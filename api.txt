
--- FILE: Dockerfile ---
# --- Stage 1: Build ---
FROM maven:3.9-eclipse-temurin-21 AS builder
WORKDIR /app

# Copie du pom.xml et t√©l√©chargement des d√©pendances (mise en cache des layers)
COPY pom.xml .
RUN mvn dependency:go-offline

# Copie du code source et compilation
COPY src ./src
RUN mvn clean package -DskipTests

# --- Stage 2: Run ---
FROM eclipse-temurin:21-jre-jammy
WORKDIR /app

# Cr√©ation d'un utilisateur non-root pour la s√©curit√© (Standard Tramasys)
RUN addgroup yowyob && adduser yowyob --ingroup yowyob
USER yowyob:yowyob

# Copie du JAR depuis l'√©tape de build
COPY --from=builder /app/target/*.jar app.jar

# Variables d'environnement par d√©faut
# Note: Les variables DB_USER, DB_PASSWORD, AUTH_JWT_SECRET doivent √™tre inject√©es au runtime
ENV SPRING_PROFILES_ACTIVE=prod

# Exposition du port
EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]


--- FILE: api.txt ---


--- FILE: docker-compose.yml ---
services:
  # 1. Base de donn√©es PostgreSQL
  postgres:
    image: postgres:16
    container_name: ride-go-db
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: yowyob_db
      POSTGRES_USER: fleet_admin
      POSTGRES_PASSWORD: fleet_password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # 2. Cache Redis pour le tracking GPS
  redis:
    image: redis:alpine
    container_name: ride-go-redis
    ports:
      - "6379:6379"
    command: redis-server --requirepass password

  # 3. Kafka (Redpanda) pour les notifications
  redpanda:
    image: docker.redpanda.com/redpandadata/redpanda:latest
    container_name: ride-go-kafka
    ports:
      - "9092:9092"
    command:
      - redpanda start
      - --overprovisioned
      - --smp 1
      - --memory 1G
      - --reserve-memory 0M
      - --node-id 0
      - --check=false
      - --kafka-addr plaintext://0.0.0.0:29092,external://0.0.0.0:9092
      - --advertise-kafka-addr plaintext://redpanda:29092,external://localhost:9092

volumes:
  postgres_data:

--- FILE: .mvn/wrapper/maven-wrapper.properties ---
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip


--- FILE: bin/compose.yaml ---
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password
      POSTGRES_DB: reactivedb
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"

  kafka:
    image: bitnami/kafka:3.5
    ports:
      - "9092:9092"
    environment:
      - KAFKA_CFG_NODE_ID=0
      - KAFKA_CFG_PROCESS_ROLES=controller,broker
      - KAFKA_CFG_CONTROLLER_QUORUM_VOTERS=0@kafka:9093
      - KAFKA_CFG_LISTENERS=PLAINTEXT://:9092,CONTROLLER://:9093
      - KAFKA_CFG_ADVERTISED_LISTENERS=PLAINTEXT://localhost:9092
      - KAFKA_CFG_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      - KAFKA_CFG_CONTROLLER_LISTENER_NAMES=CONTROLLER

  # Stock service Mock
  stock-mock:
    image: wiremock/wiremock:2.35.0
    ports:
      - "8081:8080"
    # start the wiremock
    command: ["--verbose", "--global-response-templating"]

volumes:
  postgres_data:

--- FILE: bin/.mvn/wrapper/maven-wrapper.properties ---
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip


--- FILE: bin/src/main/resources/application.yml ---
server:
  port: 8080

spring:
  application:
    name: reactive-hexagonal
  
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/reactivedb
    username: user
    password: password
  
  sql:
    init:
      mode: always # start the scheme

  data:
    redis:
      host: localhost
      port: 6379

  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# Custom Config 
application:
  external:
    stock-service-url: http://localhost:8081 # Wiremock

# Resilience4j Config
resilience4j:
  circuitbreaker:
    instances:
      stock-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5

--- FILE: bin/src/main/resources/schema.sql ---
CREATE TABLE IF NOT EXISTS products (
    id UUID PRIMARY KEY,
    name VARCHAR(255),
    price DECIMAL(10, 2),
    status VARCHAR(50)
);

--- FILE: src/main/java/com/yowyob/rideandgo/RideAndGoApplication.java ---
package com.yowyob.rideandgo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@EnableScheduling
@SpringBootApplication
public class RideAndGoApplication {

	public static void main(String[] args) {
		SpringApplication.run(RideAndGoApplication.class, args);
	}

}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/messaging/HttpNotificationAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.messaging;

import com.yowyob.rideandgo.domain.ports.out.SendNotificationPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.NotificationApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Slf4j
@Primary
@Component
@RequiredArgsConstructor
@ConditionalOnProperty(name = "application.notification.mode", havingValue = "http", matchIfMissing = true)
public class HttpNotificationAdapter implements SendNotificationPort {

    private final NotificationApiClient notificationApiClient;

    @Override
    public Mono<Boolean> sendNotification(SendNotificationRequest request) {
        log.info("üìß Sending HTTP Notification [Template: {}] to {}", request.templateId(), request.to());
        
        return notificationApiClient.sendNotification(request)
                .thenReturn(true)
                .onErrorResume(e -> {
                    log.error("Failed to send notification via HTTP: {}", e.getMessage());
                    return Mono.just(false);
                });
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/messaging/OfferEventPublisherAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.messaging;

import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.ports.out.OfferEventPublisherPort;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Slf4j
@Component
@RequiredArgsConstructor
public class OfferEventPublisherAdapter implements OfferEventPublisherPort {

    private final KafkaTemplate<String, Offer> kafkaTemplate;

    @Value("${application.kafka.topics.offer-created}")
    private String topic;

    @Override
    public Mono<Void> publishOfferCreatedEvent(Offer offer) {
        return Mono.fromFuture(kafkaTemplate.send(topic, offer.id().toString(), offer))
                .then();
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/DriverR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.exception.DriverProfileNotValidatedException;
import com.yowyob.rideandgo.domain.model.Driver;
import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.DriverEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.DriverR2dbcRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class DriverR2dbcAdapter implements DriverRepositoryPort {
    private final DriverR2dbcRepository driverRepository;

    @Override
    public Mono<Boolean> setOnlineStatus(UUID driverId, boolean isOnline) {
        return driverRepository.findById(driverId)
                .switchIfEmpty(Mono.error(new IllegalStateException("Profil chauffeur introuvable.")))
                .flatMap(entity -> {
                    if (isOnline && !entity.isProfileValidated()) {
                        return Mono.error(new DriverProfileNotValidatedException("Profil non valid√©."));
                    }
                    entity.setOnline(isOnline);
                    entity.setNewEntity(false);
                    return driverRepository.save(entity).thenReturn(true);
                });
    }

    @Override
    public Mono<Driver> save(Driver driver) {
        // ‚úÖ Mapping des nouveaux champs rating et totalReviewsCount
        DriverEntity entity = new DriverEntity(
                driver.id(), driver.status(), driver.licenseNumber(), driver.hasCar(),
                driver.isOnline(), driver.isProfileCompleted(), driver.vehicleId(),
                driver.isProfileValidated(), driver.isSyndicated(),
                driver.rating(), driver.totalReviewsCount(), // ICI
                false);

        return driverRepository.existsById(driver.id())
                .flatMap(exists -> {
                    entity.setNewEntity(!exists);
                    return driverRepository.save(entity);
                })
                .map(this::mapToDomain);
    }

    @Override
    public Mono<Driver> findById(UUID driverId) {
        return driverRepository.findById(driverId).map(this::mapToDomain);
    }

    @Override
    public Flux<Driver> findAll() {
        return driverRepository.findAll().map(this::mapToDomain);
    }

    @Override
    public Mono<Driver> createDriver(UUID userId) {
        return driverRepository.findById(userId)
                .switchIfEmpty(Mono.defer(() -> {
                    DriverEntity newEntity = new DriverEntity();
                    newEntity.setId(userId);
                    newEntity.setStatus("OFFLINE");
                    newEntity.setOnline(false);
                    newEntity.setProfileCompleted(false);
                    newEntity.setLicenseNumber("PENDING");
                    newEntity.setProfileValidated(true);
                    newEntity.setRating(0.0); // Initialisation
                    newEntity.setTotalReviewsCount(0); // Initialisation
                    newEntity.setNewEntity(true);
                    return driverRepository.save(newEntity);
                }))
                .map(this::mapToDomain);
    }

    @Override
    public Mono<Driver> validateProfile(UUID driverId) {
        return driverRepository.findById(driverId)
                .flatMap(entity -> {
                    entity.setProfileValidated(true);
                    entity.setNewEntity(false);
                    return driverRepository.save(entity);
                })
                .map(this::mapToDomain);
    }

    @Override
    public Flux<Driver> findAllPendingValidation() {
        return driverRepository.findByIsProfileValidatedFalse().map(this::mapToDomain);
    }

    private Driver mapToDomain(DriverEntity entity) {
        return Driver.builder()
                .id(entity.getId())
                .status(entity.getStatus())
                .licenseNumber(entity.getLicenseNumber())
                .hasCar(entity.isHasCar())
                .isOnline(entity.isOnline())
                .isProfileCompleted(entity.isProfileCompleted())
                .isProfileValidated(entity.isProfileValidated())
                .isSyndicated(entity.isSyndicated())
                .vehicleId(entity.getVehicleId())
                .rating(entity.getRating() != null ? entity.getRating() : 0.0)
                .totalReviewsCount(entity.getTotalReviewsCount() != null ? entity.getTotalReviewsCount() : 0)
                .build();
    }

    @Override
    public Flux<String> findDeviceTokensOfOnlineDrivers() {
        return driverRepository.findDeviceTokensOfActiveDrivers();
    }

    @Override
    public Flux<String> findEmailsOfEligibleDrivers() {
        return driverRepository.findEmailsOfEligibleDrivers();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/DriverTrajectoryR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.DriverTrajectory;
import com.yowyob.rideandgo.domain.ports.out.DriverTrajectoryRepositoryPort;
import io.r2dbc.postgresql.codec.Json;
import lombok.RequiredArgsConstructor;

import java.time.LocalDateTime;
import java.util.UUID;

import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.stereotype.Component;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Component
@RequiredArgsConstructor
public class DriverTrajectoryR2dbcAdapter implements DriverTrajectoryRepositoryPort {

    private final DatabaseClient databaseClient;

    @Override
    public Mono<Void> save(DriverTrajectory trajectory) {
        String sql = """
                    INSERT INTO ride_and_go.driver_trajectory_history
                    (id, driver_id, start_time, end_time, points_count, trajectory_data)
                    VALUES (:id, :driverId, :start, :end, :count, :data)
                """;

        return databaseClient.sql(sql)
                .bind("id", trajectory.id())
                .bind("driverId", trajectory.driverId())
                .bind("start", trajectory.startTime())
                .bind("end", trajectory.endTime())
                .bind("count", trajectory.pointsCount())
                // Conversion String -> JSONB pour Postgres
                .bind("data", Json.of(trajectory.trajectoryDataJson()))
                .then();
    }

    @Override
    public Flux<DriverTrajectory> findAllByDriverId(UUID driverId) {
        String sql = "SELECT * FROM ride_and_go.driver_trajectory_history WHERE driver_id = :driverId ORDER BY start_time DESC";

        return databaseClient.sql(sql)
                .bind("driverId", driverId)
                .map((row, metadata) -> DriverTrajectory.builder()
                        .id(row.get("id", UUID.class))
                        .driverId(row.get("driver_id", UUID.class))
                        .startTime(row.get("start_time", LocalDateTime.class))
                        .endTime(row.get("end_time", LocalDateTime.class))
                        .pointsCount(row.get("points_count", Integer.class))
                        // On r√©cup√®re le contenu JSONB sous forme de String
                        .trajectoryDataJson(row.get("trajectory_data", String.class))
                        .build())
                .all();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/NotificationHistoryR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.Notification;
import com.yowyob.rideandgo.domain.ports.out.NotificationHistoryRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.NotificationEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.NotificationR2dbcRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.PageRequest;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import java.time.LocalDateTime;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class NotificationHistoryR2dbcAdapter implements NotificationHistoryRepositoryPort {
    private final NotificationR2dbcRepository repository;
    private final DatabaseClient databaseClient;

    @Override
    public Mono<Void> save(Notification domain) {
        NotificationEntity entity = new NotificationEntity(
                domain.id(),
                domain.userId(),
                domain.title(),
                domain.message(),
                domain.type(),
                domain.isRead(),
                LocalDateTime.now(),
                domain.dataJson(),
                true // New
        );
        return repository.save(entity).then();
    }

    @Override
    public Mono<PagedResult<Notification>> getUserNotifications(UUID userId, int page, int size) {
        return repository.countByUserId(userId)
                .flatMap(total -> {
                    if (total == 0) {
                        return Mono.just(new PagedResult<Notification>(java.util.Collections.emptyList(), 0, 0, page));
                    }

                    int totalPages = (int) Math.ceil((double) total / size);

                    return repository.findByUserIdOrderByCreatedAtDesc(userId, PageRequest.of(page, size))
                            .map(this::toDomain)
                            .collectList()
                            .map(content -> new PagedResult<>(content, total, totalPages, page));
                });
    }

    @Override
    public Mono<Void> markAsRead(UUID notificationId) {
        return repository.findById(notificationId)
                .flatMap(entity -> {
                    entity.setRead(true);
                    entity.setNewEntity(false); // Update
                    return repository.save(entity);
                })
                .then();
    }

    @Override
    public Mono<Void> markAllAsReadForUser(UUID userId) {
        String sql = "UPDATE notifications SET is_read = true WHERE user_id = :userId AND is_read = false";
        return databaseClient.sql(sql)
                .bind("userId", userId)
                .then();
    }

    private Notification toDomain(NotificationEntity entity) {
        return new Notification(
                entity.getId(),
                entity.getUserId(),
                entity.getTitle(),
                entity.getMessage(),
                entity.getType(),
                entity.isRead(),
                entity.getCreatedAt(),
                entity.getData());
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/NotificationSettingsR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.NotificationSettings;
import com.yowyob.rideandgo.domain.ports.out.NotificationSettingsRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.NotificationSettingsEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.NotificationSettingsR2dbcRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Component
@RequiredArgsConstructor
public class NotificationSettingsR2dbcAdapter implements NotificationSettingsRepositoryPort {

    private final NotificationSettingsR2dbcRepository repository;

    @Override
    public Mono<NotificationSettings> getSettings(UUID userId) {
        return repository.findById(userId)
                .map(this::toDomain)
                // Si pas de settings en base, on retourne les d√©fauts
                .defaultIfEmpty(NotificationSettings.defaults(userId));
    }

    @Override
    public Mono<Void> saveSettings(NotificationSettings settings) {
        return repository.findById(settings.userId())
                .map(entity -> {
                    updateEntity(entity, settings);
                    entity.setNewEntity(false);
                    return entity;
                })
                .switchIfEmpty(Mono.defer(() -> {
                    NotificationSettingsEntity entity = new NotificationSettingsEntity();
                    entity.setUserId(settings.userId());
                    updateEntity(entity, settings);
                    entity.setNewEntity(true);
                    return Mono.just(entity);
                }))
                .flatMap(repository::save)
                .then();
    }

    private void updateEntity(NotificationSettingsEntity entity, NotificationSettings domain) {
        entity.setEnableEmail(domain.emailEnabled());
        entity.setEnablePush(domain.pushEnabled());
        entity.setEnableSms(domain.smsEnabled());
        entity.setEnableWhatsapp(domain.whatsappEnabled());
    }

    private NotificationSettings toDomain(NotificationSettingsEntity entity) {
        return new NotificationSettings(
            entity.getUserId(),
            entity.isEnableEmail(),
            entity.isEnableSms(),
            entity.isEnablePush(),
            entity.isEnableWhatsapp()
        );
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/OfferR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.model.Bid;
import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.ports.out.OfferRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferAgreementEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.OfferAgreementR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.OfferR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.mappers.OfferMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class OfferR2dbcAdapter implements OfferRepositoryPort {

    private final OfferAgreementR2dbcRepository offerAgreementRepository;
    private final OfferR2dbcRepository offerRepository;
    private final OfferMapper offerMapper;

    @Override
    @Transactional
    public Mono<Offer> save(Offer offer) {
        log.info("üíæ SAVE OFFER: ID={}, Bids Count={}", offer.id(),
                (offer.bids() != null ? offer.bids().size() : "null"));

        OfferEntity entity = offerMapper.toEntity(offer);

        return offerRepository.existsById(offer.id())
                .flatMap(exists -> {
                    if (!exists)
                        entity.setNewEntity(true);
                    return offerRepository.save(entity);
                })
                .flatMap(savedOffer -> {
                    if (offer.bids() == null || offer.bids().isEmpty()) {
                        log.info("‚ö†Ô∏è No bids to save for offer {}", offer.id());
                        return Mono.just(savedOffer);
                    }

                    return Flux.fromIterable(offer.bids())
                            .flatMap(bid -> {
                                log.debug("Processing bid for driver {}", bid.driverId());
                                return offerAgreementRepository
                                        .findByOfferIdAndDriverId(savedOffer.getId(), bid.driverId())
                                        .doOnNext(
                                                found -> log.debug("Bid already exists for driver {}", bid.driverId()))
                                        .switchIfEmpty(
                                                Mono.defer(() -> {
                                                    log.info("‚ûï INSERTING BID: Driver {} -> Offer {}", bid.driverId(),
                                                            savedOffer.getId());
                                                    OfferAgreementEntity link = new OfferAgreementEntity();
                                                    link.setId(Utils.generateUUID());
                                                    link.setOfferId(savedOffer.getId());
                                                    link.setDriverId(bid.driverId());
                                                    link.asNew();
                                                    return offerAgreementRepository.save(link)
                                                            .doOnSuccess(
                                                                    s -> log.info("‚úÖ Inserted link ID: {}", s.getId()))
                                                            .doOnError(e -> log.error("‚ùå Failed to insert link: {}",
                                                                    e.getMessage()));
                                                }));
                            })
                            .collectList() // Force l'ex√©cution
                            .map(links -> {
                                log.info("üîÑ Processed {} links", links.size());
                                return savedOffer;
                            });
                })
                .flatMap(savedOffer -> {
                    // Force reload pour v√©rifier ce qui a √©t√© persist√©
                    return findById(savedOffer.getId())
                            .doOnSuccess(o -> log.info("üîç Reloaded Offer: Bids Count={}",
                                    (o.bids() != null ? o.bids().size() : 0)));
                });
    }

    @Override
    public Flux<Offer> findLatestPending(int limit) {
        return offerRepository.findAll()
                .filter(o -> o.getState() == OfferState.PENDING || o.getState() == OfferState.BID_RECEIVED)
                .sort((o1, o2) -> o2.getCreatedDate().compareTo(o1.getCreatedDate()))
                .take(limit)
                .flatMap(this::enrichOfferWithAgreements)
                .map(this::mapToDomainManual);
    }

    @Override
    public Mono<Offer> findById(UUID offerId) {
        return offerRepository.findById(offerId)
                .flatMap(this::enrichOfferWithAgreements)
                .map(this::mapToDomainManual);
    }

    @Override
    public Flux<Offer> findAll() {
        return offerRepository.findAll()
                .flatMap(this::enrichOfferWithAgreements)
                .map(this::mapToDomainManual);
    }

    private Mono<OfferEntity> enrichOfferWithAgreements(OfferEntity entity) {
        return offerAgreementRepository.findByOfferId(entity.getId())
                .collectList()
                .map(agreements -> {
                    entity.setAgreements(agreements != null ? agreements : Collections.emptyList());
                    // Log debug pour voir si on r√©cup√®re bien de la base
                    // if (!entity.getAgreements().isEmpty()) log.debug("DB returned {} agreements
                    // for offer {}", entity.getAgreements().size(), entity.getId());
                    return entity;
                });
    }

    private Offer mapToDomainManual(OfferEntity entity) {
        Offer domain = offerMapper.toDomain(entity);
        if (entity.getAgreements() != null && !entity.getAgreements().isEmpty()) {
            return domain.withBids(entity.getAgreements().stream()
                    .map(a -> Bid.builder().driverId(a.getDriverId()).build())
                    .collect(Collectors.toList()));
        } else {
            return domain.withBids(Collections.emptyList());
        }
    }

    @Override
    public Mono<Boolean> delete(Offer offer) {
        return offerRepository.delete(offerMapper.toEntity(offer)).thenReturn(true);
    }

    @Override
    public Mono<Boolean> exists(Offer offer) {
        return offerRepository.existsById(offer.id());
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/ReviewR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.Review;
import com.yowyob.rideandgo.domain.ports.out.ReviewRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.ReviewEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.ReviewR2dbcRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.time.LocalDateTime;
import java.util.UUID;

@Component
@RequiredArgsConstructor
public class ReviewR2dbcAdapter implements ReviewRepositoryPort {
    private final ReviewR2dbcRepository repository;

    @Override
    public Mono<Review> save(Review domain) {
        ReviewEntity entity = new ReviewEntity(
                domain.id(), domain.rideId(), domain.passengerId(),
                domain.driverId(), domain.rating(), domain.comment(),
                LocalDateTime.now(), true);
        return repository.save(entity).map(this::mapToDomain);
    }

    @Override
    public Mono<Double> getAverageRatingForDriver(UUID driverId) {
        return repository.getAverageRatingForDriver(driverId).defaultIfEmpty(0.0);
    }

    @Override
    public Mono<Long> countReviewsForDriver(UUID driverId) {
        return repository.countReviewsForDriver(driverId).defaultIfEmpty(0L);
    }

    @Override
    public Flux<Review> findAllByDriverId(UUID driverId) {
        return repository.findByDriverIdOrderByCreatedAtDesc(driverId)
                .map(this::mapToDomain);
    }

    private Review mapToDomain(ReviewEntity e) {
        return Review.builder()
                .id(e.getId()).rideId(e.getRideId()).passengerId(e.getPassengerId())
                .driverId(e.getDriverId()).rating(e.getRating()).comment(e.getComment())
                .createdAt(e.getCreatedAt()).build();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/RideR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RideEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.RideR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.mappers.RideMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class RideR2dbcAdapter implements RideRepositoryPort {
    private final RideR2dbcRepository repository;
    private final RideMapper mapper;

    @Override
    @Transactional
    public Mono<Ride> save(Ride ride) {
        RideEntity entity = mapper.toEntity(ride);
        entity.setNewEntity(ride.state() == RideState.CREATED && ride.timeReal() == 0);

        return repository.save(entity)
                .map(mapper::toDomain)
                .switchIfEmpty(Mono.just(ride));
    }

    @Override
    public Mono<Ride> findRideById(UUID id) {
        return repository.findById(id).map(mapper::toDomain);
    }

    @Override
    public Mono<Ride> findCurrentRideByDriverId(UUID driverId) {
        return repository.findActiveRideByDriverId(driverId).map(mapper::toDomain);
    }

    @Override
    public Mono<Ride> findRideByOfferId(UUID offerId) {
        return repository.findByOfferId(offerId).map(mapper::toDomain);
    }

    @Override
    public Mono<Long> countCompletedRidesByDriverId(UUID driverId) {
        return repository.countCompletedByDriverId(driverId);
    }

    @Override
    public Flux<Ride> findRideHistoryByUserId(UUID userId, int page, int size) {
        long offset = (long) page * size;
        return repository.findHistoryByUserId(userId, offset, size).map(mapper::toDomain);
    }

    @Override
    public Flux<Ride> findRideHistoryByDriverId(UUID driverId, int page, int size) {
        long offset = (long) page * size;
        return repository.findHistoryByDriverId(driverId, offset, size).map(mapper::toDomain);
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/RoleR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.Permission;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.RoleRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.PermissionR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.RoleR2dbcRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.UUID;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class RoleR2dbcAdapter implements RoleRepositoryPort {

    private final RoleR2dbcRepository roleRepository;
    private final PermissionR2dbcRepository permissionRepository;

    @Override
    public Mono<Role> findByRoleName(RoleType type) {
        return roleRepository.findByName(type).next()
                .flatMap(this::enrichRole);
    }

    @Override
    public Mono<Role> findRoleById(UUID roleId) {
        return roleRepository.findById(roleId)
                .flatMap(this::enrichRole);
    }

    private Mono<Role> enrichRole(RoleEntity entity) {
        return permissionRepository.findAllByRoleId(entity.getId())
                .map(p -> new Permission(p.getId(), p.getName()))
                .collect(Collectors.toSet())
                .map(perms -> Role.builder()
                        .id(entity.getId())
                        // ‚úÖ CORRECTION : entity.getType() -> entity.getName()
                        .type(entity.getName()) 
                        .permissions(perms)
                        .build());
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/UserDeviceR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.ports.out.UserDeviceRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserDeviceEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.UserDeviceR2dbcRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class UserDeviceR2dbcAdapter implements UserDeviceRepositoryPort {

    private final UserDeviceR2dbcRepository repository;

    @Override
    public Mono<Void> saveDeviceToken(UUID userId, String token, String platform) {
        return repository.findById(userId)
                .map(entity -> {
                    entity.setDeviceToken(token);
                    entity.setPlatform(platform);
                    entity.setLastUpdatedAt(LocalDateTime.now());
                    entity.setNewEntity(false); // Update
                    return entity;
                })
                .switchIfEmpty(Mono.defer(() -> {
                    UserDeviceEntity entity = new UserDeviceEntity(userId, token, platform, LocalDateTime.now(), true);
                    return Mono.just(entity);
                }))
                .flatMap(repository::save)
                .then();
    }

    @Override
    public Mono<String> findDeviceTokenByUserId(UUID userId) {
        return repository.findById(userId)
                .map(UserDeviceEntity::getDeviceToken);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/UserR2dbcAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.Permission;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.*;
import com.yowyob.rideandgo.infrastructure.mappers.UserMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.r2dbc.core.DatabaseClient;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class UserR2dbcAdapter implements UserRepositoryPort {

    private final UserR2dbcRepository userRepository;
    private final RoleR2dbcRepository roleRepository;
    private final PermissionR2dbcRepository permissionRepository;
    private final UserMapper userMapper;
    private final DatabaseClient databaseClient;

    private static final String SCHEMA = "ride_and_go"; // Nom du sch√©ma

    @Override
    public Mono<User> findUserById(UUID userId) {
        return userRepository.findById(userId)
                .flatMap(this::enrichUser);
    }

    @Override
    public Flux<User> findAll() {
        return userRepository.findAll()
                .flatMap(this::enrichUser);
    }

    @Override
    public Flux<User> findByRoleName(RoleType type) {
        return roleRepository.findByName(type)
                .flatMap(role -> userRepository.findAllByRoleId(role.getId()))
                .flatMap(this::enrichUser);
    }

    @Override
    @Transactional
    public Mono<User> save(User user) {
        UserEntity entity = userMapper.toEntity(user);

        return userRepository.existsById(user.id())
                .flatMap(exists -> {
                    if (!exists)
                        entity.setNewEntity(true);
                    return userRepository.save(entity);
                })
                .flatMap(savedEntity -> syncRoles(user, savedEntity))
                .flatMap(savedEntity -> syncActorTables(user, savedEntity))
                .map(savedEntity -> user);
    }

    /**
     * Ins√®re l'utilisateur dans la table 'customers' ou 'drivers' selon son r√¥le.
     * C'est n√©cessaire pour satisfaire les FK des autres tables (offers, rides).
     * CORRECTION: Ajout du pr√©fixe de sch√©ma.
     */
    private Mono<UserEntity> syncActorTables(User user, UserEntity savedEntity) {
        if (user.roles() == null || user.roles().isEmpty())
            return Mono.just(savedEntity);

        return Flux.fromIterable(user.roles())
                .flatMap(role -> {
                    String roleName = role.type().name();

                    if (roleName.contains("PASSENGER") || roleName.contains("CUSTOMER")) {
                        String sql = String.format(
                                "INSERT INTO %s.customers (id, code, payment_method) VALUES (:id, :code, 'CASH') ON CONFLICT DO NOTHING",
                                SCHEMA);
                        return databaseClient.sql(sql)
                                .bind("id", savedEntity.getId())
                                .bind("code", "CUST-" + savedEntity.getId().toString().substring(0, 8))
                                .then();
                    } else if (roleName.contains("DRIVER")) {
                        // Pour un driver, il faut d'abord l'ins√©rer dans 'business_actors' puis dans
                        // 'drivers'.
                        String sqlBA = String.format(
                                "INSERT INTO %s.business_actors (id, name, email_address, phone_number) VALUES (:id, :name, :email, :phone) ON CONFLICT DO NOTHING",
                                SCHEMA);
                        String sqlDriver = String.format(
                                "INSERT INTO %s.drivers (id, status, license_number) VALUES (:id, 'AVAILABLE', 'UNKNOWN') ON CONFLICT DO NOTHING",
                                SCHEMA);

                        return databaseClient.sql(sqlBA)
                                .bind("id", savedEntity.getId())
                                .bind("name", savedEntity.getName())
                                .bind("email", savedEntity.getEmail())
                                .bind("phone", savedEntity.getTelephone())
                                .then()
                                .then(databaseClient.sql(sqlDriver)
                                        .bind("id", savedEntity.getId())
                                        .then());
                    }
                    return Mono.empty();
                })
                .then(Mono.just(savedEntity));
    }

    @Override
    public Mono<Boolean> delete(User user) {
        return userRepository.deleteById(user.id()).thenReturn(true).onErrorReturn(false);
    }

    @Override
    public Mono<Boolean> deleteById(UUID userId) {
        return userRepository.deleteById(userId).thenReturn(true).onErrorReturn(false);
    }

    @Override
    public Mono<Boolean> exists(User user) {
        return userRepository.existsById(user.id());
    }

    // --- NOUVELLE IMPLEMENTATION : ADD ROLE ---
    @Override
    public Mono<Void> addRoleToUser(UUID userId, RoleType roleType) {
        return roleRepository.findByName(roleType).next()
                .flatMap(roleEntity -> {
                    String sql = String.format(
                            "INSERT INTO %s.user_has_roles (user_id, role_id) VALUES (:userId, :roleId) ON CONFLICT DO NOTHING",
                            SCHEMA);
                    return databaseClient.sql(sql)
                            .bind("userId", userId)
                            .bind("roleId", roleEntity.getId())
                            .then();
                });
    }

    private Mono<User> enrichUser(UserEntity entity) {
        // Fetch Roles and their specific permissions
        Mono<Set<Role>> rolesMono = roleRepository.findAllByUserId(entity.getId())
                .flatMap(roleEntity -> permissionRepository.findAllByRoleId(roleEntity.getId())
                        .map(p -> new Permission(p.getId(), p.getName()))
                        .collect(Collectors.toSet())
                        .map(perms -> Role.builder()
                                .id(roleEntity.getId())
                                .type(roleEntity.getName())
                                .permissions(perms)
                                .build()))
                .collect(Collectors.toSet());

        // Fetch permissions assigned directly to the user
        Mono<Set<Permission>> directPermsMono = permissionRepository.findDirectPermissionsByUserId(entity.getId())
                .map(p -> new Permission(p.getId(), p.getName()))
                .collect(Collectors.toSet());

        // Combine all reactive streams
        return Mono.zip(rolesMono, directPermsMono)
                .map(tuple -> User.builder()
                        .id(entity.getId())
                        .name(entity.getName())
                        .email(entity.getEmail())
                        .telephone(entity.getTelephone())
                        .roles(tuple.getT1())
                        .directPermissions(tuple.getT2())
                        .build());
    }

    /**
     * M√©thode helper pour g√©rer la table de liaison user_has_roles
     */
    private Mono<UserEntity> syncRoles(User domainUser, UserEntity savedEntity) {
        if (domainUser.roles() == null || domainUser.roles().isEmpty()) {
            return Mono.just(savedEntity);
        }

        String sqlDelete = String.format("DELETE FROM %s.user_has_roles WHERE user_id = :userId", SCHEMA);

        return databaseClient.sql(sqlDelete)
                .bind("userId", savedEntity.getId())
                .then()
                .thenMany(Flux.fromIterable(domainUser.roles()))
                .flatMap(domainRole -> roleRepository.findByName(domainRole.type()).next()
                        .switchIfEmpty(Mono.defer(() -> {
                            RoleEntity newRole = new RoleEntity(
                                    java.util.UUID.randomUUID(),
                                    domainRole.type(),
                                    LocalDateTime.now(),
                                    LocalDateTime.now(),
                                    true);
                            return roleRepository.save(newRole);
                        }))
                        .flatMap(roleEntity -> {
                            String sqlInsert = String.format(
                                    "INSERT INTO %s.user_has_roles (user_id, role_id) VALUES (:userId, :roleId) ON CONFLICT DO NOTHING",
                                    SCHEMA);
                            return databaseClient.sql(sqlInsert)
                                    .bind("userId", savedEntity.getId())
                                    .bind("roleId", roleEntity.getId())
                                    .then();
                        }))
                .then(Mono.just(savedEntity));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/DriverR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.DriverEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface DriverR2dbcRepository extends ReactiveCrudRepository<DriverEntity, UUID> {
    @Query("""
                SELECT ud.device_token
                FROM drivers d
                JOIN user_devices ud ON d.id = ud.user_id
                WHERE d.is_online = true
                  AND d.is_profile_completed = true
                  AND d.is_profile_validated = true
            """)
    Flux<String> findDeviceTokensOfActiveDrivers();

    @Query("""
                SELECT u.email_address
                FROM drivers d
                JOIN users u ON d.id = u.id
                WHERE d.is_online = true
                  AND d.is_profile_completed = true
                  AND d.is_profile_validated = true
            """)
    Flux<String> findEmailsOfEligibleDrivers();

    Flux<DriverEntity> findByIsProfileValidatedFalse();
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/NotificationR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.NotificationEntity;
import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface NotificationR2dbcRepository extends ReactiveCrudRepository<NotificationEntity, UUID> {

    // R√©cup√©ration pagin√©e par utilisateur
    Flux<NotificationEntity> findByUserIdOrderByCreatedAtDesc(UUID userId, Pageable pageable);

    // Compte pour la pagination
    Mono<Long> countByUserId(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/NotificationSettingsR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.NotificationSettingsEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import java.util.UUID;

public interface NotificationSettingsR2dbcRepository extends ReactiveCrudRepository<NotificationSettingsEntity, UUID> {
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/OfferAgreementR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferAgreementEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface OfferAgreementR2dbcRepository extends ReactiveCrudRepository<OfferAgreementEntity, UUID> {
    
    /**
     * Checks if a driver has already applied to a specific offer.
     */
    Mono<OfferAgreementEntity> findByOfferIdAndDriverId(UUID offerId, UUID driverId);

    /**
     * Lists all applications for a given offer.
     */
    Flux<OfferAgreementEntity> findByOfferId(UUID offerId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/OfferR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;

import java.util.UUID;

public interface OfferR2dbcRepository extends ReactiveCrudRepository<OfferEntity, UUID> {
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/PermissionR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.PermissionEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface PermissionR2dbcRepository extends ReactiveCrudRepository<PermissionEntity, UUID> {
    
    @Query("SELECT p.* FROM permissions p JOIN role_has_permissions rhp ON p.id = rhp.permission_id WHERE rhp.role_id = :roleId")
    Flux<PermissionEntity> findAllByRoleId(UUID roleId);

    @Query("SELECT p.* FROM permissions p JOIN user_has_permissions uhp ON p.id = uhp.permission_id WHERE uhp.user_id = :userId")
    Flux<PermissionEntity> findDirectPermissionsByUserId(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/ReviewR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.ReviewEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ReviewR2dbcRepository extends ReactiveCrudRepository<ReviewEntity, UUID> {
    
    Flux<ReviewEntity> findByDriverIdOrderByCreatedAtDesc(UUID driverId);

    // ‚úÖ Utilisation de COALESCE et CAST pour garantir un Double 0.0 (jamais NULL)
    @Query("SELECT CAST(COALESCE(AVG(rating), 0.0) AS DOUBLE PRECISION) FROM reviews WHERE driver_id = :driverId")
    Mono<Double> getAverageRatingForDriver(UUID driverId);

    @Query("SELECT COUNT(*) FROM reviews WHERE driver_id = :driverId")
    Mono<Long> countReviewsForDriver(UUID driverId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/RideR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RideEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface RideR2dbcRepository extends ReactiveCrudRepository<RideEntity, UUID> {
    @Query("SELECT * FROM rides WHERE driver_id = :driverId AND state IN ('CREATED', 'ONGOING') LIMIT 1")
    Mono<RideEntity> findActiveRideByDriverId(UUID driverId);

    Mono<RideEntity> findByOfferId(UUID offerId);

    @Query("SELECT COUNT(*) FROM rides WHERE driver_id = :driverId AND state = 'COMPLETED'")
    Mono<Long> countCompletedByDriverId(UUID driverId);

    @Query("SELECT * FROM rides WHERE (driver_id = :userId OR passenger_id = :userId) ORDER BY created_at DESC OFFSET :offset LIMIT :limit")
    Flux<RideEntity> findHistoryByUserId(UUID userId, long offset, int limit);

    @Query("SELECT * FROM rides WHERE driver_id = :driverId ORDER BY created_at DESC OFFSET :offset LIMIT :limit")
    Flux<RideEntity> findHistoryByDriverId(UUID driverId, long offset, int limit);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/RoleR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux; // Import Flux
import java.util.UUID;

public interface RoleR2dbcRepository extends ReactiveCrudRepository<RoleEntity, UUID> {
    
    // CORRECTION : On renvoie Flux au lieu de Mono pour √©viter l'erreur "Non unique result"
    Flux<RoleEntity> findByName(RoleType name);

    @Query("SELECT r.* FROM roles r JOIN user_has_roles uhr ON r.id = uhr.role_id WHERE uhr.user_id = :userId")
    Flux<RoleEntity> findAllByUserId(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/UserDeviceR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserDeviceEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import java.util.UUID;

public interface UserDeviceR2dbcRepository extends ReactiveCrudRepository<UserDeviceEntity, UUID> {
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/UserR2dbcRepository.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;

import java.util.UUID;

public interface UserR2dbcRepository extends ReactiveCrudRepository<UserEntity, UUID> {

    /**
     * Finds all users associated with a specific role ID using the join table.
     */
    @Query("SELECT u.* FROM users u JOIN user_has_roles uhr ON u.id = uhr.user_id WHERE uhr.role_id = :roleId")
    Flux<UserEntity> findAllByRoleId(UUID roleId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/dto/DriverContactInfo.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.dto;

import java.util.UUID;

// Projection simple pour r√©cup√©rer les infos de contact
public record DriverContactInfo(
    UUID driverId,
    String email,
    String phone
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/DriverEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("drivers")
public class DriverEntity implements Persistable<UUID> {

    @Id
    private UUID id;
    private String status;
    @Column("license_number")
    private String licenseNumber;
    @Column("has_car")
    private boolean hasCar;
    @Column("is_online")
    private boolean isOnline;
    @Column("is_profile_completed")
    private boolean isProfileCompleted;

    // --- NOUVEAUX CHAMPS ---
    @Column("vehicle_id")
    private UUID vehicleId;

    @Column("is_profile_validated")
    private boolean isProfileValidated;

    @Column("is_syndicated")
    private boolean isSyndicated;

    private Double rating;
    
    @Column("total_reviews_count")
    private Integer totalReviewsCount;

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/NotificationEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("notifications")
public class NotificationEntity implements Persistable<UUID> {
    @Id
    private UUID id;

    @Column("user_id")
    private UUID userId;

    private String title;
    private String message;
    private String type; // INFO, ALERT...

    @Column("is_read")
    private boolean isRead;

    @Column("created_at")
    private LocalDateTime createdAt;

    // On stocke le JSON sous forme de String pour simplifier le mapping R2DBC standard
    private String data; 

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() { return newEntity || id == null; }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/NotificationSettingsEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.util.UUID;

@Table("notification_settings")
@AllArgsConstructor
@NoArgsConstructor
@Data
public class NotificationSettingsEntity implements Persistable<UUID> {

    @Id
    @Column("user_id")
    private UUID userId;

    @Column("enable_email")
    private boolean enableEmail;

    @Column("enable_sms")
    private boolean enableSms;

    @Column("enable_push")
    private boolean enablePush;

    @Column("enable_whatsapp")
    private boolean enableWhatsapp;

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public UUID getId() {
        return userId;
    }

    @Override
    @Transient
    public boolean isNew() {
        return newEntity || userId == null;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/OfferAgreementEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data 
@NoArgsConstructor
@AllArgsConstructor
@Table("offer_driver_linkages") 
public class OfferAgreementEntity implements Persistable<UUID> {
    @Id
    private UUID id;

    @Column("driver_id")
    private UUID driverId;

    @Column("offer_id")
    private UUID offerId;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    // --- Gestion Insert/Update ---

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public OfferAgreementEntity asNew() {
        this.newEntity = true;
        return this;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/OfferEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import com.yowyob.rideandgo.domain.model.enums.OfferState;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data 
@NoArgsConstructor 
@AllArgsConstructor
@Table("offers") 
public class OfferEntity implements Persistable<UUID> {
    
    @Id
    private UUID id;

    @Column("passenger_id")
    private UUID passengerId;

    @Column("selected_driver_id") 
    private UUID selectedDriverId;

    @Column("start_point")
    private String startPoint;

   @Column("start_lat") // ‚úÖ Mapping DB
    private Double startLat;

    @Column("start_lon") // ‚úÖ Mapping DB
    private Double startLon;

    @Column("end_point")
    private String endPoint;

    @Column("end_lat")
    private Double endLat;

    @Column("end_lon")
    private Double endLon;

    private double price;

    @Column("state")
    private OfferState state;

    // --- NOUVEAUX CHAMPS ---
    @Column("passenger_phone")
    private String passengerPhone;

    @Column("departure_time")
    private String departureTime;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    @Transient
    private List<OfferAgreementEntity> agreements;

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean isNew) {
        this.newEntity = isNew;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/PermissionEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor 
@AllArgsConstructor
@Table("permissions")
public class PermissionEntity {
    @Id
    private UUID id;
    private String name;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/ReviewEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("reviews")
public class ReviewEntity implements Persistable<UUID> {
    @Id
    private UUID id;
    @Column("ride_id")
    private UUID rideId;
    @Column("passenger_id")
    private UUID passengerId;
    @Column("driver_id")
    private UUID driverId;
    private int rating;
    private String comment;
    @Column("created_at")
    private LocalDateTime createdAt;

    @Transient
    private boolean newEntity = false;

    @Override
    public boolean isNew() {
        return newEntity || id == null;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/RideEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("rides")
public class RideEntity implements Persistable<UUID> {
    @Id
    private UUID id;

    @Column("offer_id")
    private UUID offerId;

    @Column("driver_id")
    private UUID driverId;

    @Column("passenger_id")
    private UUID passengerId;

    private double distance;

    @Column("time_estimation")  
    private int duration;

    @Column("state")
    private RideState state;

    @Column("real_time") 
    private int timeReal;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate = LocalDateTime.now();

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    // --- Gestion Insert/Update ---

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/RoleEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable; 
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data 
@NoArgsConstructor 
@AllArgsConstructor
@Table("roles")
public class RoleEntity implements Persistable<UUID> { 
    @Id
    private UUID id;

    @Column("name")
    private RoleType name;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    // --- Gestion Insert/Update ---
    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/UserDeviceEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("user_devices")
public class UserDeviceEntity implements Persistable<UUID> {

    @Id
    @Column("user_id")
    private UUID userId;

    @Column("device_token")
    private String deviceToken;

    private String platform;

    @LastModifiedDate
    @Column("last_updated_at")
    private LocalDateTime lastUpdatedAt;

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return newEntity || userId == null;
    }
    
    // UUID est manuel (FK), donc on doit g√©rer isNew manuellement
    @Override
    public UUID getId() {
        return userId;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/UserEntity.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("users")
public class UserEntity implements Persistable<UUID> {
    @Id
    private UUID id;

    private String name; // Utilis√© pour le username

    @Column("first_name")
    private String firstName;

    @Column("last_name")
    private String lastName;

    @Column("email_address")
    private String email;

    @Column("phone_number")
    private String telephone;

    @Column("photo_uri")
    private String photoUri;

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/cache/RedisAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.cache;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.ports.out.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.data.geo.Distance;
import org.springframework.data.geo.Point;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.data.geo.Circle;
import org.springframework.data.geo.Distance;
import org.springframework.data.geo.Metrics;
import org.springframework.data.geo.Point;
import org.springframework.data.redis.connection.RedisGeoCommands;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.time.Instant;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class RedisAdapter
        implements OfferCachePort, UserCachePort, FareCachePort, LocationCachePort, CacheInvalidationPort {

    private final ReactiveRedisTemplate<String, Object> redisTemplate;

    // CL√â 1 : Le "Live" (Geo Set unique pour tous les drivers)
    // Contient : {Membre: "uuid", Score: GeoHash}
    private static final String KEY_GEO_LIVE = "drivers:geo:live";

    // CL√â 2 : Le "Buffer" (Pr√©fixe pour les listes d'historique)
    // Contient : Liste de strings "lat,lon,timestamp"
    private static final String PREFIX_HISTORY = "history:driver:";

    private static final String KEY_OFFERS_GEO = "offers:geo:pending";

    // --- LocationCachePort Implementation ---

    @Override
    public Mono<Boolean> saveLocation(UUID actorId, Double latitude, Double longitude) {
        String driverIdStr = actorId.toString();
        // Redis utilise (Longitude, Latitude) pour ses Points
        Point point = new Point(longitude, latitude);

        // 1. Mise √† jour du Live (GEOADD)
        // Ajoute ou met √† jour la position du membre dans le Set g√©ospatial
        Mono<Long> geoAdd = redisTemplate.opsForGeo()
                .add(KEY_GEO_LIVE, point, driverIdStr);

        // 2. Ajout √† l'historique (RPUSH)
        // Format compact pour √©conomiser la RAM : "lat,lon,timestamp"
        String historyEntry = String.format("%f,%f,%d", latitude, longitude, Instant.now().getEpochSecond());
        String historyKey = PREFIX_HISTORY + driverIdStr;

        Mono<Long> listPush = redisTemplate.opsForList()
                .rightPush(historyKey, historyEntry);

        // 3. S√©curit√© : TTL sur la liste d'historique (1h).
        // Si le Cron plante, ces donn√©es seront perdues apr√®s 1h mais la RAM sera
        // lib√©r√©e.
        Mono<Boolean> setTtl = redisTemplate.expire(historyKey, Duration.ofHours(1));

        // Ex√©cution parall√®le (Pipelining)
        return Mono.zip(geoAdd, listPush, setTtl)
                .map(tuple -> true)
                .doOnError(e -> log.error("‚ùå Failed to update location for {}", actorId, e))
                .onErrorReturn(false);
    }

    @Override
    public Mono<Location> getLocation(UUID actorId) {
        // opsForGeo().position() retourne un Mono<Point> correspondant au membre
        // demand√©.
        // Si le membre n'est pas dans le Set, le Mono est vide.
        return redisTemplate.opsForGeo()
                .position(KEY_GEO_LIVE, actorId.toString())
                .map(p -> new Location(p.getY(), p.getX())); // Point.y = Lat, Point.x = Lon
    }

    @Override
    public Flux<GeoResult> findNearbyDrivers(Double latitude, Double longitude, Double radiusKm) {
        // 1. D√©finir le point central (Le passager)
        Point center = new Point(longitude, latitude); // Rappel: Redis c'est (Lon, Lat)

        // 2. D√©finir le rayon de recherche
        // Distance prend (valeur, m√©trique). KILOMETERS est une constante de Spring
        // Data Redis.
        Distance radius = new Distance(radiusKm, Metrics.KILOMETERS);

        // 3. D√©finir le cercle de recherche
        org.springframework.data.geo.Circle circle = new org.springframework.data.geo.Circle(center, radius);

        // 4. Configurer la commande Redis (GEOSEARCH)
        // - includeDistance() : On veut savoir √† quelle distance ils sont
        // - includeCoordinates() : On veut leur position exacte actuelle
        // - sortAscending() : On veut les plus proches en premier
        RedisGeoCommands.GeoRadiusCommandArgs args = RedisGeoCommands.GeoRadiusCommandArgs
                .newGeoRadiusArgs()
                .includeDistance()
                .includeCoordinates()
                .sortAscending();

        // 5. Ex√©cuter la commande
        return redisTemplate.opsForGeo()
                .radius(KEY_GEO_LIVE, circle, args)
                .flatMap(geoResult -> {
                    // Mapping du r√©sultat Redis (GeoResult<RedisGeoCommands.GeoLocation<Object>>)
                    // vers notre objet de domaine (LocationCachePort.GeoResult)

                    String driverIdStr = (String) geoResult.getContent().getName();
                    Point driverPoint = geoResult.getContent().getPoint();
                    double dist = geoResult.getDistance().getValue(); // Distance dans l'unit√© demand√©e (km)

                    try {
                        UUID driverId = UUID.fromString(driverIdStr);

                        // Cr√©ation de notre objet Location interne
                        Location loc = new Location(driverPoint.getY(), driverPoint.getX()); // Y=Lat, X=Lon

                        // Cr√©ation du r√©sultat final
                        return Mono.just(new GeoResult(driverId, dist, loc));

                    } catch (IllegalArgumentException e) {
                        log.warn("‚ö†Ô∏è Found invalid UUID in Geo Set: {}", driverIdStr);
                        return Mono.empty();
                    }
                });
    }

    // --- CacheInvalidationPort Implementation ---

    @Override
    public Mono<Void> invalidateUserCache(UUID userId) {
        String userIdStr = userId.toString();
        String userKey = "user:" + userIdStr;

        log.info("üî• Invalidating cache for user {}", userId);

        // 1. Supprimer le cache profil utilisateur
        Mono<Boolean> delUser = redisTemplate.delete(userKey).map(l -> l > 0);

        // 2. Supprimer de la carte Live (ZREM / GEO REMOVE)
        // Cela le rend invisible pour la recherche de taxi
        Mono<Long> delGeo = redisTemplate.opsForGeo().remove(KEY_GEO_LIVE, userIdStr);

        // Note: On NE supprime PAS l'historique (historyKey) ici !
        // On veut que le Cron puisse le traiter et le dumper en base m√™me si l'user se
        // d√©connecte.
        // L'historique expirera tout seul gr√¢ce au TTL si le cron ne passe pas.

        return Mono.when(delUser, delGeo);
    }

    // --- OfferCachePort Implementation ---

    @Override
    public Mono<Boolean> saveInCache(Offer offer) {
        return redisTemplate.opsForValue()
                .set("offer:" + offer.id(), offer, Duration.ofMinutes(15));
    }

    @Override
    public Mono<Offer> findOfferById(UUID offerId) {
        return redisTemplate.opsForValue()
                .get("offer:" + offerId)
                .cast(Offer.class)
                .onErrorResume(e -> Mono.empty());
    }

    // --- UserCachePort Implementation ---

    @Override
    public Mono<Boolean> saveInCache(User user) {
        return redisTemplate.opsForValue()
                .set("user:" + user.id(), user, Duration.ofMinutes(10));
    }

    @Override
    public Mono<User> findUserById(UUID userId) {
        return redisTemplate.opsForValue()
                .get("user:" + userId)
                .cast(User.class);
    }

    // --- FareCachePort Implementation ---

    @Override
    public Mono<Boolean> saveInCache(Fare fare) {
        return redisTemplate.opsForValue()
                .set("fare:" + fare.id(), fare, Duration.ofMinutes(10));
    }

    @Override
    public Mono<Fare> findFareById(UUID fareId) {
        return redisTemplate.opsForValue()
                .get("fare:" + fareId)
                .cast(Fare.class);
    }

    @Override
    public Mono<Void> saveOfferLocation(UUID offerId, Double lat, Double lon) {
        return redisTemplate.opsForGeo()
                .add(KEY_OFFERS_GEO, new Point(lon, lat), offerId.toString())
                .then();
    }

    @Override
    public Mono<Void> removeOfferLocation(UUID offerId) {
        return redisTemplate.opsForGeo()
                .remove(KEY_OFFERS_GEO, offerId.toString())
                .then();
    }

    @Override
    public Flux<UUID> findNearbyOfferIds(Double lat, Double lon, Double radiusKm) {
        Circle circle = new Circle(new Point(lon, lat), new Distance(radiusKm, Metrics.KILOMETERS));
        return redisTemplate.opsForGeo()
                .radius(KEY_OFFERS_GEO, circle)
                .map(res -> UUID.fromString(res.getContent().getName().toString()));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/FakeAuthAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.codec.multipart.FilePart;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.UUID;

@Slf4j
public class FakeAuthAdapter implements AuthPort {
    
    @Override
    public Mono<AuthResponse> login(String email, String password) {
        log.info("üõ† MODE FAKE AUTH : Login pour {}", email);
        return Mono.just(new AuthResponse(
                UUID.randomUUID(),
                "fake.jwt.token",
                "fake.refresh.token",
                email,
                List.of("RIDE_AND_GO_DRIVER"),
                List.of("*")));
    }

    @Override
    public Mono<AuthResponse> register(String username, String email, String password, String phone, String firstName,
            String lastName, List<RoleType> roles, FilePart photo) {
        
        log.info("üõ† MODE FAKE AUTH : Register pour {} (Photo re√ßue: {})", username, (photo != null));

        List<String> rolesStr = roles.stream().map(Enum::name).toList();

        return Mono.just(new AuthResponse(
                UUID.randomUUID(),
                "fake.jwt.token",
                "fake.refresh.token",
                username,
                rolesStr,
                List.of("*")));
    }

    @Override
    public Mono<AuthResponse> refreshToken(String refreshToken) {
        return Mono.just(new AuthResponse(
                UUID.randomUUID(),
                "new.fake.jwt.token",
                "new.fake.refresh.token",
                "RefreshUser",
                List.of("RIDE_AND_GO_DRIVER"),
                List.of("*")));
    }

    @Override
    public Mono<Void> forgotPassword(String email) {
        return Mono.empty();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/FakeFareAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

@Slf4j
public class FakeFareAdapter implements FareClientPort {

    @Override
    public Mono<FareResponse> caclculateFare(FareRequest request) {
        log.info("üõ† MODE FAKE FARE : Calcul pour {} -> {}", request.depart(), request.arrivee());
        
        double randomPrice = ThreadLocalRandom.current().nextDouble(1500.0, 5000.0);
        double roundedPrice = Math.round(randomPrice / 100.0) * 100.0; // Arrondi √† 100

        // Construction des sous-objets Fake
        FareResponse.FeaturesUtilisees features = new FareResponse.FeaturesUtilisees(
            5500.0, 900.0, 5.0, 1.2, 12, "matin", 1, 2
        );
        
        FareResponse.EstimationsSupplementaires estimations = new FareResponse.EstimationsSupplementaires(
            roundedPrice, features
        );

        return Mono.just(new FareResponse(
                "exact",
                roundedPrice,       // prix_moyen
                roundedPrice - 200, // prix_min
                roundedPrice + 200, // prix_max
                5.5,                // distance
                15.0,               // duree
                estimations,        // estimations_supplementaires
                Map.of("Heure de pointe", "+500F"), // ajustements_appliques
                1,                  // fiabilite
                "Estimation Fake r√©ussie",
                Map.of("type_route", "bitume"),     // details_trajet
                List.of("Eviter le centre ville")   // suggestions
        ));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/FakeUserAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.ports.out.ExternalUserPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@RequiredArgsConstructor
public class FakeUserAdapter implements ExternalUserPort {

    private final UserRepositoryPort userRepository;

    @Override
    public Flux<User> fetchAllRemoteUsers() {
        return userRepository.findAll();
    }

    @Override
    public Flux<User> fetchAllRemoteUsersByService(String serviceName) {
        // En mode fake, on ignore le filtre service, on renvoie tout le local
        return userRepository.findAll();
    }

    @Override
    public Mono<User> fetchRemoteUserById(UUID id) {
        return userRepository.findUserById(id);
    }

    // --- WRITE OPERATIONS (Fake Implementation) ---

    @Override
    public Mono<Void> addRole(UUID userId, String roleName) {
        log.info("üõ† FAKE ADAPTER: Pretending to add role {} to user {}", roleName, userId);
        return Mono.empty();
    }

    @Override
    public Mono<Void> removeRole(UUID userId, String roleName) {
        log.info("üõ† FAKE ADAPTER: Pretending to remove role {} from user {}", roleName, userId);
        return Mono.empty();
    }

    @Override
    public Mono<User> updateProfile(UUID userId, String firstName, String lastName, String phone) {
        log.info("üõ† FAKE ADAPTER: Pretending to update profile for user {}", userId);
        // On retourne l'utilisateur local tel quel
        return userRepository.findUserById(userId);
    }

    @Override
    public Mono<Void> changePassword(UUID userId, String currentPassword, String newPassword) {
        log.info("üõ† FAKE ADAPTER: Pretending to change password for user {}", userId);
        return Mono.empty();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/PaymentAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.exception.WalletNotFoundException;
import com.yowyob.rideandgo.domain.model.Wallet;
import com.yowyob.rideandgo.domain.ports.out.PaymentPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.PaymentApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class PaymentAdapter implements PaymentPort {
    private final PaymentApiClient client;

    @Override
    public Mono<Wallet> createWallet(UUID ownerId, String ownerName) {
        log.info("üí≥ Creating wallet for driver {} ({})", ownerName, ownerId);
        return client.createWallet(new PaymentApiClient.CreateWalletRequest(ownerId.toString(), ownerName))
                .map(this::mapToDomain);
    }

    @Override
    public Mono<Wallet> getWalletByOwnerId(UUID ownerId) {
        return client.getWalletByOwnerId(ownerId.toString())
                .map(this::mapToDomain)
                .onErrorResume(WebClientResponseException.class, e -> {
                    log.error("‚ùå Failed to fetch wallet for owner {}: {} - {}", ownerId, e.getStatusCode(),
                            e.getResponseBodyAsString());
                            
                    // On consid√®re que 404 ou 500 sur cette route signifie "Pas de Wallet"
                    return Mono.error(new WalletNotFoundException(
                            "Votre portefeuille de paiement n'a pas √©t√© trouv√©. Veuillez contacter le support."));
                });
    }

    @Override
    public Mono<Void> processPayment(UUID walletId, double offerPrice) {
        log.info("üí∏ Creating Payment Transaction for offer price: {} on wallet {}", offerPrice, walletId);
        return client.createPaymentTransaction(new PaymentApiClient.PaymentTransactionRequest(
                walletId.toString(), offerPrice, "PAYMENT"))
                .onErrorResume(WebClientResponseException.class, e -> {
                    log.error("‚ùå Payment transaction failed for wallet {}: {}", walletId, e.getResponseBodyAsString());
                    return Mono.error(new RuntimeException("√âchec de la transaction de paiement."));
                });
    }

    private Wallet mapToDomain(PaymentApiClient.WalletResponse res) {
        return Wallet.builder()
                .id(UUID.fromString(res.id()))
                .ownerId(UUID.fromString(res.ownerId()))
                .ownerName(res.ownerName())
                .balance(res.balance())
                .build();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/RemoteAuthAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.exception.AuthenticationFailedException;
import com.yowyob.rideandgo.domain.exception.UserAlreadyExistsException;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import com.yowyob.rideandgo.domain.ports.out.CacheInvalidationPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.client.MultipartBodyBuilder;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@RequiredArgsConstructor
public class RemoteAuthAdapter implements AuthPort {

    private final AuthApiClient client;
    private final UserRepositoryPort userRepositoryPort;
    private final CacheInvalidationPort cacheInvalidationPort;

    private static final String SERVICE_NAME = "RIDE_AND_GO";

    @Override
    public Mono<AuthResponse> login(String identifier, String password) {
        log.info("üåê REMOTE AUTH : Login pour {}", identifier);
        return client.login(new AuthApiClient.LoginRequest(identifier, password))
                .doOnSuccess(response -> {
                    if (response != null && response.user() != null && response.user().id() != null) {
                        UUID userId = UUID.fromString(response.user().id());
                        cacheInvalidationPort.invalidateUserCache(userId).subscribe();
                    }
                })
                .map(this::mapToDomain)
                .onErrorResume(WebClientResponseException.class, ex -> {
                    if (ex.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                        return Mono.error(new AuthenticationFailedException("Identifiant ou mot de passe incorrect."));
                    }
                    return Mono.error(new RuntimeException("Erreur d'authentification distante"));
                });
    }

    @Override
    public Mono<AuthResponse> register(String username, String email, String password, String phone,
            String firstName, String lastName, List<RoleType> roles, FilePart photo) {

        log.info("üåê REMOTE AUTH : Register Multipart avec photo pour {}", username);

        List<String> rolesToSend = roles.stream().map(Enum::name).toList();

        AuthApiClient.RegisterRequest registerDto = new AuthApiClient.RegisterRequest(
                username, password, email, phone, firstName, lastName, SERVICE_NAME, rolesToSend);

        // Construction du corps Multipart
        MultipartBodyBuilder builder = new MultipartBodyBuilder();
        builder.part("data", registerDto, MediaType.APPLICATION_JSON);

        if (photo != null) {
            builder.part("file", photo);
        }

        return client.register(builder.build())
                .flatMap(response -> {
                    // Mapping vers l'utilisateur local incluant la photoUri re√ßue
                    User localUser = User.builder()
                            .id(UUID.fromString(response.user().id()))
                            .name(response.user().username())
                            .firstName(response.user().firstName()) // ‚úÖ Ajout√©
                            .lastName(response.user().lastName()) // ‚úÖ Ajout√©
                            .email(response.user().email())
                            .telephone(response.user().phone())
                            .photoUri(response.user().photoUri())
                            .roles(Collections.emptySet())
                            .directPermissions(Collections.emptySet())
                            .build();

                    return userRepositoryPort.save(localUser)
                            .doOnSuccess(u -> log.info("‚úÖ User synced locally with photo: {}", u.photoUri()))
                            .thenReturn(mapToDomain(response));
                })
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("‚ùå Register Failed (Remote): {}", ex.getStatusCode());
                    if (ex.getStatusCode() == HttpStatus.CONFLICT) {
                        return Mono.error(new UserAlreadyExistsException("L'utilisateur existe d√©j√†."));
                    }
                    return Mono.error(new RuntimeException("Erreur inscription : " + ex.getResponseBodyAsString()));
                });
    }

    @Override
    public Mono<AuthResponse> refreshToken(String refreshToken) {
        return client.refresh(new AuthApiClient.RefreshTokenRequest(refreshToken))
                .doOnSuccess(response -> {
                    if (response != null && response.user() != null && response.user().id() != null) {
                        cacheInvalidationPort.invalidateUserCache(UUID.fromString(response.user().id())).subscribe();
                    }
                })
                .map(this::mapToDomain);
    }

    @Override
    public Mono<Void> forgotPassword(String email) {
        return Mono.empty();
    }

    private AuthResponse mapToDomain(AuthApiClient.TraMaSysResponse res) {
        List<String> filteredRoles = res.user().roles().stream()
                .filter(roleStr -> {
                    try {
                        RoleType.valueOf(roleStr);
                        return true;
                    } catch (Exception e) {
                        return false;
                    }
                }).collect(Collectors.toList());

        return new AuthResponse(
                UUID.fromString(res.user().id()),
                res.accessToken(), res.refreshToken(),
                res.user().username(), filteredRoles, res.user().permissions());
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/RemoteFareAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.FareCalculatorClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreaker;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreakerFactory;
import reactor.core.publisher.Mono;

@Slf4j
@RequiredArgsConstructor
public class RemoteFareAdapter implements FareClientPort {
    private final FareCalculatorClient client;
    private final ReactiveCircuitBreakerFactory<?, ?> cbFactory;
    private final FareClientPort fallbackAdapter;

    @Override
    public Mono<FareResponse> caclculateFare(FareRequest request) {
        log.info("üåê MODE REMOTE FARE : Calling external API for {} to {}", request.depart(), request.arrivee());
        ReactiveCircuitBreaker rcb = cbFactory.create("fare-calculator-service");

        return rcb.run(
                client.calculateFare(request),
                throwable -> {
                    log.warn("üö® External Fare Service failed, using fallback: {}", throwable.getMessage());
                    return fallbackAdapter.caclculateFare(request);
                }
        );
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/RemoteUserAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.exception.AuthenticationFailedException;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.ports.out.ExternalUserPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.Collections;
import java.util.UUID;
import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import java.util.stream.Collectors;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class RemoteUserAdapter implements ExternalUserPort {
    private final AuthApiClient client;
    private static final String SERVICE_NAME = "RIDE_AND_GO";

    // --- READ ---

    @Override
    public Flux<User> fetchAllRemoteUsers() {
        return getUsersByService(SERVICE_NAME);
    }

    @Override
    public Flux<User> fetchAllRemoteUsersByService(String serviceName) {
        return getUsersByService(serviceName);
    }

    private Flux<User> getUsersByService(String service) {
        return client.getUsersByService(service)
                .map(this::mapToDomain)
                .onErrorResume(e -> {
                    log.error("Failed to fetch remote users for service {}: {}", service, e.getMessage());
                    return Flux.empty();
                });
    }

    @Override
    public Mono<User> fetchRemoteUserById(UUID id) {
        return client.getUserById(id.toString())
                .map(this::mapToDomain)
                .onErrorResume(e -> {
                    log.warn("User {} not found via direct ID call, trying list filter...", id);
                    return fetchAllRemoteUsers()
                            .filter(u -> u.id().equals(id))
                            .next();
                });
    }

    // --- WRITE (Propagation) ---

    @Override
    public Mono<Void> addRole(UUID userId, String roleName) {
        log.info("üåç Propagating ADD ROLE {} for user {} to Auth Service", roleName, userId);
        return client.addRole(userId.toString(), roleName)
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("Failed to add role {} to user {}: {}", roleName, userId, ex.getStatusCode());
                    return Mono.error(new RuntimeException("Impossible de modifier les r√¥les √† distance."));
                });
    }

    @Override
    public Mono<Void> removeRole(UUID userId, String roleName) {
        log.info("üåç Propagating REMOVE ROLE {} for user {} to Auth Service", roleName, userId);
        return client.removeRole(userId.toString(), roleName)
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("Failed to remove role {} from user {}: {}", roleName, userId, ex.getStatusCode());
                    return Mono.error(new RuntimeException("Impossible de modifier les r√¥les √† distance."));
                });
    }

    @Override
    public Mono<User> updateProfile(UUID userId, String firstName, String lastName, String phone) {
        log.info("üåç Propagating UPDATE PROFILE for user {} to Auth Service", userId);
        return client.updateProfile(userId.toString(), new AuthApiClient.UpdateProfileDto(firstName, lastName, phone))
                .map(this::mapToDomain)
                .onErrorResume(WebClientResponseException.class, ex -> {
                    if (ex.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                        return Mono.error(new AuthenticationFailedException("Session expir√©e ou non autoris√©e."));
                    }
                    return Mono.error(new RuntimeException("Erreur lors de la mise √† jour du profil distant."));
                });
    }

    @Override
    public Mono<Void> changePassword(UUID userId, String currentPassword, String newPassword) {
        log.info("üåç Propagating PASSWORD CHANGE for user {} to Auth Service", userId);
        return client.changePassword(userId.toString(),
                new AuthApiClient.ChangePasswordDto(currentPassword, newPassword))
                .onErrorResume(WebClientResponseException.class, ex -> {
                    // C'est ici qu'on attrape ton erreur 401
                    if (ex.getStatusCode() == HttpStatus.UNAUTHORIZED) {
                        log.warn("‚ùå Password change failed: Current password incorrect for user {}", userId);
                        return Mono.error(new AuthenticationFailedException("Le mot de passe actuel est incorrect."));
                    }
                    log.error("‚ùå Password change error: Status {}", ex.getStatusCode());
                    return Mono.error(new RuntimeException("Erreur lors du changement de mot de passe √† distance."));
                });
    }

    // --- MAPPER ---

    private User mapToDomain(AuthApiClient.UserDetail dto) {
        Set<Role> roles = dto.roles() != null ? dto.roles().stream()
                .filter(roleStr -> {
                    try {
                        RoleType.valueOf(roleStr);
                        return true;
                    } catch (IllegalArgumentException e) {
                        return false;
                    }
                })
                .map(roleStr -> Role.builder().type(RoleType.valueOf(roleStr)).build())
                .collect(Collectors.toSet()) : Collections.emptySet();

        return User.builder()
                .id(UUID.fromString(dto.id()))
                .name(dto.username())
                .firstName(dto.firstName()) // ‚úÖ Ajout√©
                .lastName(dto.lastName()) // ‚úÖ Ajout√©
                .email(dto.email())
                .telephone(dto.phone())
                .photoUri(dto.photoUri())
                .roles(roles)
                .directPermissions(Collections.emptySet())
                .build();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/SyndicateAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.ports.out.SyndicatePort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.SyndicateApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class SyndicateAdapter implements SyndicatePort {
    private final SyndicateApiClient client;

    @Override
    public Mono<Boolean> checkIsSyndicated(UUID userId) {
        log.info("üîç Checking Syndicate status for user {} at UGate", userId);
        return client.getDriverComplianceDetails(userId.toString())
                .map(SyndicateApiClient.SyndicateDetailsResponse::isVerified)
                .onErrorResume(e -> {
                    log.error("‚ùå Failed to contact Syndicate service: {}", e.getMessage());
                    return Mono.just(false);
                });
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/VehicleAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.domain.ports.out.VehicleRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.VehicleApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.client.MultipartBodyBuilder;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Component;
import org.springframework.util.MultiValueMap;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.Collections;
import java.util.List;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class VehicleAdapter implements VehicleRepositoryPort {
        private final VehicleApiClient client;

        @Override
        public Mono<Vehicle> createVehicle(Vehicle domain) {
                log.info("üöó [API Direct] Creating vehicle for: {}", domain.registrationNumber());

                var request = new VehicleApiClient.SimplifiedVehicleRequest(
                                domain.vehicleMakeId(),
                                domain.vehicleModelId(),
                                domain.transmissionTypeId(),
                                domain.manufacturerId(),
                                domain.vehicleSizeId(),
                                domain.vehicleTypeId(),
                                domain.fuelTypeId(),
                                domain.vehicleSerialNumber(),
                                domain.vehicleSerialPhoto(),
                                domain.registrationNumber(),
                                domain.registrationPhoto(),
                                null,
                                domain.tankCapacity(),
                                domain.luggageMaxCapacity(),
                                domain.totalSeatNumber(),
                                domain.averageFuelConsumptionPerKm(),
                                domain.mileageAtStart(),
                                (double) domain.mileageSinceCommissioning(),
                                (double) domain.vehicleAgeAtStart(),
                                domain.brand());

                return client.createVehicleSimplified(request)
                                .map(res -> this.mapResponseToDomain(res, Collections.emptyList()))
                                .doOnSuccess(v -> log.info("‚úÖ Vehicle created with ID: {}", v.id()));
        }

        @Override
        public Mono<Vehicle> getVehicleById(UUID vehicleId) {
                // ‚úÖ AJOUT DE LA GARDE
                if (vehicleId == null) {
                        log.warn("‚ö†Ô∏è Attempted to fetch vehicle with NULL ID");
                        return Mono.empty();
                }

                log.debug("üåê [API Direct] Fetching vehicle {}", vehicleId);

                return Mono.zip(
                                client.getVehicleById(vehicleId.toString()),
                                this.getVehicleImages(vehicleId).collectList().defaultIfEmpty(Collections.emptyList()))
                                .map(tuple -> mapResponseToDomain(tuple.getT1(), tuple.getT2()))
                                .doOnError(e -> log.error("‚ùå Failed to fetch vehicle {}: {}", vehicleId,
                                                e.getMessage()));
        }

        @Override
        public Mono<Vehicle> patchVehicle(UUID vehicleId, Vehicle partial) {
                log.info("üîß [API Direct] Patching vehicle {}", vehicleId);

                var request = new VehicleApiClient.UpdateVehicleRequest(
                                partial.vehicleMakeId(),
                                partial.vehicleModelId(),
                                partial.transmissionTypeId(),
                                partial.manufacturerId(),
                                partial.vehicleSizeId(),
                                partial.vehicleTypeId(),
                                partial.fuelTypeId(),
                                partial.vehicleSerialNumber(),
                                partial.vehicleSerialPhoto(),
                                partial.registrationNumber(),
                                partial.registrationPhoto(),
                                null,
                                partial.tankCapacity() > 0 ? partial.tankCapacity() : null,
                                partial.luggageMaxCapacity() > 0 ? partial.luggageMaxCapacity() : null,
                                partial.totalSeatNumber() > 0 ? partial.totalSeatNumber() : null,
                                partial.averageFuelConsumptionPerKm() > 0 ? partial.averageFuelConsumptionPerKm()
                                                : null,
                                partial.mileageAtStart() > 0 ? partial.mileageAtStart() : null,
                                partial.mileageSinceCommissioning() > 0 ? (double) partial.mileageSinceCommissioning()
                                                : null,
                                partial.vehicleAgeAtStart() > 0 ? (double) partial.vehicleAgeAtStart() : null,
                                partial.brand());

                return client.patchVehicle(vehicleId.toString(), request)
                                .flatMap(res -> this.getVehicleImages(vehicleId).collectList()
                                                .map(images -> mapResponseToDomain(res, images)));
        }

        @Override
        public Mono<Vehicle> uploadRegistrationDocument(UUID vehicleId, FilePart file) {
                return client.uploadRegistrationDocument(vehicleId.toString(), buildMultipart(file, "file"))
                                .flatMap(res -> this.getVehicleImages(vehicleId).collectList()
                                                .map(images -> mapResponseToDomain(res, images)));
        }

        @Override
        public Mono<Vehicle> uploadSerialDocument(UUID vehicleId, FilePart file) {
                return client.uploadSerialDocument(vehicleId.toString(), buildMultipart(file, "file"))
                                .flatMap(res -> this.getVehicleImages(vehicleId).collectList()
                                                .map(images -> mapResponseToDomain(res, images)));
        }

        @Override
        public Mono<String> uploadVehicleImage(UUID vehicleId, FilePart file) {
                return client.uploadVehicleImage(vehicleId.toString(), buildMultipart(file, "file"))
                                .map(VehicleApiClient.VehicleImageResponse::imagePath);
        }

        @Override
        public Flux<String> getVehicleImages(UUID vehicleId) {
                return client.getVehicleImages(vehicleId.toString())
                                .map(VehicleApiClient.VehicleImageResponse::imagePath)
                                .onErrorResume(e -> {
                                        log.warn("Could not fetch images for vehicle {}: {}", vehicleId,
                                                        e.getMessage());
                                        return Flux.empty();
                                });
        }

        // --- HELPERS ---

        @Override
        public Mono<Void> cacheVehicle(Vehicle vehicle) {
                // D√©sactiv√© comme demand√©
                return Mono.empty();
        }

        private Vehicle mapResponseToDomain(VehicleApiClient.VehicleResponse res, List<String> images) {
                return new Vehicle(
                                UUID.fromString(res.vehicleId()),
                                res.vehicleMakeId(),
                                res.vehicleModelId(),
                                res.transmissionTypeId(),
                                res.manufacturerId(),
                                res.vehicleSizeId(),
                                res.vehicleTypeId(),
                                res.fuelTypeId(),
                                res.vehicleSerialNumber(),
                                res.vehicleSerialPhoto(),
                                res.registrationNumber(),
                                res.registrationPhoto(),
                                res.tankCapacity(),
                                res.luggageMaxCapacity(),
                                res.totalSeatNumber(),
                                res.averageFuelConsumptionPerKm(),
                                res.mileageAtStart(),
                                (int) res.mileageSinceCommissioning(),
                                (int) res.vehicleAgeAtStart(),
                                res.brand(),
                                images);
        }

        private MultiValueMap<String, ?> buildMultipart(FilePart file, String keyName) {
                MultipartBodyBuilder builder = new MultipartBodyBuilder();
                builder.part(keyName, file);
                return builder.build();
        }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/AuthApiClient.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;

import org.springframework.http.MediaType;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.DeleteExchange;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PostExchange;
import org.springframework.web.service.annotation.PutExchange;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.UUID;

@HttpExchange("/api")
public interface AuthApiClient {

        // --- AUTH ---
        @PostExchange("/auth/login")
        Mono<TraMaSysResponse> login(@RequestBody LoginRequest request);

        @PostExchange(url = "/auth/register", contentType = MediaType.MULTIPART_FORM_DATA_VALUE)
        Mono<TraMaSysResponse> register(@RequestBody MultiValueMap<String, ?> parts);

        @PostExchange(url = "/auth/refresh", contentType = "application/json")
        Mono<TraMaSysResponse> refresh(@RequestBody RefreshTokenRequest request);

        // --- USERS READ ---
        @GetExchange("/users/service/{serviceName}")
        Flux<UserDetail> getUsersByService(@PathVariable String serviceName);

        @GetExchange("/users/{id}")
        Mono<UserDetail> getUserById(@PathVariable String id);

        // --- USERS WRITE (Propagation) ---

        // Ajout de r√¥le (POST /api/users/{id}/roles/{roleName})
        @PostExchange("/users/{id}/roles/{roleName}")
        Mono<Void> addRole(@PathVariable String id, @PathVariable String roleName);

        // Suppression de r√¥le (DELETE /api/users/{id}/roles/{roleName})
        @DeleteExchange("/users/{id}/roles/{roleName}")
        Mono<Void> removeRole(@PathVariable String id, @PathVariable String roleName);

        // Mise √† jour profil (PUT /api/users/{id})
        @PutExchange("/users/{id}")
        Mono<UserDetail> updateProfile(@PathVariable String id, @RequestBody UpdateProfileDto dto);

        // Changement mot de passe (PUT /api/users/{id}/password)
        @PutExchange("/users/{id}/password")
        Mono<Void> changePassword(@PathVariable String id, @RequestBody ChangePasswordDto dto);

        // --- DTOs Internes pour le Client ---

        record LoginRequest(String identifier, String password) {
        }

        record RegisterRequest(
                        String username, String password, String email, String phone,
                        String firstName, String lastName, String service, List<String> roles) {
        }

        record RefreshTokenRequest(String refreshToken) {}

        record TraMaSysResponse(String accessToken, String refreshToken, UserDetail user) {
        }

        record UserDetail(
                        String id,
                        String username,
                        String email,
                        String phone,
                        String firstName,
                        String lastName,
                        String service,
                        List<String> roles,
                        List<String> permissions,
                        UUID photoId,
                        String photoUri) {
        }

        record UpdateProfileDto(String firstName, String lastName, String phone) {
        }

        record ChangePasswordDto(String currentPassword, String newPassword) {
        }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/FareCalculatorClient.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;


import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PostExchange;
import reactor.core.publisher.Mono;

@HttpExchange("/api")
public interface FareCalculatorClient {
    @PostExchange("/estimate/")
    Mono<FareResponse> calculateFare(@RequestBody FareRequest request);
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/NotificationApiClient.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PostExchange;
import reactor.core.publisher.Mono;

@HttpExchange("/api/v1/notifications")
public interface NotificationApiClient {

    @PostExchange("/send")
    Mono<Void> sendNotification(@RequestBody SendNotificationRequest request);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/PaymentApiClient.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PostExchange;
import reactor.core.publisher.Mono;

@HttpExchange("/api/v1")
public interface PaymentApiClient {
    
    @PostExchange("/wallets")
    Mono<WalletResponse> createWallet(@RequestBody CreateWalletRequest request);

    @GetExchange("/wallets/owner/{id}")
    Mono<WalletResponse> getWalletByOwnerId(@PathVariable("id") String ownerId);

    @PostExchange("/transactions/payment")
    Mono<Void> createPaymentTransaction(@RequestBody PaymentTransactionRequest request);
    
    record CreateWalletRequest(String ownerId, String ownerName) {
    }

    record PaymentTransactionRequest(String walletId, double amount, String type) {
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    record WalletResponse(String id, String ownerId, String ownerName, double balance) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/SyndicateApiClient.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import reactor.core.publisher.Mono;

@HttpExchange("/compliance")
public interface SyndicateApiClient {
    @GetExchange("/details/{driverId}")
    Mono<SyndicateDetailsResponse> getDriverComplianceDetails(@PathVariable("driverId") String driverId);

    @JsonIgnoreProperties(ignoreUnknown = true)
    record SyndicateDetailsResponse(
            String id,
            String firstName,
            String lastName,
            String licenseNumber,
            boolean isVerified) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/VehicleApiClient.java ---
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;

import org.springframework.http.MediaType;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PatchExchange;
import org.springframework.web.service.annotation.PostExchange;
import org.springframework.web.service.annotation.PutExchange;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.time.LocalDateTime;

@HttpExchange("/vehicles")
public interface VehicleApiClient {
    // --- CORE VEHICLE (New Simplified Flow) ---

    @PostExchange("/simplified")
    Mono<VehicleResponse> createVehicleSimplified(@RequestBody SimplifiedVehicleRequest request);

    @GetExchange("/{id}")
    Mono<VehicleResponse> getVehicleById(@PathVariable String id);

    @PatchExchange("/{id}")
    Mono<VehicleResponse> patchVehicle(@PathVariable String id, @RequestBody UpdateVehicleRequest request);

    // --- MEDIA / DOCUMENTS MANAGEMENT ---

    @PostExchange(url = "/{id}/images", contentType = MediaType.MULTIPART_FORM_DATA_VALUE)
    Mono<VehicleImageResponse> uploadVehicleImage(@PathVariable String id, @RequestBody MultiValueMap<String, ?> parts);

    @GetExchange("/{id}/images")
    Flux<VehicleImageResponse> getVehicleImages(@PathVariable String id);

    @PutExchange(url = "/{id}/documents/registration", contentType = MediaType.MULTIPART_FORM_DATA_VALUE)
    Mono<VehicleResponse> uploadRegistrationDocument(@PathVariable String id,
            @RequestBody MultiValueMap<String, ?> parts);

    @PutExchange(url = "/{id}/documents/serial", contentType = MediaType.MULTIPART_FORM_DATA_VALUE)
    Mono<VehicleResponse> uploadSerialDocument(@PathVariable String id, @RequestBody MultiValueMap<String, ?> parts);

    // --- LOOKUPS (Legacy / Optional now) ---
    // On garde les GET au cas o√π on voudrait lister les marques dans l'UI
    @GetExchange("/lookup/vehicle-makes")
    Flux<MakeResponse> getAllMakes();

    @GetExchange("/lookup/vehicle-models")
    Flux<ModelResponse> getAllModels();

    @GetExchange("/lookup/vehicle-types")
    Flux<TypeResponse> getAllTypes();

    // --- DTOs ---

    // 1. Simplified Request (Noms au lieu d'IDs)
    record SimplifiedVehicleRequest(
            String makeName,
            String modelName,
            String transmissionType,
            String manufacturerName,
            String sizeName,
            String typeName,
            String fuelTypeName,
            String vehicleSerialNumber,
            String vehicleSerialPhoto,
            String registrationNumber,
            String registrationPhoto,
            LocalDateTime registrationExpiryDate, // Peut √™tre null
            int tankCapacity,
            int luggageMaxCapacity,
            int totalSeatNumber,
            double averageFuelConsumptionPerKm,
            int mileageAtStart,
            double mileageSinceCommissioning,
            double vehicleAgeAtStart,
            String brand) {
    }

    // 2. Patch Request (IDs partiels)
    record UpdateVehicleRequest(
            String vehicleMakeId,
            String vehicleModelId,
            String transmissionTypeId,
            String manufacturerId,
            String vehicleSizeId,
            String vehicleTypeId,
            String fuelTypeId,
            String vehicleSerialNumber,
            String vehicleSerialPhoto,
            String registrationNumber,
            String registrationPhoto,
            LocalDateTime registrationExpiryDate,
            Integer tankCapacity,
            Integer luggageMaxCapacity,
            Integer totalSeatNumber,
            Double averageFuelConsumptionPerKm,
            Integer mileageAtStart,
            Double mileageSinceCommissioning,
            Double vehicleAgeAtStart,
            String brand) {
    }

    // 3. Response Standard
    record VehicleResponse(
            String vehicleId,
            String vehicleMakeId,
            String vehicleModelId,
            String transmissionTypeId,
            String manufacturerId,
            String vehicleSizeId,
            String vehicleTypeId,
            String fuelTypeId,
            String vehicleSerialNumber,
            String vehicleSerialPhoto,
            String registrationNumber,
            String registrationPhoto,
            LocalDateTime registrationExpiryDate,
            int tankCapacity,
            int luggageMaxCapacity,
            int totalSeatNumber,
            double averageFuelConsumptionPerKm,
            int mileageAtStart,
            double mileageSinceCommissioning,
            double vehicleAgeAtStart,
            String brand,
            LocalDateTime createdAt,
            LocalDateTime updatedAt) {
    }

    // 4. Image Response
    record VehicleImageResponse(
            String vehicleIllustrationImageId,
            String vehicleId,
            String imagePath) {
    }

    // Lookups DTOs
    record MakeResponse(String vehicleMakeId, String makeName) {
    }

    record ModelResponse(String vehicleModelId, String vehicleMakeId, String modelName) {
    }

    record TypeResponse(String vehicleTypeId, String typeName) {
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/AdminController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.application.service.AdminService;
import com.yowyob.rideandgo.domain.model.Driver;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/admin")
@RequiredArgsConstructor
@Tag(name = "Admin-Backoffice", description = "Operations for platform administrators")
@PreAuthorize("hasAuthority('RIDE_AND_GO_ADMIN')") // Protection globale
public class AdminController {

    private final AdminService adminService;

    @GetMapping("/drivers/pending")
    @Operation(summary = "List pending drivers", description = "Get list of drivers waiting for validation")
    public Flux<Driver> getPendingDrivers() {
        return adminService.getPendingDrivers();
    }

    @PatchMapping("/drivers/{id}/validate")
    @Operation(summary = "Validate Driver", description = "Approve driver documents and enable access")
    public Mono<Driver> validateDriver(@PathVariable UUID id) {
        return adminService.validateDriver(id);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/AuthController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.AuthUseCase;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.List;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@Tag(name = "Authentication")
public class AuthController {

    private final AuthUseCase authUseCase;

    @PostMapping("/login")
    public Mono<AuthPort.AuthResponse> login(@RequestBody LoginRequest request) {
        return authUseCase.login(request.identifier(), request.password());
    }

    @PostMapping(value = "/register", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Inscription Multi-R√¥les avec Photo")
    public Mono<AuthPort.AuthResponse> register(
            @RequestPart("data") RegisterDto dto, // ‚úÖ Objet structur√©
            @RequestPart(value = "file", required = false) FilePart photo) {

        List<RoleType> rolesToAssign = (dto.roles() != null && !dto.roles().isEmpty())
                ? dto.roles()
                : List.of(RoleType.RIDE_AND_GO_PASSENGER);

        return authUseCase.register(
                dto.username(), dto.password(), dto.email(),
                dto.phone(), dto.firstName(), dto.lastName(),
                rolesToAssign, photo);
    }

    @PostMapping("/refresh")
    @Operation(summary = "Refresh Token")
    public Mono<AuthPort.AuthResponse> refresh(@RequestBody RefreshTokenDto request) {
        return authUseCase.refreshToken(request.refreshToken());
    }

    public record LoginRequest(String identifier, String password) {
    }

    public record RefreshTokenDto(String refreshToken) {
    }

    public record RegisterDto(
            String username,
            String password,
            String email,
            String phone,
            String firstName,
            String lastName,
            List<RoleType> roles) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/DeviceController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.in.RegisterDeviceTokenUseCase;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/devices")
@RequiredArgsConstructor
@Tag(name = "Device-Management", description = "Manage Push Notification Tokens")
public class DeviceController {

    private final RegisterDeviceTokenUseCase registerDeviceTokenUseCase;

    @PostMapping("/token")
    @Operation(summary = "Register FCM/APNS Token", description = "Link a device token to the current user for push notifications.")
    public Mono<Void> registerToken(@RequestBody TokenRequest request) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        UUID userId = UUID.fromString(auth.getName());
                        return registerDeviceTokenUseCase.registerToken(userId, request.token(), request.platform());
                    } catch (Exception e) {
                        return Mono.error(new IllegalStateException("Invalid User ID"));
                    }
                });
    }

    public record TokenRequest(String token, String platform) {}
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/DriverController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/drivers")
@RequiredArgsConstructor
@Tag(name = "Driver-Management", description = "Operations for drivers (status, etc.)")
public class DriverController {

    private final DriverRepositoryPort driverRepositoryPort;

    @PostMapping("/status/online")
    @Operation(summary = "Go Online/Offline", description = "Toggle availability for receiving offers.")
    public Mono<Boolean> setOnlineStatus(@RequestParam boolean isOnline) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        UUID driverId = UUID.fromString(auth.getName());
                        return driverRepositoryPort.setOnlineStatus(driverId, isOnline);
                    } catch (Exception e) {
                        return Mono.error(new IllegalStateException("Invalid Token or User ID"));
                    }
                });
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/FareController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/fares")
@Tag(name = "Fare-Calculator", description = "Trip price estimation (Stateless)")
public class FareController {

    private final FareClientPort fareClientPort;

    @PostMapping("/estimate")
    @Operation(summary = "Calculate fare estimation", description = "Returns suggested price. No data persistence.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Estimation successful", 
                        content = @Content(schema = @Schema(implementation = FareResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid request parameters")
    })
    public Mono<FareResponse> estimateFare(@RequestBody FareRequest request) {
        return fareClientPort.caclculateFare(request);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/GlobalExceptionHandler.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.exception.AuthenticationFailedException;
import com.yowyob.rideandgo.domain.exception.OfferNotFoundException;
import com.yowyob.rideandgo.domain.exception.UserAlreadyExistsException;
import com.yowyob.rideandgo.domain.exception.OfferStatutNotMatchException;

import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OfferNotFoundException.class)
    public ProblemDetail handleOfferNotFound(OfferNotFoundException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, e.getMessage());
    }

    @ExceptionHandler(AuthenticationFailedException.class)
    public ProblemDetail handleAuthenticationFailed(AuthenticationFailedException e) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.UNAUTHORIZED, e.getMessage());
        problemDetail.setTitle("√âchec d'authentification");
        return problemDetail;
    }

    @ExceptionHandler(IllegalStateException.class)
    public ProblemDetail handleIllegalState(IllegalStateException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, e.getMessage());
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ProblemDetail handleIllegalArgument(IllegalArgumentException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, e.getMessage());
    }

    @ExceptionHandler(OfferStatutNotMatchException.class)
    public ProblemDetail handleStatutMatch(OfferStatutNotMatchException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.CONFLICT, e.getMessage());
    }

    @ExceptionHandler(UserAlreadyExistsException.class)
    public ProblemDetail handleUserAlreadyExists(UserAlreadyExistsException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.CONFLICT, e.getMessage());
    }

    @ExceptionHandler(com.yowyob.rideandgo.domain.exception.WalletNotFoundException.class)
    public ProblemDetail handleWalletNotFound(com.yowyob.rideandgo.domain.exception.WalletNotFoundException e) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, e.getMessage());
        problemDetail.setTitle("Portefeuille introuvable");
        return problemDetail;
    }

    @ExceptionHandler(com.yowyob.rideandgo.domain.exception.DriverProfileNotValidatedException.class)
    public ProblemDetail handleDriverNotValidated(com.yowyob.rideandgo.domain.exception.DriverProfileNotValidatedException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.FORBIDDEN, e.getMessage());
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/HealthCheckController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/health")
@RequiredArgsConstructor
@Tag(name = "Health", description = "System diagnostic and connectivity checks")
public class HealthCheckController {

    private final DatabaseClient databaseClient;

    /**
     * Probes the database to ensure the R2DBC connection is active.
     */
    @GetMapping("/check-db")
    @Operation(summary = "Check database connectivity", description = "Executes a simple query to verify the DB link")
    public Mono<Map<String, Object>> checkDatabase() {
        return databaseClient.sql("SELECT 1")
                .map((row, metadata) -> row.get(0))
                .first()
                // Explicitly tell Java to treat this as a Map<String, Object>
                .map(res -> Map.<String, Object>of(
                        "status", "UP",
                        "database", "CONNECTED",
                        "message", "Database is responding correctly"
                ))
                .onErrorReturn(Map.of(
                        "status", "DOWN",
                        "database", "DISCONNECTED",
                        "message", "Could not connect to the database"
                ));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/LocationController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.in.UpdateLocationUseCase;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/v1/location")
@RequiredArgsConstructor
@Tag(name = "GPS-Tracking", description = "Real-time location updates")
public class LocationController {

    private final UpdateLocationUseCase updateLocationUseCase;

    @PostMapping
    @Operation(summary = "Update current location", description = "Updates the actor's coordinates in Redis. ID is extracted from JWT.")
    public Mono<Boolean> updateLocation(@RequestBody LocationRequest request) {
        return updateLocationUseCase.updateCurrentLocation(request.latitude(), request.longitude());
    }

    public record LocationRequest(Double latitude, Double longitude) {}
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/NotificationController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.model.Notification;
import com.yowyob.rideandgo.domain.ports.in.MarkNotificationAsReadUseCase;
import com.yowyob.rideandgo.domain.ports.out.NotificationHistoryRepositoryPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/notifications")
@RequiredArgsConstructor
@Tag(name = "Notification-History", description = "In-app notifications history")
public class NotificationController {
    private final NotificationHistoryRepositoryPort historyPort;
    private final MarkNotificationAsReadUseCase markAsReadUseCase;

    @GetMapping
    @Operation(summary = "Get my notifications", description = "Paginated list of notifications for the connected user.")
    public Mono<NotificationHistoryRepositoryPort.PagedResult<Notification>> getMyNotifications(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {

        return getCurrentUserId()
                .flatMap(userId -> historyPort.getUserNotifications(userId, page, size));
    }

    @PatchMapping("/{id}/read")
    @Operation(summary = "Mark a notification as read")
    public Mono<Void> markAsRead(@PathVariable UUID id) {
        return getCurrentUserId()
                .flatMap(userId -> markAsReadUseCase.markAsRead(id, userId));
    }

    @PatchMapping("/read-all")
    @Operation(summary = "Mark all my notifications as read")
    public Mono<Void> markAllAsRead() {
        return getCurrentUserId()
                .flatMap(markAsReadUseCase::markAllAsRead);
    }

    private Mono<UUID> getCurrentUserId() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        return Mono.just(UUID.fromString(auth.getName()));
                    } catch (Exception e) {
                        return Mono.error(new IllegalStateException("Invalid User Context"));
                    }
                });
    }
} 

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/OfferController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.in.*;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateOfferRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.LandingOfferResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.OfferResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideResponse;
import com.yowyob.rideandgo.infrastructure.mappers.OfferMapper;
import com.yowyob.rideandgo.infrastructure.mappers.RideMapper;
import com.yowyob.rideandgo.application.service.OfferService;
import com.yowyob.rideandgo.application.service.RideService; // Import ajout√©
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;

import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UpdateOfferRequest;

import java.util.UUID;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/offers")
@Tag(name = "Offer-Controller", description = "Matchmaking workflow")
public class OfferController {

    private final CreateOfferUseCase createOfferUseCase;
    private final GetAvailableOffersUseCase getAvailableOffersUseCase;
    private final ResponseToOfferUseCase responseToOfferUseCase;
    private final SelectDriverUseCase selectDriverUseCase;
    private final OfferService offerService;
    private final RideService rideService; // Injection ajout√©e
    private final OfferMapper mapper;
    private final RideMapper rideMapper;

    @GetMapping("/landing")
    @Operation(summary = "Get latest anonymized offers for landing page")
    public Flux<LandingOfferResponse> getPublicOffers(@RequestParam(defaultValue = "10") int limit) {
        return offerService.getLatestPublicOffers(limit);
    }

    @PostMapping
    @Operation(summary = "Publish an offer (Passenger)")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_PASSENGER')")
    public Mono<OfferResponse> createOffer(@RequestBody CreateOfferRequest request) {
        // Extraction s√©curis√©e de l'ID du passager depuis le token
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        System.err.println(auth.getName());
                        UUID passengerId = UUID.fromString(auth.getName());
                        return createOfferUseCase.createOffer(mapper.toDomain(request), passengerId);
                    } catch (Exception e) {
                        return Mono.error(new IllegalStateException("Invalid User ID in Token"));
                    }
                })
                .map(mapper::toResponse);
    }

    @GetMapping("/available")
    @Operation(summary = "List nearby or latest pending offers (Driver)")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Flux<OfferResponse> getAvailable() {
        return getAvailableOffersUseCase.getAvailableOffers().map(mapper::toResponse);
    }

    @PostMapping("/{id}/apply")
    @Operation(summary = "Apply to an offer (Driver)")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Mono<OfferResponse> apply(@PathVariable UUID id) {
        // On r√©cup√®re aussi le driverId depuis le token, plus besoin de param
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    UUID driverId = UUID.fromString(auth.getName());
                    return responseToOfferUseCase.responseToOffer(id, driverId);
                })
                .map(mapper::toResponse);
    }

    @GetMapping("/{id}/bids")
    @Operation(summary = "Review enriched bidders (Passenger)")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_PASSENGER')")
    public Mono<OfferResponse> getBids(@PathVariable UUID id) {
        return offerService.getOfferWithEnrichedBids(id).map(mapper::toResponse);
    }

    @PatchMapping("/{id}/select-driver")
    @Operation(summary = "1. Passenger selects driver", description = "Offer state -> DRIVER_SELECTED")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_PASSENGER')")
    public Mono<OfferResponse> select(@PathVariable UUID id, @RequestParam UUID driverId) {
        return selectDriverUseCase.selectDriver(id, driverId).map(mapper::toResponse);
    }

    @PostMapping("/{id}/accept")
    @Operation(summary = "2. Driver confirms pickup", description = "Offer state -> VALIDATED. Creates Ride.")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Mono<RideResponse> driverAccepts(@PathVariable UUID id, @RequestParam UUID driverId) {
        return offerService.driverAcceptsOffer(id, driverId).map(rideMapper::toResponse);
    }

    @PostMapping("/{id}/cancel")
    @Operation(summary = "Cancel offer (Passenger)")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_PASSENGER')")
    public Mono<OfferResponse> cancel(@PathVariable UUID id) {
        return offerService.cancelOffer(id).map(mapper::toResponse);
    }

    // --- NOUVEAU ENDPOINT : Transition Offre -> Course ---
    @GetMapping("/{id}/ride")
    @Operation(summary = "Get linked ride for an offer", description = "Returns the Ride object if the offer has been validated by a driver.")
    public Mono<RideResponse> getRideByOfferId(@PathVariable UUID id) {
        return rideService.getRideByOfferId(id)
                .map(rideMapper::toResponse);
    }

    // --- ENDPOINTS DE GESTION / DEBUG ---

    @GetMapping
    @Operation(summary = "Get all offers (Admin/Debug)", description = "Retrieves all offers regardless of status")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_ADMIN')")
    public Flux<OfferResponse> getAllOffers() {
        return offerService.getAllOffers().map(mapper::toResponse);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get offer by ID", description = "Get details of a specific offer")
    public Mono<OfferResponse> getOfferById(@PathVariable UUID id) {
        return offerService.getOfferById(id).map(mapper::toResponse);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update offer", description = "Modifies start/end points or price. Does not change state.")
    public Mono<OfferResponse> updateOffer(@PathVariable UUID id, @RequestBody UpdateOfferRequest request) {
        com.yowyob.rideandgo.domain.model.Offer domainUpdate = com.yowyob.rideandgo.domain.model.Offer.builder()
                .startPoint(request.startPoint())
                .endPoint(request.endPoint())
                .price(request.price() != null ? request.price() : 0.0)
                .build();

        return offerService.updateOffer(id, domainUpdate).map(mapper::toResponse);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete offer", description = "Permanently removes an offer")
    public Mono<Void> deleteOffer(@PathVariable UUID id) {
        return offerService.deleteOffer(id).then();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/ReviewController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.application.service.ReviewService;
import com.yowyob.rideandgo.domain.model.Review;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.ReviewResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/reviews")
@RequiredArgsConstructor
@Tag(name = "Review-Controller")
public class ReviewController {
    private final ReviewService reviewService;

    @PostMapping("/ride/{rideId}")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_PASSENGER')")
    public Mono<Review> postReview(@PathVariable UUID rideId, @RequestBody ReviewRequest request) {
        return ReactiveSecurityContextHolder.getContext()
                .map(ctx -> UUID.fromString(ctx.getAuthentication().getName()))
                .flatMap(passengerId -> reviewService.submitReview(rideId, passengerId, request.stars(),
                        request.comment()));
    }

    @GetMapping("/me")
    @Operation(summary = "Get my reviews (for drivers)")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Flux<ReviewResponse> getMyReviews() {
        return ReactiveSecurityContextHolder.getContext()
                .map(ctx -> UUID.fromString(ctx.getAuthentication().getName()))
                .flatMapMany(reviewService::getReviewsForDriver);
    }

    public record ReviewRequest(int stars, String comment) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/SettingsController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.model.NotificationSettings;
import com.yowyob.rideandgo.domain.ports.out.NotificationSettingsRepositoryPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RestController
@RequestMapping("/api/v1/settings")
@RequiredArgsConstructor
@Tag(name = "Settings", description = "User preferences configuration")
public class SettingsController {

    private final NotificationSettingsRepositoryPort settingsRepository;

    @GetMapping("/notifications")
    @Operation(summary = "Get notification preferences")
    public Mono<NotificationSettings> getSettings() {
        return getCurrentUserId().flatMap(settingsRepository::getSettings);
    }

    @PutMapping("/notifications")
    @Operation(summary = "Update notification preferences", description = "Enable/Disable specific channels (Email, Push, SMS...)")
    public Mono<Void> updateSettings(@RequestBody SettingsDto request) {
        return getCurrentUserId()
                .flatMap(userId -> settingsRepository.saveSettings(new NotificationSettings(
                        userId,
                        request.email(),
                        request.sms(),
                        request.push(),
                        request.whatsapp())));
    }

    private Mono<UUID> getCurrentUserId() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .map(auth -> UUID.fromString(auth.getName()));
    }

    public record SettingsDto(boolean email, boolean sms, boolean push, boolean whatsapp) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/TripController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.application.service.RideService;
import com.yowyob.rideandgo.domain.ports.in.GetRideLocationUseCase;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.EnrichedRideResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideTrackingResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UpdateStatusRequest;
import com.yowyob.rideandgo.infrastructure.mappers.RideMapper;
import com.yowyob.rideandgo.application.service.TrajectoryService;
import com.yowyob.rideandgo.domain.model.DriverTrajectory;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/trips")
@RequiredArgsConstructor
@Tag(name = "Trip-Controller")
public class TripController {
    private final RideService rideService;
    private final GetRideLocationUseCase getRideLocationUseCase;
    private final RideMapper rideMapper;
    private final TrajectoryService trajectoryService;

    @GetMapping("/history")
    @Operation(summary = "Get my ride history")
    public Flux<RideResponse> getMyHistory(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMapMany(auth -> {
                    UUID userId = UUID.fromString(auth.getName());
                    return rideService.getHistoryForUser(userId, page, size);
                })
                .map(rideMapper::toResponse);
    }

    @GetMapping("/driver/{driverId}/history")
    @Operation(summary = "Get driver specific history")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_ADMIN') or #driverId.toString() == authentication.name")
    public Flux<RideResponse> getDriverHistory(
            @PathVariable UUID driverId,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        return rideService.getHistoryForDriver(driverId, page, size)
                .map(rideMapper::toResponse);
    }

    @GetMapping("/enriched-history")
    @Operation(summary = "Get my ride history with full details", description = "Aggregates Ride, User and Vehicle info. Never fails with 500.")
    public Flux<EnrichedRideResponse> getMyEnrichedHistory(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMapMany(auth -> {
                    UUID userId = UUID.fromString(auth.getName());
                    return rideService.getEnrichedHistory(userId, page, size);
                });
    }

    @GetMapping("/{id}")
    public Mono<RideResponse> getRideById(@PathVariable UUID id) {
        return rideService.getRideById(id).map(rideMapper::toResponse);
    }

    @GetMapping("/driver/current")
    public Mono<RideResponse> getCurrentRide() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> rideService.getCurrentRideForDriver(UUID.fromString(auth.getName())))
                .map(rideMapper::toResponse);
    }

    @PatchMapping("/{id}/status")
    public Mono<RideResponse> updateStatus(@PathVariable UUID id, @RequestBody UpdateStatusRequest request) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> rideService.updateRideStatus(id, request.status(), UUID.fromString(auth.getName())))
                .map(rideMapper::toResponse);
    }

    @GetMapping("/{id}/location")
    public Mono<RideTrackingResponse> getTrackingInfo(@PathVariable UUID id) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> getRideLocationUseCase.getPartnerLocation(id, UUID.fromString(auth.getName())));
    }

    @GetMapping("/trajectories/me")
    @Operation(summary = "Get my movement history (Segments)", description = "Returns all 10-min trajectory segments for the connected driver.")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Flux<DriverTrajectory> getMyTrajectories() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMapMany(auth -> {
                    UUID driverId = UUID.fromString(auth.getName());
                    return trajectoryService.getMyTrajectories(driverId);
                });
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/UserController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.yowyob.rideandgo.application.service.UserService;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.domain.ports.in.UserUseCases;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.BecomeDriverRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.ChangePasswordRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.DriverProfileResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FullDriverProfileResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UpdateUserProfileRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UserResponse;
import com.yowyob.rideandgo.infrastructure.mappers.UserMapper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/users")
@Tag(name = "Users", description = "User management")
public class UserController {
    private final UserUseCases userUseCases;
    private final UserMapper userMapper;
    private final UserService userService;
    private final ObjectMapper objectMapper;

    // --- GESTION ADMIN ---

    @GetMapping("/service/{serviceName}")
    @Operation(summary = "List all users of a service (Admin)", description = "Fetches users from remote Auth Service.")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_ADMIN')")
    public Flux<UserResponse> getAllUsersByService(@PathVariable String serviceName) {
        return userUseCases.getAllRemoteUsersByService(serviceName)
                .map(this::mapToResponse);
    }

    // --- GESTION PROFIL (SELF) ---

    @GetMapping("/me")
    @Operation(summary = "Get my profile", description = "Retrieve the profile of the currently authenticated user based on JWT.")
    public Mono<UserResponse> getCurrentUser() {
        return getCurrentUserId()
                .flatMap(userUseCases::getUserById)
                .map(this::mapToResponse);
    }

    @PutMapping("/profile")
    @Operation(summary = "Update my profile")
    public Mono<UserResponse> updateProfile(@RequestBody UpdateUserProfileRequest request) {
        return getCurrentUserId()
                .flatMap(userId -> userUseCases.updateProfile(userId, request.firstName(), request.lastName(),
                        request.phone()))
                .map(this::mapToResponse);
    }

    @PutMapping("/password")
    @Operation(summary = "Change my password")
    public Mono<Void> changePassword(@RequestBody ChangePasswordRequest request) {
        return getCurrentUserId()
                .flatMap(userId -> userUseCases.changePassword(userId, request.currentPassword(),
                        request.newPassword()));
    }

    @PostMapping(value = "/driver", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Become Driver - Full Onboarding")
    public Mono<DriverProfileResponse> becomeDriver(
            @RequestPart("data") BecomeDriverRequest request, // ‚úÖ Objet structur√©
            @RequestPart(name = "registrationPhoto", required = false) FilePart registrationPhoto,
            @RequestPart(name = "serialPhoto", required = false) FilePart serialPhoto) {

        return getCurrentUserId()
                .flatMap(userId -> userService.upgradeToDriverComplete(
                        userId, request, registrationPhoto, serialPhoto));
    }

    /**
     * NOUVEAU : Route pour d√©clencher la v√©rification du statut Syndicat.
     */
    @PatchMapping("/verify-compliance")
    @Operation(summary = "Verify Syndicate Membership", description = "Checks with UGate if the driver is verified. If yes, completes the profile.")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Mono<DriverProfileResponse> verifyCompliance() {
        return getCurrentUserId()
                .flatMap(userUseCases::verifySyndicateStatus);
    }

    @GetMapping("/me/driver-profile")
    @Operation(summary = "Get Full Driver Profile", description = "Aggregates User, Driver, Wallet and Vehicle data.")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Mono<FullDriverProfileResponse> getFullDriverProfile() {
        return getCurrentUserId()
                .flatMap(userService::getFullDriverProfile);
    }

    // --- LECTURE STANDARD ---

    @GetMapping("/{userId}")
    public Mono<UserResponse> getUserById(@PathVariable UUID userId) {
        return userUseCases.getUserById(userId).map(this::mapToResponse);
    }

    @GetMapping("/drivers/{id}")
    @Operation(summary = "Get Driver Full Profile", description = "Aggregates User, Driver, Wallet and Vehicle data for a specific driver.")
    public Mono<FullDriverProfileResponse> getDriverById(@PathVariable UUID id) {
        return userService.getFullDriverProfile(id);
    }

    // --- HELPERS ---

    private Mono<UUID> getCurrentUserId() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .map(auth -> UUID.fromString(auth.getName()));
    }

    private UserResponse mapToResponse(User user) {
        UserResponse response = userMapper.toResponse(user);
        if (user.roles() != null) {
            response.setRoles(user.roles().stream()
                    .map(com.yowyob.rideandgo.domain.model.Role::type)
                    .collect(Collectors.toList()));
        }
        return response;
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/VehicleController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.application.service.VehicleService;
import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.BecomeDriverRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UpdateVehicleDto;
import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.MediaType;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/vehicles")
@RequiredArgsConstructor
@Tag(name = "Vehicle-Management", description = "Direct Vehicle Operations (External Service Proxy)")
@PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
public class VehicleController {
    private final VehicleService vehicleService;
    private final DriverRepositoryPort driverRepositoryPort;

    // --- FULL CREATION (JSON + FILES) ---

    @GetMapping("/me")
    @Operation(summary = "Get My Vehicle", description = "Retrieve the vehicle associated with the current driver.")
    public Mono<Vehicle> getMyVehicle() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .map(auth -> UUID.fromString(auth.getName()))
                .flatMap(driverId -> driverRepositoryPort.findById(driverId))
                .flatMap(driver -> {
                    if (driver.vehicleId() == null) {
                        return Mono.error(new IllegalStateException("No vehicle associated with this driver."));
                    }
                    return vehicleService.getVehicleById(driver.vehicleId());
                });
    }

    // --- STANDARD CRUD ---

    @GetMapping("/{id}")
    public Mono<Vehicle> getById(@PathVariable UUID id) {
        return vehicleService.getVehicleById(id);
    }

    @PatchMapping("/{id}")
    @Operation(summary = "Patch Vehicle", description = "Update specific fields of a vehicle.")
    public Mono<Vehicle> patchVehicle(@PathVariable UUID id,
            @org.springframework.web.bind.annotation.RequestBody UpdateVehicleDto dto) {
        // Mapping partiel : on ne mappe que ce qui est pr√©sent
        Vehicle partial = Vehicle.builder()
                .vehicleMakeId(dto.makeName())
                .vehicleModelId(dto.modelName())
                .transmissionTypeId(dto.transmissionType())
                .manufacturerId(dto.manufacturerName())
                .vehicleSizeId(dto.sizeName())
                .vehicleTypeId(dto.typeName())
                .fuelTypeId(dto.fuelTypeName())
                .vehicleSerialNumber(dto.vehicleSerialNumber())
                .registrationNumber(dto.registrationNumber())
                .tankCapacity(dto.tankCapacity() != null ? dto.tankCapacity() : 0)
                .luggageMaxCapacity(dto.luggageMaxCapacity() != null ? dto.luggageMaxCapacity() : 0)
                .totalSeatNumber(dto.totalSeatNumber() != null ? dto.totalSeatNumber() : 0)
                .averageFuelConsumptionPerKm(
                        dto.averageFuelConsumptionPerKm() != null ? dto.averageFuelConsumptionPerKm() : 0.0)
                .mileageAtStart(dto.mileageAtStart() != null ? dto.mileageAtStart() : 0)
                .mileageSinceCommissioning(
                        dto.mileageSinceCommissioning() != null ? dto.mileageSinceCommissioning() : 0)
                .vehicleAgeAtStart(dto.vehicleAgeAtStart() != null ? dto.vehicleAgeAtStart() : 0)
                .brand(dto.makeName()) // Fallback
                .build();

        return vehicleService.patchVehicle(id, partial);
    }

    // --- MEDIA MANAGEMENT ---

    @PostMapping(value = "/{id}/images", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Upload Gallery Image")
    public Mono<String> uploadImage(@PathVariable UUID id, @RequestPart("file") FilePart file) {
        return vehicleService.addImage(id, file);
    }

    @GetMapping("/{id}/images")
    @Operation(summary = "Get Gallery Images")
    public Flux<String> getImages(@PathVariable UUID id) {
        return vehicleService.getImages(id);
    }

    // --- DOCUMENT UPDATES ---

    @PutMapping(value = "/{id}/documents/registration", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Update Registration Photo")
    public Mono<Vehicle> updateRegistrationDoc(@PathVariable UUID id, @RequestPart("file") FilePart file) {
        return vehicleService.createVehicleWithDocuments(
                Vehicle.builder().id(id).build(), // Dummy vehicle just to carry ID if needed, or implement direct
                                                  // method in service
                file, null).flatMap(v -> vehicleService.getVehicleById(id)); // Reload fresh
    }

    @PutMapping(value = "/{id}/documents/serial", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Update Serial Number Photo")
    public Mono<Vehicle> updateSerialDoc(@PathVariable UUID id, @RequestPart("file") FilePart file) {
        return vehicleService.createVehicleWithDocuments(
                Vehicle.builder().id(id).build(),
                null, file).flatMap(v -> vehicleService.getVehicleById(id));
    }

    // --- HELPER MAPPER ---
    private Vehicle mapRequestToDomain(BecomeDriverRequest.VehicleInfo info) {
        return Vehicle.builder()
                .vehicleMakeId(info.makeName())
                .vehicleModelId(info.modelName())
                .transmissionTypeId(info.transmissionType())
                .manufacturerId(info.manufacturerName())
                .vehicleSizeId(info.sizeName())
                .vehicleTypeId(info.typeName())
                .fuelTypeId(info.fuelTypeName())
                .vehicleSerialNumber(info.vehicleSerialNumber())
                .registrationNumber(info.registrationNumber())
                .tankCapacity(info.tankCapacity())
                .luggageMaxCapacity(info.luggageMaxCapacity())
                .totalSeatNumber(info.totalSeatNumber())
                .averageFuelConsumptionPerKm(info.averageFuelConsumptionPerKm())
                .mileageAtStart(info.mileageAtStart())
                .mileageSinceCommissioning((int) info.mileageSinceCommissioning())
                .vehicleAgeAtStart((int) info.vehicleAgeAtStart())
                .brand(info.makeName())
                .build();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/WalletController.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.model.Wallet;
import com.yowyob.rideandgo.domain.ports.out.PaymentPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;
import java.util.UUID;

@RestController
@RequestMapping("/api/v1/wallets")
@RequiredArgsConstructor
@Tag(name = "Payment-Wallet", description = "Driver balance and transaction management")
public class WalletController {
    private final PaymentPort paymentPort;

    @GetMapping("/me")
    @Operation(summary = "Get My Wallet", description = "Retrieve balance for the current authenticated driver.")
    @PreAuthorize("hasAuthority('RIDE_AND_GO_DRIVER')")
    public Mono<Wallet> getMyWallet() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .map(auth -> UUID.fromString(auth.getName()))
                .flatMap(paymentPort::getWalletByOwnerId);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/BecomeDriverRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * DTO pour l'onboarding chauffeur.
 * Utilise les NOMS (ex: "Toyota") au lieu des IDs, conform√©ment √† l'API Vehicle
 * Simplified.
 * Les photos seront upload√©es dans une √©tape ult√©rieure via l'API Vehicle.
 */
public record BecomeDriverRequest(
        String licenseNumber,
        @JsonProperty("vehicle") VehicleInfo vehicle) {
    public record VehicleInfo(
            // Identifiants textuels (Noms)
            String makeName, // ex: "Toyota"
            String modelName, // ex: "Corolla Hybride"
            String transmissionType, // ex: "Automatique"
            String manufacturerName, // ex: "Toyota Factory"
            String sizeName, // ex: "Berline Compacte"
            String typeName, // ex: "Personnel"
            String fuelTypeName, // ex: "Hybride Essence"
            
            // Donn√©es physiques
            String vehicleSerialNumber, // VIN
            String registrationNumber, // Plaque

            // Caract√©ristiques techniques
            int tankCapacity,
            int luggageMaxCapacity,
            int totalSeatNumber,
            double averageFuelConsumptionPerKm,
            int mileageAtStart,
            double mileageSinceCommissioning,
            double vehicleAgeAtStart) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/ChangePasswordRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record ChangePasswordRequest(
    String currentPassword,
    String newPassword
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/CreateOfferRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.OfferState;

import java.util.UUID;

public record CreateOfferRequest(
        String startPoint,
        Double startLat,
        Double startLon,
        String endPoint,
        Double endLat, // ‚úÖ AJOUT√â
        Double endLon, // ‚úÖ AJOUT√â
        double price,
        String passengerPhone, 
        String departureTime 
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/CreateUserRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.Builder;
import lombok.Data;

@Data @Builder
public class CreateUserRequest {
    private String email;

    private String name;

    private String telephone;

    private String password;

    private RoleType type;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/DriverProfileResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.Vehicle;
import java.util.UUID;

/**
 * R√©ponse enrichie pour le profil public d'un chauffeur.
 */
public record DriverProfileResponse(
        UUID userId,
        String firstName,          // NOUVEAU
        String lastName,           // NOUVEAU
        String status,
        String licenseNumber,
        boolean isOnline,
        boolean isProfileValidated,
        boolean isSyndicated,
        boolean isProfileCompleted,
        Double rating,             // NOUVEAU
        Integer totalReviewsCount, // NOUVEAU
        Vehicle vehicle) {
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/EnrichedRideResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.model.Vehicle;
import lombok.Builder;
import lombok.Data;
import java.util.UUID;
import java.time.LocalDateTime;

@Data
@Builder
public class EnrichedRideResponse {
    private UUID rideId;
    private RideState state;
    private Double distance;
    private Double price;
    private String startPoint;
    private String endPoint;
    private LocalDateTime createdAt; // ‚úÖ S'assurer que ce champ est bien l√†

    // Infos sur le partenaire
    private String partnerName;
    private String partnerPhone;
    private String partnerPhoto;

    // Infos v√©hicule
    private Vehicle vehicle;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/FareRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

// Cette annotation retire les champs NULL du JSON envoy√©
@JsonInclude(JsonInclude.Include.NON_NULL) 
public record FareRequest(
    @JsonProperty("depart") String depart,
    @JsonProperty("arrivee") String arrivee,
    @JsonProperty("heure") String heure,
    @JsonProperty("meteo") Integer meteo,
    @JsonProperty("type_zone") Integer typeZone,
    @JsonProperty("congestion_user") Integer congestionUser
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/FareResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;
import java.util.Map;

/**
 * DTO complet align√© sur la r√©ponse de l'API FareCalculator (Yowyob/Pynfi).
 */
public record FareResponse(
    @JsonProperty("statut") String statut,
    @JsonProperty("prix_moyen") Double prixMoyen,
    @JsonProperty("prix_min") Double prixMin,
    @JsonProperty("prix_max") Double prixMax,
    @JsonProperty("distance") Double distance,
    @JsonProperty("duree") Double duree,
    
    // Objets imbriqu√©s complexes
    @JsonProperty("estimations_supplementaires") EstimationsSupplementaires estimationsSupplementaires,
    
    // Maps dynamiques pour les ajustements et d√©tails (cl√©/valeur)
    @JsonProperty("ajustements_appliques") Map<String, Object> ajustementsAppliques,
    
    @JsonProperty("fiabilite") Integer fiabilite,
    @JsonProperty("message") String message,
    
    @JsonProperty("details_trajet") Map<String, Object> detailsTrajet,
    
    @JsonProperty("suggestions") List<String> suggestions
) {
    
    // --- Records internes pour la structure imbriqu√©e ---

    public record EstimationsSupplementaires(
        @JsonProperty("ml_prediction") Double mlPrediction,
        @JsonProperty("features_utilisees") FeaturesUtilisees featuresUtilisees
    ) {}

    public record FeaturesUtilisees(
        @JsonProperty("distance_metres") Double distanceMetres,
        @JsonProperty("duree_secondes") Double dureeSecondes,
        @JsonProperty("congestion") Double congestion,
        @JsonProperty("sinuosite") Double sinuosite,
        @JsonProperty("nb_virages") Integer nbVirages,
        @JsonProperty("heure") String heure,
        @JsonProperty("meteo") Integer meteo,
        @JsonProperty("type_zone") Integer typeZone
    ) {}
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/FullDriverProfileResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.Driver;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.domain.model.Wallet;
import lombok.Builder;
import lombok.Data;

@Data
@Builder
public class FullDriverProfileResponse {
    private UserResponse user;
    private Driver driver;
    private Wallet wallet;
    private Vehicle vehicle;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/LandingOfferResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import java.time.LocalDateTime;

public record LandingOfferResponse(
    String startPoint,
    String endPoint,
    Double startLat,
    Double startLon,
    Double endLat, // ‚úÖ Pour dessiner la ligne d'arriv√©e sur la map
    Double endLon, // ‚úÖ
    double price,
    String departureTime,
    LocalDateTime createdAt
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/NotificationType.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public enum NotificationType {
    EMAIL, SMS, PUSH, WHATSAPP
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/OfferResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.Bid;
import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.model.Bid;

import java.util.List;
import java.util.UUID;

public record OfferResponse(
        UUID id,
        UUID passengerId,
        UUID selectedDriverId,
        String startPoint,
        Double startLat, // ‚úÖ AJOUT√â
        Double startLon, // ‚úÖ AJOUT√â
        String endPoint,
        Double endLat, // ‚úÖ Pour dessiner la ligne d'arriv√©e sur la map
        Double endLon, // ‚úÖ 
        double price,
        String passengerPhone,
        String departureTime,
        OfferState state,
        List<Bid> bids 
) {}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/ReviewResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import lombok.Builder;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.UUID;

@Data
@Builder
public class ReviewResponse {
    private UUID reviewId;
    private int rating;
    private String comment;
    private LocalDateTime createdAt;

    // Infos sur celui qui a laiss√© l'avis
    private String passengerName;
    private String passengerPhoto;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/RideResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import lombok.Data;

import java.util.UUID;

@Data
public class RideResponse {
    private UUID id;

    private UUID offerId;

    private UUID driverId;

    private UUID passengerId;

    double distance;

    int duration;

    RideState state;

    int timeReal;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/RideTrackingResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record RideTrackingResponse(
    Double latitude,       // La position de la cible
    Double longitude,
    Double distanceKm,     // Distance calcul√©e
    Integer etaMinutes,    // Temps estim√©
    String targetRole      // "DRIVER" ou "PASSENGER"
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/SendNotificationRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import lombok.Builder;

import java.util.List;
import java.util.Map;

@Builder
public record SendNotificationRequest(
        NotificationType notificationType,
        int templateId,
        List<String> to,
        Map<String, String> data
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UpdateOfferRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record UpdateOfferRequest(
    String startPoint,
    String endPoint,
    Double price
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UpdateStatusRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RideState;

public record UpdateStatusRequest(
    RideState status
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UpdateUserProfileRequest.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record UpdateUserProfileRequest(
    String firstName,
    String lastName,
    String phone
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UpdateVehicleDto.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record UpdateVehicleDto(
        String makeName,
        String modelName,
        String transmissionType,
        String manufacturerName,
        String sizeName,
        String typeName,
        String fuelTypeName,
        String vehicleSerialNumber,
        String registrationNumber,
        Integer tankCapacity,
        Integer luggageMaxCapacity,
        Integer totalSeatNumber,
        Double averageFuelConsumptionPerKm,
        Integer mileageAtStart,
        Integer mileageSinceCommissioning,
        Integer vehicleAgeAtStart) {
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UserResponse.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.Builder;
import lombok.Data;

import java.util.List;
import java.util.UUID;

@Data
@Builder
public class UserResponse {
    private UUID id;
    private String name; // Username
    private String firstName;
    private String lastName;
    private String email;
    private String telephone;
    private String photoUri;
    List<RoleType> roles;
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/kafka/kafkaAdapter.java ---
package com.yowyob.rideandgo.infrastructure.adapters.inbound.kafka;

public class kafkaAdapter {
    
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/mappers/FareMapper.java ---
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface FareMapper {

    /**
     * Mappe la r√©ponse de l'API (Pynfi/Yowyob) vers le Domaine.
     */
    @Mapping(target = "estimatedFare", source = "prixMoyen") // Mapping du prix
    @Mapping(target = "officialFare", source = "prixMoyen")
    // Les champs suivants ne sont pas dans la r√©ponse API racine, on les ignore ou on les laisse null
    @Mapping(target = "startPoint", ignore = true) 
    @Mapping(target = "endPoint", ignore = true)
    @Mapping(target = "userId", ignore = true)
    @Mapping(target = "id", ignore = true)
    Fare toDomain(FareResponse response);

    /**
     * Mappe la requ√™te entrante (DTO) vers le Domaine.
     */
    @Mapping(target = "startPoint", source = "depart") // Mapping fran√ßais -> anglais
    @Mapping(target = "endPoint", source = "arrivee")
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "userId", ignore = true)
    @Mapping(target = "estimatedFare", ignore = true)
    @Mapping(target = "officialFare", ignore = true)
    Fare toDomain(FareRequest request);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/mappers/OfferMapper.java ---
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateOfferRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.OfferResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface OfferMapper {

    @Mapping(target = "bids", ignore = true)
    @Mapping(target = "version", ignore = true)
    Offer toDomain(OfferEntity entity);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "bids", ignore = true)
    @Mapping(target = "version", ignore = true)
    @Mapping(target = "passengerId", ignore = true)
    @Mapping(target = "state", ignore = true)
    @Mapping(target = "selectedDriverId", ignore = true)
    Offer toDomain(CreateOfferRequest request);

    OfferResponse toResponse(Offer domain);

    @Mapping(target = "agreements", ignore = true)
    OfferEntity toEntity(Offer domain);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/mappers/RideMapper.java ---
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RideEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface RideMapper {
    
    @Mapping(target = "createdAt", source = "createdDate")
    Ride toDomain(RideEntity entity);

    @Mapping(target = "createdDate", source = "createdAt")
    RideEntity toEntity(Ride domain);

    RideResponse toResponse(Ride domain);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/mappers/RoleMapper.java ---
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface RoleMapper {

    @Mapping(target = "permissions", ignore = true)
    @Mapping(target = "type", source = "name") // IMPORTANT: Entity.name -> Domain.type
    Role toDomain(RoleEntity entity);

    @Mapping(target = "name", source = "type") // IMPORTANT: Domain.type -> Entity.name
    RoleEntity toEntity(Role domain);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/mappers/UserMapper.java ---
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateUserRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UserResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface UserMapper {

    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "directPermissions", ignore = true)
    User toDomain(UserEntity entity);

    UserEntity toEntity(User domain);

    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "directPermissions", ignore = true)
    User toDomain(CreateUserRequest request);

    @Mapping(target = "roles", ignore = true) 
    UserResponse toResponse(User domain);
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/AuthConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import com.yowyob.rideandgo.domain.ports.out.CacheInvalidationPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.FakeAuthAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.RemoteAuthAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AuthConfig {
    private final UserRepositoryPort userRepositoryPort;

    public AuthConfig(UserRepositoryPort userRepositoryPort) {
        this.userRepositoryPort = userRepositoryPort;
    }

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "fake")
    public AuthPort fakeAuthPort() {
        return new FakeAuthAdapter();
    }

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "remote", matchIfMissing = true)
    public AuthPort remoteAuthPort(AuthApiClient authApiClient,
            UserRepositoryPort userRepositoryPort,
            CacheInvalidationPort cacheInvalidationPort) { // Ajout du param√®tre
        return new RemoteAuthAdapter(authApiClient, userRepositoryPort, cacheInvalidationPort); // Injection
    }

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "fake")
    public com.yowyob.rideandgo.domain.ports.out.ExternalUserPort fakeUserPort() {
        return new com.yowyob.rideandgo.infrastructure.adapters.outbound.external.FakeUserAdapter(userRepositoryPort);
    }

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "remote", matchIfMissing = true)
    public com.yowyob.rideandgo.domain.ports.out.ExternalUserPort remoteUserPort(AuthApiClient authApiClient) {
        return new com.yowyob.rideandgo.infrastructure.adapters.outbound.external.RemoteUserAdapter(authApiClient);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/DatabaseInitConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.r2dbc.core.DatabaseClient;
import jakarta.annotation.PostConstruct;


@Configuration
@Profile("local") // Only active in local development
public class DatabaseInitConfig {

    private final DatabaseClient databaseClient;

    public DatabaseInitConfig(DatabaseClient databaseClient) {
        this.databaseClient = databaseClient;
    }

    @PostConstruct
    public void init() {

    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/FareConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.FakeFareAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.RemoteFareAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.FareCalculatorClient;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreakerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class FareConfig {

    /**
     * Always available as a candidate for fallback.
     */
    @Bean
    public FareClientPort fakeFareAdapter() {
        return new FakeFareAdapter();
    }

    /**
     * Active only when mode is 'remote'.
     */
    @Bean
    @Primary
    @ConditionalOnProperty(name = "application.fare.mode", havingValue = "remote")
    public FareClientPort remoteFareAdapter(FareCalculatorClient client, 
                                           ReactiveCircuitBreakerFactory<?, ?> cbFactory) {
        return new RemoteFareAdapter(client, cbFactory, fakeFareAdapter());
    }

    /**
     * Active only when mode is 'fake'.
     */
    @Bean
    @Primary
    @ConditionalOnProperty(name = "application.fare.mode", havingValue = "fake", matchIfMissing = true)
    public FareClientPort onlyFakeFareAdapter() {
        return fakeFareAdapter();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/KafkaConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.reactive.ReactiveKafkaProducerTemplate;
import reactor.kafka.sender.SenderOptions;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public ReactiveKafkaProducerTemplate<String, Object> reactiveKafkaProducerTemplate() {
        Map<String, Object> props = new HashMap<>();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, org.springframework.kafka.support.serializer.JsonSerializer.class);

        SenderOptions<String, Object> senderOptions = SenderOptions.create(props);

        return new ReactiveKafkaProducerTemplate<>(senderOptions);
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/OpenApiConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    /**
     * Configures OpenAPI (Swagger) with JWT security support.
     */
    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth";
        
        return new OpenAPI()
                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
                .components(new Components()
                        .addSecuritySchemes(securitySchemeName,
                                new SecurityScheme()
                                        .name(securitySchemeName)
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")))
                .info(new Info()
                        .title("Ride & Go API")
                        .version("1.0.0")
                        .description("Reactive API for Urban Transport Marketplace (Ride & Go project).")
                        .contact(new Contact()
                                .name("Gabriel")
                                .email("dev@yowyob.com"))
                        .license(new License()
                                .name("Apache 2.0")
                                .url("http://springdoc.org")));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/R2dbcConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import io.r2dbc.spi.ConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.convert.R2dbcCustomConversions;
import org.springframework.data.r2dbc.dialect.PostgresDialect;
import org.springframework.r2dbc.connection.R2dbcTransactionManager;
import org.springframework.transaction.ReactiveTransactionManager;

import java.util.Arrays;

/**
 * Configuration R2DBC avec gestion des ENUMs PostgreSQL via Converters Spring Data.
 * Cette approche est plus fiable que EnumCodec car elle utilise CAST SQL explicites.
 */
@Configuration
public class R2dbcConfig {

    /**
     * Enregistre les converters personnalis√©s pour les ENUMs PostgreSQL.
     */
    @Bean
    public R2dbcCustomConversions r2dbcCustomConversions() {
        return R2dbcCustomConversions.of(PostgresDialect.INSTANCE, Arrays.asList(
                // OfferState converters
                new OfferStateWritingConverter(),
                new OfferStateReadingConverter(),
                // RideState converters
                new RideStateWritingConverter(),
                new RideStateReadingConverter()
        ));
    }

    /**
     * Active la gestion transactionnelle r√©active
     */
    @Bean
    public ReactiveTransactionManager transactionManager(ConnectionFactory connectionFactory) {
        return new R2dbcTransactionManager(connectionFactory);
    }

    // ========== OFFER STATE CONVERTERS ==========

    /**
     * Convertit l'enum Java OfferState vers String pour PostgreSQL.
     * PostgreSQL cast automatiquement "STRING"::offer_state_enum
     */
    @WritingConverter
    static class OfferStateWritingConverter implements Converter<OfferState, String> {
        @Override
        public String convert(OfferState source) {
            return source.name();
        }
    }

    /**
     * Convertit la String PostgreSQL vers l'enum Java OfferState
     */
    @ReadingConverter
    static class OfferStateReadingConverter implements Converter<String, OfferState> {
        @Override
        public OfferState convert(String source) {
            return OfferState.valueOf(source);
        }
    }

    // ========== RIDE STATE CONVERTERS ==========

    @WritingConverter
    static class RideStateWritingConverter implements Converter<RideState, String> {
        @Override
        public String convert(RideState source) {
            return source.name();
        }
    }

    @ReadingConverter
    static class RideStateReadingConverter implements Converter<String, RideState> {
        @Override
        public RideState convert(String source) {
            return RideState.valueOf(source);
        }
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/RedisConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

@Configuration
public class RedisConfig {
        /**
         * ObjectMapper standard pour l'application (WebClient, Controllers, etc.).
         * N'active PAS le default typing. C'est le bean par d√©faut.
         */
        @Bean
        @Primary
        public ObjectMapper objectMapper() {
                JavaTimeModule javaTimeModule = new JavaTimeModule();

                return new ObjectMapper()
                                .registerModule(new ParameterNamesModule())
                                .registerModule(javaTimeModule)
                                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);
        }

        /**
         * ObjectMapper SP√âCIFIQUE et ISOL√â pour Redis.
         * Il est construit √† partir de z√©ro pour ne pas muter le bean primaire.
         * Il active le "default typing" pour la d√©s√©rialisation polymorphique.
         */
        @Bean
        @Qualifier("redisObjectMapper")
        public ObjectMapper redisObjectMapper() {
                JavaTimeModule javaTimeModule = new JavaTimeModule();

                ObjectMapper objectMapper = new ObjectMapper()
                                .registerModule(new ParameterNamesModule())
                                .registerModule(javaTimeModule)
                                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);

                // Activation du "Typing" uniquement pour cette instance d'ObjectMapper.
                objectMapper.activateDefaultTyping(
                                LaissezFaireSubTypeValidator.instance,
                                ObjectMapper.DefaultTyping.NON_FINAL);

                return objectMapper;
        }

        /**
         * Configure le template Redis pour utiliser l'ObjectMapper SP√âCIFIQUE √† Redis.
         */
        @Bean
        public ReactiveRedisTemplate<String, Object> reactiveRedisTemplate(
                        ReactiveRedisConnectionFactory factory,
                        @Qualifier("redisObjectMapper") ObjectMapper redisObjectMapper) { // Injection du bean qualifi√©

                Jackson2JsonRedisSerializer<Object> jsonSerializer = new Jackson2JsonRedisSerializer<>(
                                redisObjectMapper, Object.class);

                RedisSerializationContext<String, Object> context = RedisSerializationContext
                                .<String, Object>newSerializationContext(new StringRedisSerializer())
                                .value(jsonSerializer)
                                .hashValue(jsonSerializer)
                                .build();

                return new ReactiveRedisTemplate<>(factory, context);
        }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/SecurityConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.infrastructure.security.JwtAuthenticationManager;
import com.yowyob.rideandgo.infrastructure.security.SecurityContextRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.http.HttpStatus;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import reactor.core.publisher.Mono;
import java.util.List;

@Configuration
@EnableWebFluxSecurity
@RequiredArgsConstructor
public class SecurityConfig {
        private final JwtAuthenticationManager authenticationManager;
        private final SecurityContextRepository securityContextRepository;

        @Bean
        public PasswordEncoder passwordEncoder() {
                return new BCryptPasswordEncoder();
        }

        @Bean
        public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
                return http
                                .exceptionHandling(exceptionHandling -> exceptionHandling
                                                .authenticationEntryPoint((swe, e) -> Mono.fromRunnable(() -> swe
                                                                .getResponse().setStatusCode(HttpStatus.UNAUTHORIZED)))
                                                .accessDeniedHandler((swe,
                                                                e) -> Mono.fromRunnable(() -> swe.getResponse()
                                                                                .setStatusCode(HttpStatus.FORBIDDEN))))
                                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                                .formLogin(ServerHttpSecurity.FormLoginSpec::disable)
                                .httpBasic(ServerHttpSecurity.HttpBasicSpec::disable)

                                // --- CONFIGURATION CORS APPLIQU√âE ICI ---
                                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                                // -----------------------------

                                .authenticationManager(authenticationManager)
                                .securityContextRepository(securityContextRepository)
                                .authorizeExchange(exchanges -> exchanges
                                                .pathMatchers(
                                                                "/api/v1/auth/**",
                                                                "/api/v1/offers/landing",
                                                                "/v3/api-docs/**",
                                                                "/swagger-ui/**",
                                                                "/swagger-ui.html",
                                                                "/webjars/**",
                                                                "/api/v1/health/**")
                                                .permitAll()
                                                // Autoriser les requ√™tes OPTIONS (Pre-flight CORS)
                                                .pathMatchers(org.springframework.http.HttpMethod.OPTIONS).permitAll()
                                                .anyExchange().authenticated())
                                .build();
        }

        // --- BEAN CORS CORRIG√â POUR LA PROD ---
        @Bean
        CorsConfigurationSource corsConfigurationSource() {
                CorsConfiguration configuration = new CorsConfiguration();

                // CORRECTION CRITIQUE :
                // Utiliser allowedOriginPatterns("*") au lieu de allowedOrigins("*")
                // permet d'utiliser allowCredentials(true) sans violer la spec CORS.
                configuration.setAllowedOriginPatterns(List.of("*"));

                configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH", "HEAD"));
                configuration.setAllowedHeaders(List.of("*"));

                // Indispensable pour que le frontend puisse envoyer le token Authorization
                configuration.setAllowCredentials(true);

                // Exposer les headers si besoin (ex: pagination)
                configuration.setExposedHeaders(List.of("*"));

                UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
                source.registerCorsConfiguration("/**", configuration);
                return source;
        }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/config/WebClientConfig.java ---
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.FareCalculatorClient;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.NotificationApiClient;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.PaymentApiClient;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.SyndicateApiClient;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.VehicleApiClient;

import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;

import java.net.URI;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.support.WebClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.web.reactive.function.client.ClientRequest;
import org.springframework.web.reactive.function.client.ExchangeFilterFunction;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Configuration
public class WebClientConfig {

    private final HttpClient httpClient = HttpClient.create().wiretap(true);

    @Bean
    public PaymentApiClient paymentApiClient(WebClient.Builder builder,
            @Value("${application.payment.url}") String url) {
        WebClient webClient = builder.baseUrl(url).build();
        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        return HttpServiceProxyFactory.builderFor(adapter).build().createClient(PaymentApiClient.class);
    }

    @Bean
    public FareCalculatorClient fareCalculatorClient(WebClient.Builder builder,
            @Value("${application.fare.url}") String url,
            @Value("${application.fare.api-key}") String apiKey) {

        WebClient webClient = builder
                .baseUrl(url)
                .defaultHeader("Authorization", "ApiKey " + apiKey)
                .build();

        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        return HttpServiceProxyFactory.builderFor(adapter).build().createClient(FareCalculatorClient.class);
    }

    @Bean
    public AuthApiClient authApiClient(WebClient.Builder builder,
            @Value("${application.auth.url}") String url) {
        
        // On applique le connector Netty au builder
        WebClient webClient = builder
                .baseUrl(url)
                .clientConnector(new ReactorClientHttpConnector(httpClient)) // Injection Netty
                .filter(addBearerToken()) 
                .filter(logRequest()) 
                .build();

        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();
        return factory.createClient(AuthApiClient.class);
    }

    private ExchangeFilterFunction logRequest() {
        return (request, next) -> {
            // ‚úÖ LOG √âLARGI : On loggue tout ce qui va vers le service Auth pour debug
            log.info("üöÄ [WebClient Outbound] {} {}", request.method(), request.url());
            request.headers().forEach((name, values) -> 
                values.forEach(value -> {
                    String maskedValue = name.equalsIgnoreCase("Authorization") ? "Bearer ********" : value;
                    log.info("   üß© Header: {}={}", name, maskedValue);
                })
            );
            return next.exchange(request);
        };
    }

    @Bean
    public NotificationApiClient notificationApiClient(WebClient.Builder builder,
            @Value("${application.notification.url}") String url,
            @Value("${application.notification.service-token}") String serviceToken) {
        WebClient webClient = builder
                .baseUrl(url)
                .defaultHeader("X-Service-Token", serviceToken)
                .build();

        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        return HttpServiceProxyFactory.builderFor(adapter).build().createClient(NotificationApiClient.class);
    }

    @Bean
    public SyndicateApiClient syndicateApiClient(WebClient.Builder builder,
            @Value("${application.syndicate.url}") String url) {
        WebClient webClient = builder.baseUrl(url).filter(addBearerToken()).build(); 
        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        return HttpServiceProxyFactory.builderFor(adapter).build().createClient(SyndicateApiClient.class);
    }

    @Bean
    public VehicleApiClient vehicleApiClient(WebClient.Builder builder,
            @Value("${application.vehicle.url}") String url) {
        WebClient webClient = builder.baseUrl(url).filter(addBearerToken()).build();
        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        return HttpServiceProxyFactory.builderFor(adapter).build().createClient(VehicleApiClient.class);
    }

    private ExchangeFilterFunction addBearerToken() {
        return (request, next) -> {
            URI url = request.url();
            String path = url.getPath();

            // Ne pas ajouter de token pour les routes publiques d'auth
            if (path.contains("/auth/login") || path.contains("/auth/register") || path.contains("/auth/refresh")) {
                return next.exchange(request);
            }

            return ReactiveSecurityContextHolder.getContext()
                    .map(ctx -> ctx.getAuthentication())
                    .flatMap(auth -> {
                        Object credentials = auth.getCredentials();
                        if (credentials instanceof String token) {
                            ClientRequest newRequest = ClientRequest.from(request)
                                    .headers(headers -> headers.setBearerAuth(token))
                                    .build();
                            return next.exchange(newRequest);
                        }
                        return next.exchange(request);
                    })
                    // ‚úÖ CRITIQUE : Si le contexte est vide (ex: appel swagger sans login), on loggue l'absence de token
                    .switchIfEmpty(Mono.defer(() -> {
                        log.warn("‚ö†Ô∏è [WebClient] No Security Context found for path: {}. Sending without token.", path);
                        return next.exchange(request);
                    }));
        };
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/security/JwtAuthenticationManager.java ---
package com.yowyob.rideandgo.infrastructure.security;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.ReactiveAuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;
import java.util.Base64;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtAuthenticationManager implements ReactiveAuthenticationManager {
    // Utilisation d'une instance locale pour √©viter les conflits avec la
    // configuration globale
    private final ObjectMapper objectMapper = new ObjectMapper();

    // Simulation de tokens li√©s √† des UUIDs r√©els de ta base (Mode Test/Swagger)
    private static final Map<String, String> STATIC_TOKENS = Map.of(
            "client-token", "7f13909e-7170-4f91-872e-333333333333",
            "driver-1-token", "a1b2c3d4-e5f6-4a5b-8c9d-111111111111",
            "driver-2-token", "a1b2c3d4-e5f6-4a5b-8c9d-222222222222");

    @Override
    public Mono<Authentication> authenticate(Authentication authentication) {
        String authToken = authentication.getCredentials().toString();

        // 1. Cas des tokens de test statiques (Swagger / Dev Local)
        if (STATIC_TOKENS.containsKey(authToken)) {
            String userId = STATIC_TOKENS.get(authToken);
            RoleType role = authToken.contains("driver")
                    ? RoleType.RIDE_AND_GO_DRIVER
                    : RoleType.RIDE_AND_GO_PASSENGER;

            return Mono.just(new UsernamePasswordAuthenticationToken(
                    userId,
                    authToken,
                    List.of(new SimpleGrantedAuthority(role.name()))));
        }

        // 2. Cas des vrais JWT (Remote / Production)
        if (authToken != null && !authToken.isEmpty()) {
            try {
                // D√©codage basique du Payload (Partie 2 du JWT)
                String[] chunks = authToken.split("\\.");
                if (chunks.length < 2) {
                    return Mono.empty(); // Token malform√©
                }

                Base64.Decoder decoder = Base64.getUrlDecoder();
                String payload = new String(decoder.decode(chunks[1]));

                // Parsing JSON
                Map<String, Object> claims = objectMapper.readValue(payload, new TypeReference<Map<String, Object>>() {
                });

                // Extraction de l'ID (Subject)
                String userId = (String) claims.get("sub");

                // Extraction des R√¥les
                List<String> rolesClaim = (List<String>) claims.get("roles");
                List<SimpleGrantedAuthority> authorities;

                if (rolesClaim != null && !rolesClaim.isEmpty()) {
                    authorities = rolesClaim.stream()
                            .map(SimpleGrantedAuthority::new)
                            .collect(Collectors.toList());
                } else {
                    authorities = List.of(new SimpleGrantedAuthority(RoleType.RIDE_AND_GO_PASSENGER.name()));
                }

                return Mono.just(new UsernamePasswordAuthenticationToken(
                        userId,
                        authToken,
                        authorities));

            } catch (Exception e) {
                log.error("Failed to decode JWT: {}", e.getMessage());
                return Mono.empty();
            }
        }

        return Mono.empty();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/infrastructure/security/SecurityContextRepository.java ---
package com.yowyob.rideandgo.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication; 
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.security.web.server.context.ServerSecurityContextRepository;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Repository responsible for extracting the JWT token from the Authorization header
 * and initiating the authentication process.
 */
@Component
@RequiredArgsConstructor
public class SecurityContextRepository implements ServerSecurityContextRepository {

    private final JwtAuthenticationManager authenticationManager;

    @Override
    public Mono<Void> save(ServerWebExchange exchange, SecurityContext context) {
        return Mono.error(new UnsupportedOperationException("Stateless API: session saving is not supported."));
    }

    /**
     * Loads the security context by extracting the "Bearer" token from HTTP headers.
     */
    @Override
    public Mono<SecurityContext> load(ServerWebExchange exchange) {
        return Mono.justOrEmpty(exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION))
                .filter(authHeader -> authHeader.startsWith("Bearer "))
                .flatMap(authHeader -> {
                    String authToken = authHeader.substring(7);
                    // Create an unauthenticated token object
                    Authentication auth = new UsernamePasswordAuthenticationToken(authToken, authToken);
                    // Delegate validation to the AuthenticationManager
                    return this.authenticationManager.authenticate(auth)
                            .map(SecurityContextImpl::new);
                });
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/AuthenticationFailedException.java ---
package com.yowyob.rideandgo.domain.exception;

public class AuthenticationFailedException extends RuntimeException {
    public AuthenticationFailedException(String message) {
        super(message);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/DriverProfileNotValidatedException.java ---
package com.yowyob.rideandgo.domain.exception;

public class DriverProfileNotValidatedException extends RuntimeException {
    public DriverProfileNotValidatedException(String message) {
        super(message);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/OfferNotFoundException.java ---
package com.yowyob.rideandgo.domain.exception;

public class OfferNotFoundException extends RuntimeException {
    public OfferNotFoundException(String message) {
        super(message);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/OfferStatutNotMatchException.java ---
package com.yowyob.rideandgo.domain.exception;

public class OfferStatutNotMatchException extends RuntimeException{
    public OfferStatutNotMatchException(String message) {
        super(message);
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/TokenNotFoundException.java ---
package com.yowyob.rideandgo.domain.exception;

public class TokenNotFoundException extends RuntimeException{
    public TokenNotFoundException(String message) {
        super(message);
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/UserAlreadyExistsException.java ---
package com.yowyob.rideandgo.domain.exception;

public class UserAlreadyExistsException extends RuntimeException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/UserIsNotDriverException.java ---
package com.yowyob.rideandgo.domain.exception;

public class UserIsNotDriverException extends RuntimeException{
    public UserIsNotDriverException(String message) {
        super(message);
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/exception/WalletNotFoundException.java ---
package com.yowyob.rideandgo.domain.exception;

public class WalletNotFoundException extends RuntimeException {
    public WalletNotFoundException(String message) {
        super(message);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/AcceptedOfferUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Ride;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface AcceptedOfferUseCase {
    Mono<Ride> acceptedOffer(UUID offerId, UUID passengerId, UUID driverId);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/AuthUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import org.springframework.http.codec.multipart.FilePart; // Import requis
import reactor.core.publisher.Mono;
import java.util.List;

public interface AuthUseCase {
    Mono<AuthPort.AuthResponse> login(String identifier, String password);

    Mono<AuthPort.AuthResponse> refreshToken(String refreshToken);
    
    Mono<Void> resetPassword(String email);

    Mono<AuthPort.AuthResponse> register(
        String username, 
        String password, 
        String email, 
        String phone, 
        String firstName, 
        String lastName,
        List<RoleType> roles,
        FilePart photo // ‚úÖ Ajout ici
    );
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/CreateOfferUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface CreateOfferUseCase {
    Mono<Offer> createOffer(Offer offer, UUID passengerId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/GetAvailableOffersUseCase.java ---
// GetAvailableOffersUseCase.java
package com.yowyob.rideandgo.domain.ports.in;
import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Flux;

public interface GetAvailableOffersUseCase {
    Flux<Offer> getAvailableOffers(); // Offers in PENDING state
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/GetRideLocationUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideTrackingResponse;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface GetRideLocationUseCase {
    /**
     * R√©cup√®re la position, la distance et l'ETA du partenaire de course.
     */
    Mono<RideTrackingResponse> getPartnerLocation(UUID rideId, UUID requesterId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/MarkNotificationAsReadUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import reactor.core.publisher.Mono;
import java.util.UUID;

public interface MarkNotificationAsReadUseCase {
    /**
     * Marque une notification sp√©cifique comme lue.
     * 
     * @param notificationId ID de la notification
     * @param userId         ID de l'utilisateur (pour v√©rification de propri√©t√©)
     */
    Mono<Void> markAsRead(UUID notificationId, UUID userId);

    /**
     * Marque toutes les notifications d'un utilisateur comme lues.
     */
    Mono<Void> markAllAsRead(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/OfferManagementUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface OfferManagementUseCase {
    Flux<Offer> getAllOffers();
    Mono<Offer> getOfferById(UUID id);
    Mono<Offer> updateOffer(UUID id, Offer offerDetails);
    Mono<Boolean> deleteOffer(UUID id);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/PutFareInCacheUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Fare;
import reactor.core.publisher.Mono;

public interface PutFareInCacheUseCase {
    Mono<Boolean> putFareInCache(Fare fare);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/RegisterDeviceTokenUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import reactor.core.publisher.Mono;
import java.util.UUID;

public interface RegisterDeviceTokenUseCase {
    Mono<Void> registerToken(UUID userId, String token, String platform);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/ResponseToOfferUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface ResponseToOfferUseCase {
    Mono<Offer> responseToOffer(UUID offerId, UUID driverId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/SelectDriverUseCase.java ---

// SelectDriverUseCase.java
package com.yowyob.rideandgo.domain.ports.in;
import com.yowyob.rideandgo.domain.model.Offer;
import java.util.UUID;
import reactor.core.publisher.Mono;

public interface SelectDriverUseCase {
    Mono<Offer> selectDriver(UUID offerId, UUID driverId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/UpdateLocationUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import reactor.core.publisher.Mono;

/**
 * Input port for real-time location updates.
 */
public interface UpdateLocationUseCase {
    /**
     * Updates the GPS coordinates of the current authenticated actor.
     * @param latitude Double
     * @param longitude Double
     * @return Mono<Boolean> true if success
     */
    Mono<Boolean> updateCurrentLocation(Double latitude, Double longitude);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/UpdateRideStatusUseCase.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface UpdateRideStatusUseCase {
    /**
     * Updates the status of a ride obeying business rules.
     * @param rideId The ID of the ride
     * @param newStatus The target status (ONGOING, COMPLETED, CANCELLED)
     * @param actorId The ID of the user performing the action (Security)
     * @return The updated Ride
     */
    Mono<Ride> updateRideStatus(UUID rideId, RideState newStatus, UUID actorId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/in/UserUseCases.java ---
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Vehicle; // Import
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.BecomeDriverRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.DriverProfileResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FullDriverProfileResponse;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

import org.springframework.http.codec.multipart.FilePart;

public interface UserUseCases {
    Mono<User> saveUser(User user);

    Mono<User> getUserById(UUID userId);

    Mono<Boolean> deleteUserById(UUID userId);

    Flux<User> getAllUsers();

    Flux<User> getUsersByRole(RoleType role);

    Mono<Void> upgradeToDriver(UUID userId); // Legacy

    Mono<DriverProfileResponse> upgradeToDriverComplete(UUID userId, BecomeDriverRequest request, FilePart regPhoto,
            FilePart serialPhoto);

    Mono<User> updateProfile(UUID userId, String firstName, String lastName, String phone);

    Mono<Void> changePassword(UUID userId, String currentPassword, String newPassword);

    Flux<User> getAllRemoteUsersByService(String serviceName);

    Mono<DriverProfileResponse> verifySyndicateStatus(UUID userId);

    Mono<FullDriverProfileResponse> getFullDriverProfile(UUID userId);

    Mono<DriverProfileResponse> getDriverProfile(UUID driverId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/AuthPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.UUID;

public interface AuthPort {
    Mono<AuthResponse> login(String email, String password);

    Mono<Void> forgotPassword(String email);

    Mono<AuthResponse> refreshToken(String refreshToken);

    Mono<AuthResponse> register(
            String username, String password, String email, String phone,
            String firstName, String lastName, List<RoleType> roles,
            org.springframework.http.codec.multipart.FilePart photo // Ajout√©
    );

    record AuthResponse(
            UUID userId, // Ajout√© pour identifier l'utilisateur
            String accessToken,
            String refreshToken,
            String username,
            List<String> roles,
            List<String> permissions) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/CacheInvalidationPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Mono;
import java.util.UUID;

/**
 * Port for cache invalidation operations.
 */
public interface CacheInvalidationPort {
    /**
     * Invalidates all cache entries directly related to a user.
     * 
     * @param userId The ID of the user whose cache should be cleared.
     * @return A Mono that completes when the operation is done.
     */
    Mono<Void> invalidateUserCache(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/DriverRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Driver;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface DriverRepositoryPort {
    Mono<Boolean> setOnlineStatus(UUID driverId, boolean isOnline);

    Flux<String> findDeviceTokensOfOnlineDrivers();

    Flux<String> findEmailsOfEligibleDrivers();

    Mono<Driver> createDriver(UUID userId);

    Mono<Driver> save(Driver driver);

    Mono<Driver> findById(UUID driverId);

    Flux<Driver> findAll();

    Mono<Driver> validateProfile(UUID driverId);

    Flux<Driver> findAllPendingValidation();
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/DriverTrajectoryRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.DriverTrajectory;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface DriverTrajectoryRepositoryPort {
    Mono<Void> save(DriverTrajectory trajectory);

    // ‚úÖ Nouvelle m√©thode pour r√©cup√©rer l'historique
    Flux<DriverTrajectory> findAllByDriverId(UUID driverId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/ExternalUserPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.User;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ExternalUserPort {
    // Read
    Flux<User> fetchAllRemoteUsers(); // R√©cup√®re ceux du service par d√©faut

    Flux<User> fetchAllRemoteUsersByService(String serviceName); // R√©cup√®re pour un service sp√©cifique

    Mono<User> fetchRemoteUserById(UUID id);

    // Write (Propagation)
    Mono<Void> addRole(UUID userId, String roleName);

    Mono<Void> removeRole(UUID userId, String roleName);

    Mono<User> updateProfile(UUID userId, String firstName, String lastName, String phone);

    Mono<Void> changePassword(UUID userId, String currentPassword, String newPassword);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/FareCachePort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Fare;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface FareCachePort {
    Mono<Boolean> saveInCache(Fare fare);

    Mono<Fare> findFareById(UUID fareId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/FareClientPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import reactor.core.publisher.Mono;

public interface FareClientPort {
    Mono<FareResponse> caclculateFare(FareRequest request);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/LocationCachePort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface LocationCachePort {
    /**
     * Sauvegarde la position en temps r√©el (Geo) ET l'ajoute √† l'historique (List).
     */
    Mono<Boolean> saveLocation(UUID actorId, Double latitude, Double longitude);

    /**
     * R√©cup√®re la derni√®re position connue (Live).
     */
    Mono<Location> getLocation(UUID actorId);

    /**
     * Trouve les chauffeurs dans un rayon donn√©.
     * C'est ici que la magie Redis Geo op√©rera.
     */
    Flux<GeoResult> findNearbyDrivers(Double latitude, Double longitude, Double radiusKm);

    Mono<Void> saveOfferLocation(UUID offerId, Double lat, Double lon);

    Mono<Void> removeOfferLocation(UUID offerId);

    Flux<UUID> findNearbyOfferIds(Double lat, Double lon, Double radiusKm);

    // Record simple pour les coordonn√©es
    record Location(Double latitude, Double longitude) {
    }

    // Record pour le r√©sultat de recherche (ID + Distance)
    record GeoResult(UUID driverId, Double distanceKm, Location location) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/NotificationHistoryRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Notification;
import reactor.core.publisher.Mono;
import java.util.List;
import java.util.UUID;

public interface NotificationHistoryRepositoryPort {
    Mono<Void> save(Notification notification);

    Mono<PagedResult<Notification>> getUserNotifications(UUID userId, int page, int size);

    Mono<Void> markAsRead(UUID notificationId);

    Mono<Void> markAllAsReadForUser(UUID userId);

    // Record Helper pour la pagination
    record PagedResult<T>(List<T> content, long totalElements, int totalPages, int currentPage) {
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/NotificationSettingsRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.NotificationSettings;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface NotificationSettingsRepositoryPort {
    Mono<NotificationSettings> getSettings(UUID userId);
    Mono<Void> saveSettings(NotificationSettings settings);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/OfferCachePort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface OfferCachePort {
    Mono<Boolean> saveInCache(Offer offer);

    Mono<Offer> findOfferById(UUID offerId);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/OfferEventPublisherPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

public interface OfferEventPublisherPort {
    Mono<Void> publishOfferCreatedEvent(Offer offer);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/OfferRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface OfferRepositoryPort {
    Mono<Offer> save(Offer offer);
    Mono<Boolean> delete(Offer offer);
    Mono<Boolean> exists(Offer offer);
    Mono<Offer> findById(UUID offerId);
    Flux<Offer> findAll(); 
    Flux<Offer> findLatestPending(int limit);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/PaymentPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Wallet;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface PaymentPort {
    Mono<Wallet> createWallet(UUID ownerId, String ownerName);

    Mono<Wallet> getWalletByOwnerId(UUID ownerId);

    Mono<Void> processPayment(UUID walletId, double amount);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/ReviewRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Review;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ReviewRepositoryPort {
    Mono<Review> save(Review review);

    Mono<Double> getAverageRatingForDriver(UUID driverId);

    Mono<Long> countReviewsForDriver(UUID driverId);

    Flux<Review> findAllByDriverId(UUID driverId); // ‚úÖ NOUVEAU
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/RideRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Ride;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface RideRepositoryPort {
    Mono<Ride> save(Ride ride);

    Mono<Ride> findRideById(UUID id);

    Mono<Ride> findCurrentRideByDriverId(UUID driverId);

    Mono<Ride> findRideByOfferId(UUID offerId);

    Mono<Long> countCompletedRidesByDriverId(UUID driverId);

    Flux<Ride> findRideHistoryByUserId(UUID userId, int page, int size);

    Flux<Ride> findRideHistoryByDriverId(UUID driverId, int page, int size);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/RoleRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface RoleRepositoryPort {
    Mono<Role> findRoleById(UUID roleId);

    Mono<Role> findByRoleName(RoleType type);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/SendNotificationPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import reactor.core.publisher.Mono;

public interface SendNotificationPort {
    Mono<Boolean> sendNotification(SendNotificationRequest request);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/StockClientPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Mono;

public interface StockClientPort {
    /**
     * Verify if te stock is full.
     * @return true full, false otherwise
     */
    Mono<Boolean> isStockFull(String productName);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/SyndicatePort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Mono;
import java.util.UUID;

public interface SyndicatePort {
    Mono<Boolean> checkIsSyndicated(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/UserCachePort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.User;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface UserCachePort {
    Mono<Boolean> saveInCache(User user);

    Mono<User> findUserById(UUID userId);
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/UserDeviceRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Mono;
import java.util.UUID;

public interface UserDeviceRepositoryPort {
    Mono<Void> saveDeviceToken(UUID userId, String token, String platform);

    Mono<String> findDeviceTokenByUserId(UUID userId);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/UserRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

public interface UserRepositoryPort {
    Mono<User> save(User user);

    Mono<Boolean> delete(User user);

    Mono<Boolean> deleteById(UUID userId);

    Mono<Boolean> exists(User user);

    Mono<User> findUserById(UUID userId);

    Flux<User> findByRoleName(RoleType role);

    Flux<User> findAll();

    Mono<Void> addRoleToUser(UUID userId, RoleType role);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/ports/out/VehicleRepositoryPort.java ---
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Vehicle;
import org.springframework.http.codec.multipart.FilePart;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

// G√®re le cache Redis et l'appel distant
public interface VehicleRepositoryPort {
    // Cr√©ation via la route simplifi√©e
    Mono<Vehicle> createVehicle(Vehicle vehicle);

    // R√©cup√©ration (Cache -> Distant)
    Mono<Vehicle> getVehicleById(UUID vehicleId);

    // Mise √† jour partielle (Patch)
    Mono<Vehicle> patchVehicle(UUID vehicleId, Vehicle partialUpdate);

    // Gestion des Documents Obligatoires
    Mono<Vehicle> uploadRegistrationDocument(UUID vehicleId, FilePart file);

    Mono<Vehicle> uploadSerialDocument(UUID vehicleId, FilePart file);

    // Gestion de la Galerie d'images
    Mono<String> uploadVehicleImage(UUID vehicleId, FilePart file); // Retourne l'URL/Path

    Flux<String> getVehicleImages(UUID vehicleId); // Retourne les URLs

    Mono<Void> cacheVehicle(Vehicle vehicle);
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Bid.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.List;
import java.util.UUID;

@Builder
public record Bid(
        UUID driverId,
        String driverName,
        String driverPhone, // ‚úÖ Ajout√©
        String driverPhoto,
        Double rating,
        Integer totalTrips,
        Integer eta,
        Double distanceToPassenger,
        Double latitude,
        Double longitude,
        String vehicleId,
        String brand,
        String model,
        String color,
        String licensePlate,
        String vehicleType,
        Integer manufacturingYear,
        List<String> vehicleImages) {
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Driver.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.UUID;

@Builder(toBuilder = true)
public record Driver(
        UUID id,
        String status,
        String licenseNumber,
        boolean hasCar,
        boolean isOnline,
        boolean isProfileCompleted,
        boolean isProfileValidated,
        boolean isSyndicated,
        UUID vehicleId,
        Double rating, // NOUVEAU
        Integer totalReviewsCount // NOUVEAU
) {
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/DriverTrajectory.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.time.LocalDateTime;
import java.util.UUID;

@Builder
public record DriverTrajectory(
        UUID id,
        UUID driverId,
        LocalDateTime startTime,
        LocalDateTime endTime,
        Integer pointsCount,
        String trajectoryDataJson // On le passe en String JSON pour l'adaptateur
) {
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Fare.java ---
package com.yowyob.rideandgo.domain.model;

import java.util.UUID;

public record Fare(
        UUID id,
        UUID userId,
        String startPoint,
        String endPoint,
        Double estimatedFare,
        Double  officialFare
) {
}


--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Notification.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.time.LocalDateTime;
import java.util.UUID;

@Builder
public record Notification(
    UUID id,
    UUID userId,
    String title,
    String message,
    String type,
    boolean isRead,
    LocalDateTime createdAt,
    String dataJson
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/NotificationSettings.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.UUID;

@Builder
public record NotificationSettings(
    UUID userId,
    boolean emailEnabled,
    boolean smsEnabled,
    boolean pushEnabled,
    boolean whatsappEnabled
) {
    // Par d√©faut, si l'user n'a jamais configur√©
    public static NotificationSettings defaults(UUID userId) {
        return new NotificationSettings(userId, true, false, true, false); 
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Offer.java ---
package com.yowyob.rideandgo.domain.model;

import com.yowyob.rideandgo.domain.model.enums.OfferState;
import lombok.Builder;
import java.util.List;
import java.util.UUID;
import java.time.LocalDateTime;

@Builder
public record Offer(
        UUID id,
        UUID passengerId,
        UUID selectedDriverId,
        String startPoint,
        Double startLat,
        Double startLon,
        String endPoint,
        Double endLat, // ‚úÖ AJOUT√â
        Double endLon, // ‚úÖ AJOUT√â
        double price,
        String passengerPhone,
        String departureTime,
        OfferState state,
        List<Bid> bids,
        Long version,
        LocalDateTime createdAt // ‚úÖ Ajout√© pour la landing page
) {
    public Offer withBids(List<Bid> bids) {
        return new Offer(id, passengerId, selectedDriverId, startPoint, startLat, startLon,
                endPoint, endLat, endLon, price, passengerPhone, departureTime, state, bids, version, createdAt);
    }

    public Offer withState(OfferState state) {
        return new Offer(id, passengerId, selectedDriverId, startPoint, startLat, startLon,
                endPoint, endLat, endLon, price, passengerPhone, departureTime, state, bids, version, createdAt);
    }

    public Offer withDriverSelected(UUID driverId) {
        return new Offer(id, passengerId, driverId, startPoint, startLat, startLon,
                endPoint, endLat, endLon, price, passengerPhone, departureTime, OfferState.DRIVER_SELECTED, bids,
                version, createdAt);
    }

    public boolean hasDriverApplied(UUID driverId) {
        if (bids == null)
            return false;
        return bids.stream().anyMatch(b -> b.driverId().equals(driverId));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Permission.java ---
package com.yowyob.rideandgo.domain.model;
import java.util.UUID;

public record Permission(UUID id, String name) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Review.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.UUID;
import java.time.LocalDateTime;

@Builder
public record Review(
    UUID id,
    UUID rideId,
    UUID passengerId,
    UUID driverId,
    int rating,
    String comment,
    LocalDateTime createdAt
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Ride.java ---
package com.yowyob.rideandgo.domain.model;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import lombok.Builder;
import java.time.LocalDateTime;
import java.util.UUID;

@Builder
public record Ride(
        UUID id,
        UUID offerId,
        UUID passengerId,
        UUID driverId,
        double distance,
        int duration,
        RideState state,
        int timeReal,
        LocalDateTime createdAt // ‚úÖ Ajout√©
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Role.java ---
package com.yowyob.rideandgo.domain.model;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import java.util.Set;
import java.util.UUID;
import lombok.Builder;

@Builder
public record Role(
    UUID id, 
    RoleType type,
    Set<Permission> permissions
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/User.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.Set;
import java.util.UUID;

@Builder
public record User(
    UUID id,
    String name,        // Username / Pseudo
    String firstName,   // Pr√©nom
    String lastName,    // Nom
    String email,
    String telephone,
    String password,
    String photoUri,
    Set<Role> roles,
    Set<Permission> directPermissions
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Vehicle.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;

import java.util.List;
import java.util.UUID;

@Builder
public record Vehicle(
    // ID du v√©hicule (Cl√© primaire)
    UUID id,

    // IDs des r√©f√©rentiels (Cl√©s √©trang√®res logiques)
    String vehicleMakeId,
    String vehicleModelId,
    String transmissionTypeId,
    String manufacturerId,
    String vehicleSizeId,
    String vehicleTypeId,
    String fuelTypeId,

    // Informations d'identification
    String vehicleSerialNumber,
    String vehicleSerialPhoto, // URL
    String registrationNumber, // Plaque d'immatriculation
    String registrationPhoto,  // URL

    // Capacit√©s et caract√©ristiques
    int tankCapacity,
    int luggageMaxCapacity,
    int totalSeatNumber,
    double averageFuelConsumptionPerKm,
    int mileageAtStart,
    int mileageSinceCommissioning,
    int vehicleAgeAtStart,
    
    // Champ redondant mais pr√©sent
    String brand,

    List<String> illustrationImages
) {}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/Wallet.java ---
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.UUID;

@Builder
public record Wallet(
        UUID id,
        UUID ownerId,
        String ownerName,
        double balance) {
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/enums/OfferState.java ---
package com.yowyob.rideandgo.domain.model.enums;

/**
 * Lifecycle states of a transport Offer as defined in spec.md
 */
public enum OfferState {
    /** Initial state, waiting for drivers */
    PENDING,
    
    /** At least one driver applied */
    BID_RECEIVED,
    
    /** Passenger chose a driver */
    DRIVER_SELECTED,
    
    /** Driver confirmed, offer is closed and becomes a Ride */
    VALIDATED,
    
    /** Cancelled or expired */
    CANCELLED
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/enums/RideState.java ---
package com.yowyob.rideandgo.domain.model.enums;

/**
 * Lifecycle states of a Trip (Ride) as defined in spec.md
 */
public enum RideState {
    /** Ride initialized, driver approaching passenger */
    CREATED,
    
    /** Passenger picked up, trip in progress */
    ONGOING,
    
    /** Trip finished at destination */
    COMPLETED,
    
    /** Trip interrupted or cancelled */
    CANCELLED
}

--- FILE: src/main/java/com/yowyob/rideandgo/domain/model/enums/RoleType.java ---
package com.yowyob.rideandgo.domain.model.enums;

public enum RoleType {
    // R√¥les M√©tier Ride & Go (Identiques √† la DB Distante)
    RIDE_AND_GO_PASSENGER,
    RIDE_AND_GO_DRIVER,
    RIDE_AND_GO_ADMIN
} 

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/AdminService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.Driver;
import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.SendNotificationPort;
import com.yowyob.rideandgo.domain.ports.out.UserDeviceRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.NotificationType;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.Map;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class AdminService {

    private final DriverRepositoryPort driverRepositoryPort;
    private final SendNotificationPort sendNotificationPort;
    private final UserDeviceRepositoryPort userDeviceRepositoryPort;

    // Injection de l'ID g√©n√©r√© (√† mettre √† jour dans application.yml apr√®s ex√©cution du script python)
    @Value("${application.notification.templates.admin-validation:7}")
    private int tmplAccountValidated;

    public Flux<Driver> getPendingDrivers() {
        return driverRepositoryPort.findAllPendingValidation();
    }

    public Mono<Driver> validateDriver(UUID driverId) {
        return driverRepositoryPort.validateProfile(driverId)
                .flatMap(driver -> {
                    log.info("üëÆ Admin validated driver {}", driverId);
                    
                    // Notification au chauffeur (Async)
                    notifyDriverValidation(driverId).subscribe();
                    
                    return Mono.just(driver);
                });
    }

    private Mono<Void> notifyDriverValidation(UUID driverId) {
        return userDeviceRepositoryPort.findDeviceTokenByUserId(driverId)
                .flatMap(token -> sendNotificationPort.sendNotification(
                        SendNotificationRequest.builder()
                                .notificationType(NotificationType.PUSH) // On privil√©gie le Push pour l'instant
                                .templateId(tmplAccountValidated)
                                .to(List.of(token))
                                .data(Map.of(
                                    "message", "Votre compte chauffeur a √©t√© valid√© ! Vous pouvez passer en ligne."
                                ))
                                .build()
                ))
                .doOnError(e -> log.warn("Failed to notify driver validation: {}", e.getMessage()))
                .then();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/AuthService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.AuthUseCase;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.PaymentPort;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.List;

@Slf4j
@Service
@RequiredArgsConstructor
public class AuthService implements AuthUseCase {

    private final AuthPort authPort;
    private final PaymentPort paymentPort;
    private final DriverRepositoryPort driverRepositoryPort;

    @Override
    public Mono<AuthPort.AuthResponse> login(String identifier, String password) {
        return authPort.login(identifier, password);
    }

    @Override
    public Mono<AuthPort.AuthResponse> refreshToken(String refreshToken) {
        return authPort.refreshToken(refreshToken);
    }

    @Override
    public Mono<AuthPort.AuthResponse> register(String username, String email, String password, String phone,
            String firstName, String lastName, List<RoleType> roles, FilePart photo) {

        return authPort.register(username, password, email, phone, firstName, lastName, roles, photo)
                .flatMap(response -> {
                    boolean isDriver = roles.contains(RoleType.RIDE_AND_GO_DRIVER);

                    if (isDriver) {
                        log.info("üöï Driver registered, initializing profile for {}", response.userId());

                        // 1. On cr√©e explicitement l'entr√©e dans la table 'drivers'
                        return driverRepositoryPort.createDriver(response.userId())
                                // 2. On cr√©e le wallet
                                .flatMap(d -> {
                                    log.info("üí≥ Creating wallet for driver {}", response.userId());
                                    return paymentPort.createWallet(response.userId(), response.username());
                                })
                                .thenReturn(response)
                                .onErrorResume(e -> {
                                    log.error("‚ö†Ô∏è Driver initialization warning: {}", e.getMessage());
                                    // On ne bloque pas l'inscription si le wallet √©choue (ex: d√©j√† existant)
                                    return Mono.just(response);
                                });
                    }
                    return Mono.just(response);
                });
    }

    @Override
    public Mono<Void> resetPassword(String email) {
        return authPort.forgotPassword(email);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/DeviceService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.ports.in.RegisterDeviceTokenUseCase;
import com.yowyob.rideandgo.domain.ports.out.UserDeviceRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class DeviceService implements RegisterDeviceTokenUseCase {

    private final UserDeviceRepositoryPort deviceRepositoryPort;

    @Override
    public Mono<Void> registerToken(UUID userId, String token, String platform) {
        log.info("üì± Registering device token for user {}", userId);
        return deviceRepositoryPort.saveDeviceToken(userId, token, platform);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/EtaCalculatorService.java ---
package com.yowyob.rideandgo.application.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.concurrent.ThreadLocalRandom;

@Slf4j
@Service
public class EtaCalculatorService {

    /**
     * Logic: Random value between 3 and 12 minutes for MVP.
     */
    public Mono<Integer> calculateEta(Double startLat, Double startLon, Double endLat, Double endLon) {
        return Mono.fromCallable(() -> ThreadLocalRandom.current().nextInt(3, 13));
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/FareService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.domain.ports.in.PutFareInCacheUseCase;
import com.yowyob.rideandgo.domain.ports.out.FareCachePort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class FareService implements PutFareInCacheUseCase {

    private final FareCachePort fareCachePort;

    @Override
    public Mono<Boolean> putFareInCache(Fare fare) {
        return fareCachePort.saveInCache(fare);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/LocationService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.ports.in.GetRideLocationUseCase;
import com.yowyob.rideandgo.domain.ports.in.UpdateLocationUseCase;
import com.yowyob.rideandgo.domain.ports.out.LocationCachePort;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideTrackingResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class LocationService implements UpdateLocationUseCase, GetRideLocationUseCase {

    private final LocationCachePort locationCachePort;
    private final RideRepositoryPort rideRepositoryPort;
    private final TrackingCalculatorService trackingCalculatorService; // Injection du nouveau service

    // --- 1. Mise √† jour de ma position (Existante) ---
    @Override
    public Mono<Boolean> updateCurrentLocation(Double latitude, Double longitude) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    String userIdStr = auth.getName(); 
                    try {
                        UUID userId = UUID.fromString(userIdStr);
                        return locationCachePort.saveLocation(userId, latitude, longitude);
                    } catch (IllegalArgumentException e) {
                        log.error("Security Context principal is not a valid UUID: {}", userIdStr);
                        return Mono.just(false);
                    }
                })
                .switchIfEmpty(Mono.error(new RuntimeException("No security context found for location update")));
    }

    // --- 2. Consultation Intelligente (Nouvelle Impl√©mentation) ---
    @Override
    public Mono<RideTrackingResponse> getPartnerLocation(UUID rideId, UUID requesterId) {
        return rideRepositoryPort.findRideById(rideId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Ride not found")))
                .flatMap(ride -> {
                    UUID targetId;
                    String targetRole;

                    // D√©termination Sym√©trique
                    if (requesterId.equals(ride.driverId())) {
                        targetId = ride.passengerId();
                        targetRole = "PASSENGER";
                    } else if (requesterId.equals(ride.passengerId())) {
                        targetId = ride.driverId();
                        targetRole = "DRIVER";
                    } else {
                        return Mono.error(new IllegalStateException("Access Denied: You are not part of this ride"));
                    }

                    // R√©cup√©ration Parall√®le des 2 positions
                    Mono<LocationCachePort.Location> targetLocMono = locationCachePort.getLocation(targetId)
                            .defaultIfEmpty(new LocationCachePort.Location(0.0, 0.0));
                    
                    Mono<LocationCachePort.Location> myLocMono = locationCachePort.getLocation(requesterId)
                            .defaultIfEmpty(new LocationCachePort.Location(0.0, 0.0));

                    return Mono.zip(targetLocMono, myLocMono)
                            .map(tuple -> {
                                LocationCachePort.Location targetLoc = tuple.getT1();
                                LocationCachePort.Location myLoc = tuple.getT2();

                                double distance = 0.0;
                                int eta = 0;

                                // On ne calcule que si les positions sont valides
                                if (targetLoc.latitude() != 0.0 && myLoc.latitude() != 0.0) {
                                    distance = trackingCalculatorService.calculateDistance(
                                            myLoc.latitude(), myLoc.longitude(),
                                            targetLoc.latitude(), targetLoc.longitude()
                                    );
                                    eta = trackingCalculatorService.calculateEtaInMinutes(distance);
                                }

                                return new RideTrackingResponse(
                                        targetLoc.latitude(),
                                        targetLoc.longitude(),
                                        distance,
                                        eta,
                                        targetRole
                                );
                            });
                });
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/NotificationService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.ports.in.MarkNotificationAsReadUseCase;
import com.yowyob.rideandgo.domain.ports.out.NotificationHistoryRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class NotificationService implements MarkNotificationAsReadUseCase {
    private final NotificationHistoryRepositoryPort historyRepositoryPort;

    @Override
    public Mono<Void> markAsRead(UUID notificationId, UUID userId) {
        log.info("Marking notification {} as read for user {}", notificationId, userId);
        // Ici, on pourrait ajouter une v√©rification pour s'assurer que la notification
        // appartient bien au userId
        // Mais pour simplifier, on d√©l√®gue au repo.
        return historyRepositoryPort.markAsRead(notificationId);
    }

    @Override
    public Mono<Void> markAllAsRead(UUID userId) {
        log.info("Marking all notifications as read for user {}", userId);
        return historyRepositoryPort.markAllAsReadForUser(userId);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/OfferService.java ---
package com.yowyob.rideandgo.application.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.exception.OfferNotFoundException;
import com.yowyob.rideandgo.domain.exception.OfferStatutNotMatchException;
import com.yowyob.rideandgo.domain.model.*;
import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.in.*;
import com.yowyob.rideandgo.domain.ports.out.*;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.LandingOfferResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.NotificationType;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class OfferService implements
        CreateOfferUseCase,
        ResponseToOfferUseCase,
        GetAvailableOffersUseCase,
        SelectDriverUseCase,
        OfferManagementUseCase {

    private final OfferRepositoryPort repository;
    private final UserRepositoryPort userRepositoryPort;
    private final SendNotificationPort sendNotificationPort;
    private final RideRepositoryPort rideRepositoryPort;
    private final LocationCachePort locationCachePort;
    private final EtaCalculatorService etaCalculatorService;
    private final TrackingCalculatorService trackingCalculatorService;
    private final DriverRepositoryPort driverRepositoryPort;
    private final VehicleRepositoryPort vehicleRepositoryPort;
    private final PaymentPort paymentPort;
    private final NotificationSettingsRepositoryPort settingsRepositoryPort;
    private final NotificationHistoryRepositoryPort historyRepositoryPort;
    private final UserDeviceRepositoryPort userDeviceRepositoryPort;
    private final ExternalUserPort externalUserPort;
    private final OfferCachePort cache;
    private final ObjectMapper objectMapper;

    @Value("${application.payment.commission-rate:0.10}")
    private double commissionRate;

    @Value("${application.notification.templates.new-offer:1}")
    private int tmplNewOffer;
    @Value("${application.notification.templates.driver-applied:2}")
    private int tmplDriverApplied;
    @Value("${application.notification.templates.driver-selected:3}")
    private int tmplDriverSelected;
    @Value("${application.notification.templates.ride-confirmed:4}")
    private int tmplRideConfirmed;
    @Value("${application.notification.templates.ride-cancelled:5}")
    private int tmplRideCancelled;

    @Value("${application.offer.search-radius-km:20.0}")
    private double searchRadius;

    // ==================================================================================
    // 1. CR√âATION D'OFFRE (PASSAGER)
    // ==================================================================================
    @Override
    public Mono<Offer> createOffer(Offer request, UUID callerId) {
        return userRepositoryPort.findUserById(callerId)
                .flatMap(user -> {
                    // Logique m√©tier : Si pas de num√©ro tiers, on prend celui du compte
                    String finalPhone = (request.passengerPhone() != null && !request.passengerPhone().isBlank())
                            ? request.passengerPhone()
                            : user.telephone();

                    Offer offer = Offer.builder()
                            .id(Utils.generateUUID())
                            .passengerId(callerId)
                            .startPoint(request.startPoint())
                            .startLat(request.startLat())
                            .startLon(request.startLon())
                            .endPoint(request.endPoint())
                            .price(request.price())
                            .passengerPhone(finalPhone)
                            .departureTime(request.departureTime())
                            .state(OfferState.PENDING)
                            .bids(new ArrayList<>())
                            .build();

                    // On utilise updateOfferState pour la coh√©rence DB/Redis Geo
                    return updateOfferState(offer, OfferState.PENDING)
                            .flatMap(saved -> {
                                // Lancement asynchrone du matching
                                this.notifyNearbyDrivers(saved).subscribe();
                                return Mono.just(saved);
                            });
                });
    }

    private Mono<Offer> updateOfferState(Offer offer, OfferState newState) {
        Offer updated = offer.withState(newState);
        return repository.save(updated)
                .flatMap(saved -> {
                    // Nettoyage de l'index de recherche si l'offre n'est plus "ouverte"
                    if (newState != OfferState.PENDING && newState != OfferState.BID_RECEIVED) {
                        return locationCachePort.removeOfferLocation(saved.id()).thenReturn(saved);
                    }
                    // Indexation si l'offre est active
                    return locationCachePort.saveOfferLocation(saved.id(), saved.startLat(), saved.startLon())
                            .thenReturn(saved);
                })
                .flatMap(saved -> cache.saveInCache(saved).thenReturn(saved));
    }

    private Mono<Void> notifyNearbyDrivers(Offer offer) {
        log.info("üéØ Start matching for Offer {} in radius {}km", offer.id(), searchRadius);

        // 1. Trouver les chauffeurs √©ligibles (On r√©cup√®re l'objet User complet)
        return locationCachePort.findNearbyDrivers(offer.startLat(), offer.startLon(), searchRadius)
                .flatMap(geoResult -> {
                    UUID driverId = geoResult.driverId();
                    return driverRepositoryPort.findById(driverId)
                            .filter(d -> d.isOnline() && d.isProfileValidated())
                            .flatMap(driver -> paymentPort.getWalletByOwnerId(driverId)
                                    .filter(wallet -> wallet.balance() >= (offer.price() * commissionRate))
                                    .flatMap(wallet -> userRepositoryPort.findUserById(driverId))); // On retourne le
                                                                                                    // User
                })
                .collectList()
                .flatMap(users -> {
                    if (users.isEmpty()) {
                        log.warn("‚ö†Ô∏è No eligible drivers found within {}km for offer {}", searchRadius, offer.id());
                        return Mono.empty();
                    }

                    log.info("üì¢ Notifying {} nearby drivers for offer {}", users.size(), offer.id());

                    Map<String, String> data = Map.of(
                            "offerId", offer.id().toString(),
                            "price", String.valueOf(offer.price()),
                            "start", offer.startPoint());

                    // 2. Pr√©parer la liste des emails pour l'envoi group√©
                    List<String> emails = new ArrayList<>();

                    // 3. Pr√©parer les sauvegardes en base (Historique)
                    List<Mono<Void>> historySaves = new ArrayList<>();

                    String json = "{}";
                    try {
                        json = objectMapper.writeValueAsString(data);
                    } catch (Exception e) {
                    }

                    for (User user : users) {
                        emails.add(user.email());

                        // Cr√©ation de l'entr√©e historique pour CHAQUE chauffeur
                        Notification history = Notification.builder()
                                .id(Utils.generateUUID())
                                .userId(user.id())
                                .title("Nouvelle course disponible")
                                .message("Une course de " + offer.price() + " F est disponible √† " + offer.startPoint())
                                .type("OFFER")
                                .isRead(false)
                                .dataJson(json)
                                .build();

                        historySaves.add(historyRepositoryPort.save(history));
                    }

                    // 4. Ex√©cuter : Sauvegarde Historique (Parall√®le) ET Envoi Push (Group√©)
                    Mono<Boolean> sendTask = sendNotificationPort.sendNotification(
                            SendNotificationRequest.builder()
                                    .notificationType(NotificationType.EMAIL)
                                    .templateId(tmplNewOffer)
                                    .to(emails)
                                    .data(data)
                                    .build());

                    // On lance tout en m√™me temps
                    return Flux.merge(historySaves).then(sendTask).then();
                });
    }

    private Mono<User> ensureUserExistsLocally(UUID userId) {
        return userRepositoryPort.findUserById(userId)
                .switchIfEmpty(Mono.defer(() -> externalUserPort.fetchRemoteUserById(userId)
                        .flatMap(userRepositoryPort::save)));
    }

    // ==================================================================================
    // 2. DISCOVERY (CHAUFFEUR)
    // ==================================================================================
    @Override
    public Flux<Offer> getAvailableOffers() {
        return ReactiveSecurityContextHolder.getContext()
                .map(ctx -> UUID.fromString(ctx.getAuthentication().getName()))
                .flatMapMany(driverId ->
                // TENTATIVE 1 : Recherche G√©o
                locationCachePort.getLocation(driverId)
                        .flatMapMany(loc -> {
                            log.info("üìç Driver {} location found, searching within {}km", driverId, searchRadius);
                            return locationCachePort.findNearbyOfferIds(loc.latitude(), loc.longitude(), searchRadius)
                                    .flatMap(repository::findById);
                        })
                        // TENTATIVE 2 : Fallback si pas de position ou pas d'offres proches
                        .switchIfEmpty(Flux.defer(() -> {
                            log.warn("üì° No location for driver {} or no nearby offers. Falling back to latest offers.",
                                    driverId);
                            return repository.findLatestPending(20);
                        }))
                        // FILTRAGE & ENRICHISSEMENT (Commun aux deux cas)
                        .filter(o -> o.state() == OfferState.PENDING || o.state() == OfferState.BID_RECEIVED)
                        .distinct(Offer::id) // √âvite les doublons si une offre est dans les deux flux
                        .flatMap(this::enrichOffer)); 
    }

    public Flux<LandingOfferResponse> getLatestPublicOffers(int limit) {
        return repository.findLatestPending(limit)
                .map(offer -> new LandingOfferResponse(
                        offer.startPoint(),
                        offer.endPoint(),
                        offer.startLat(),
                        offer.startLon(),
                        offer.endLat(), // ‚úÖ Pour dessiner la ligne d'arriv√©e sur la map
                        offer.endLon(), // ‚úÖ
                        offer.price(),
                        offer.departureTime(),
                        // On r√©cup√®re la date de cr√©ation depuis le domaine
                        // Note: Assure-toi que ton OfferMapper mappe bien createdDate vers createdAt
                        LocalDateTime.now() // LocalDateTime.now() // Par d√©faut si null, mais utilise offer.createdAt()
                ));
    }

    // ==================================================================================
    // 3. CANDIDATURE (CHAUFFEUR)
    // ==================================================================================
    @Override
    public Mono<Offer> responseToOffer(UUID offerId, UUID driverId) {
        return ensureUserExistsLocally(driverId)
                .flatMap(driverUser -> repository.findById(offerId)
                        .switchIfEmpty(Mono.error(new OfferNotFoundException("Offre introuvable")))
                        .flatMap(offer -> paymentPort.getWalletByOwnerId(driverId)
                                .flatMap(wallet -> {
                                    // V√âRIFICATION COMMISSION : prix * taux < solde
                                    double estimatedCommission = offer.price() * commissionRate;
                                    if (wallet.balance() < estimatedCommission) {
                                        return Mono.error(new IllegalStateException(
                                                "Solde insuffisant pour couvrir la commission (" + estimatedCommission
                                                        + " F)."));
                                    }
                                    return Mono.just(offer);
                                }))
                        .flatMap(offer -> {
                            if (offer.hasDriverApplied(driverId))
                                return Mono.just(offer);

                            List<Bid> currentBids = offer.bids() != null ? new ArrayList<>(offer.bids())
                                    : new ArrayList<>();
                            currentBids.add(Bid.builder().driverId(driverId).build());

                            log.info("üöÄ Driver {} applying to Offer {}.", driverId, offerId);

                            // Mise √† jour de l'√©tat vers BID_RECEIVED
                            return updateOfferState(offer.withBids(currentBids), OfferState.BID_RECEIVED)
                                    .flatMap(saved -> {
                                        saveAndDispatch(
                                                saved.passengerId(),
                                                tmplDriverApplied,
                                                "Nouvelle candidature",
                                                driverUser.name() + " a postul√© pour votre course.",
                                                Map.of("driverName", driverUser.name(), "offerId", offerId.toString()))
                                                .subscribe();
                                        return Mono.just(saved);
                                    });
                        }));
    }

    // ==================================================================================
    // 4. S√âLECTION (PASSAGER)
    // ==================================================================================
    @Override
    public Mono<Offer> selectDriver(UUID offerId, UUID driverId) {
        return repository.findById(offerId)
                .flatMap(offer -> {
                    if (!offer.hasDriverApplied(driverId)) {
                        return Mono.error(new IllegalArgumentException("Driver has not applied."));
                    }
                    Offer updated = offer.withDriverSelected(driverId);
                    return repository.save(updated)
                            .flatMap(saved -> cache.saveInCache(saved).thenReturn(saved))
                            .flatMap(saved -> {
                                saveAndDispatch(
                                        driverId,
                                        tmplDriverSelected,
                                        "Course obtenue !",
                                        "Le client vous a s√©lectionn√© pour la course.",
                                        Map.of("offerId", offerId.toString(), "price", String.valueOf(offer.price())))
                                        .subscribe();
                                return Mono.just(saved);
                            });
                });
    }

    // ==================================================================================
    // 5. CONFIRMATION & CR√âATION TRIP (CHAUFFEUR)
    // ==================================================================================
    @Transactional
    public Mono<Ride> driverAcceptsOffer(UUID offerId, UUID driverId) {
        log.info("üèÅ Driver {} is accepting Offer {}", driverId, offerId);

        return repository.findById(offerId)
                .switchIfEmpty(Mono.error(new OfferNotFoundException("Offre introuvable")))
                .flatMap(offer -> {
                    // S√©curit√©s
                    if (offer.state() != OfferState.DRIVER_SELECTED) {
                        return Mono.error(new OfferStatutNotMatchException("L'offre n'est plus disponible."));
                    }
                    if (offer.selectedDriverId() == null || !offer.selectedDriverId().equals(driverId)) {
                        return Mono.error(new IllegalStateException("Vous n'√™tes pas le chauffeur s√©lectionn√©."));
                    }

                    // 1. Paiement effectif de la commission
                    return paymentPort.getWalletByOwnerId(driverId)
                            .flatMap(wallet -> paymentPort.processPayment(wallet.id(), offer.price()))
                            // 2. Mise √† jour de l'Offre vers VALIDATED (Retrait de Redis Geo automatique)
                            .then(updateOfferState(offer, OfferState.VALIDATED))
                            .thenReturn(offer);
                })
                .flatMap(offer -> {
                    // 3. Cr√©ation de la Course (Ride)
                    Ride ride = Ride.builder()
                            .id(Utils.generateUUID())
                            .offerId(offer.id())
                            .passengerId(offer.passengerId())
                            .driverId(driverId)
                            .distance(0.0)
                            .duration(0)
                            .state(RideState.CREATED)
                            .build();

                    return rideRepositoryPort.save(ride)
                            .flatMap(savedRide -> {
                                log.info("üöÄ Ride created: {}", savedRide.id());
                                saveAndDispatch(
                                        offer.passengerId(),
                                        tmplRideConfirmed,
                                        "Chauffeur en route",
                                        "Votre chauffeur a confirm√© et arrive.",
                                        Map.of("rideId", savedRide.id().toString(), "driverId", driverId.toString()))
                                        .subscribe();
                                return Mono.just(savedRide);
                            });
                });
    }

    // ==================================================================================
    // 6. ANNULATION (PASSAGER)
    // ==================================================================================
    public Mono<Offer> cancelOffer(UUID offerId) {
        return repository.findById(offerId)
                .switchIfEmpty(Mono.error(new OfferNotFoundException("Offre introuvable")))
                .flatMap(offer -> {
                    if (offer.state() == OfferState.VALIDATED) {
                        return Mono.error(new IllegalStateException("Impossible d'annuler une offre d√©j√† valid√©e."));
                    }

                    return updateOfferState(offer, OfferState.CANCELLED)
                            .flatMap(saved -> {
                                if (offer.selectedDriverId() != null) {
                                    saveAndDispatch(
                                            offer.selectedDriverId(),
                                            tmplRideCancelled,
                                            "Course annul√©e",
                                            "Le client a annul√© la course.",
                                            Map.of("offerId", offerId.toString())).subscribe();
                                }
                                return Mono.just(saved);
                            });
                });
    }

    // ==================================================================================
    // CENTRALISATION : NOTIFICATIONS ET HISTORIQUE
    // ==================================================================================

    /**
     * NOTIFICATION FILTR√âE : Chauffeurs en ligne, complets, valid√©s ET avec solde
     * suffisant.
     */
    private Mono<Void> notifyEligibleDriversWithBalance(Offer offer) {
        log.info("üì¢ Notifying eligible drivers for offer {} (Price: {})", offer.id(), offer.price());

        double requiredBalance = offer.price() * commissionRate;

        return driverRepositoryPort.findAll()
                .filter(d -> d.isOnline() && d.isProfileCompleted() && d.isProfileValidated())
                .flatMap(driver -> paymentPort.getWalletByOwnerId(driver.id())
                        .filter(wallet -> wallet.balance() >= requiredBalance)
                        .flatMap(wallet -> userRepositoryPort.findUserById(driver.id()))
                        .map(User::email))
                .collectList()
                .flatMap(emails -> {
                    if (emails.isEmpty())
                        return Mono.empty();

                    Map<String, String> data = Map.of(
                            "offerId", offer.id().toString(),
                            "price", String.valueOf(offer.price()),
                            "start", offer.startPoint(),
                            "end", offer.endPoint());

                    return send(NotificationType.EMAIL, tmplNewOffer, emails, data);
                })
                .then();
    }

    private Mono<Void> saveAndDispatch(UUID userId, int templateId, String title, String message,
            Map<String, String> data) {
        String json = "{}";
        try {
            json = objectMapper.writeValueAsString(data);
        } catch (Exception e) {
            log.warn("Serialization failed", e);
        }

        Notification history = Notification.builder()
                .id(Utils.generateUUID())
                .userId(userId)
                .title(title)
                .message(message)
                .type("INFO")
                .isRead(false)
                .dataJson(json)
                .build();

        return historyRepositoryPort.save(history).then(dispatchNotification(userId, templateId, data));
    }

    private Mono<Void> dispatchNotification(UUID userId, int templateId, Map<String, String> data) {
        return settingsRepositoryPort.getSettings(userId)
                .flatMap(settings -> {
                    List<Mono<Boolean>> sendingTasks = new ArrayList<>();
                    if (settings.pushEnabled()) {
                        sendingTasks.add(userDeviceRepositoryPort.findDeviceTokenByUserId(userId)
                                .flatMap(token -> send(NotificationType.PUSH, templateId, List.of(token), data))
                                .defaultIfEmpty(false));
                    }
                    if (settings.emailEnabled()) {
                        sendingTasks.add(userRepositoryPort.findUserById(userId)
                                .flatMap(
                                        user -> send(NotificationType.EMAIL, templateId, List.of(user.email()), data)));
                    }
                    return Flux.merge(sendingTasks).then();
                });
    }

    private Mono<Boolean> send(NotificationType type, int tmpl, List<String> to, Map<String, String> data) {
        return sendNotificationPort.sendNotification(
                SendNotificationRequest.builder()
                        .notificationType(type)
                        .templateId(tmpl)
                        .to(to)
                        .data(new HashMap<>(data))
                        .build());
    }

    private Mono<Offer> enrichOffer(Offer offer) {
        if (offer.bids() == null || offer.bids().isEmpty()) {
            return Mono.just(offer);
        }

        LocationCachePort.Location offerStartLoc = new LocationCachePort.Location(
                offer.startLat() != null ? offer.startLat() : 0.0,
                offer.startLon() != null ? offer.startLon() : 0.0);

        return Flux.fromIterable(offer.bids())
                .flatMap(bid -> enrichSingleBid(bid, offerStartLoc))
                .collectList()
                .map(offer::withBids);
    }

    // ==================================================================================
    // ENRICHISSEMENT (UI) AVEC DONN√âES R√âELLES
    // ==================================================================================

    public Mono<Offer> getOfferWithEnrichedBids(UUID offerId) {
        return repository.findById(offerId)
                .flatMap(offer -> {
                    if (offer.bids() == null || offer.bids().isEmpty())
                        return Mono.just(offer);

                    // CORRECTION ICI AUSSI
                    LocationCachePort.Location offerStartLoc = new LocationCachePort.Location(
                            offer.startLat() != null ? offer.startLat() : 0.0,
                            offer.startLon() != null ? offer.startLon() : 0.0);

                    return Flux.fromIterable(offer.bids())
                            .flatMap(bid -> enrichSingleBid(bid, offerStartLoc))
                            .collectList()
                            .map(offer::withBids);
                });
    }

    /**
     * Orchestre la r√©cup√©ration des donn√©es r√©elles pour un seul chauffeur.
     */
    private Mono<Bid> enrichSingleBid(Bid bid, LocationCachePort.Location pLoc) {
        UUID dId = bid.driverId();

        return Mono.zip(
                userRepositoryPort.findUserById(dId),
                driverRepositoryPort.findById(dId),
                locationCachePort.getLocation(dId).defaultIfEmpty(new LocationCachePort.Location(0.0, 0.0)))
                .flatMap(tuple -> {
                    User user = tuple.getT1();
                    Driver driver = tuple.getT2();
                    LocationCachePort.Location dLoc = tuple.getT3();

                    double distance = 0.0;
                    int eta = 0;

                    // Calcul temps r√©el si les deux positions sont connues
                    if (pLoc.latitude() != 0.0 && dLoc.latitude() != 0.0) {
                        distance = trackingCalculatorService.calculateDistance(
                                pLoc.latitude(), pLoc.longitude(),
                                dLoc.latitude(), dLoc.longitude());
                        eta = trackingCalculatorService.calculateEtaInMinutes(distance);
                    }

                    final double finalDistance = distance;
                    final int finalEta = eta;

                    return Mono.justOrEmpty(driver.vehicleId())
                            .flatMap(vehicleRepositoryPort::getVehicleById)
                            .defaultIfEmpty(Vehicle.builder().brand("N/A").build())
                            .map(v -> Bid.builder()
                                    .driverId(dId)
                                    .driverName(user.firstName() + " " + user.lastName())
                                    .driverPhone(user.telephone())
                                    .driverPhoto(user.photoUri())
                                    .latitude(dLoc.latitude())
                                    .longitude(dLoc.longitude())
                                    .distanceToPassenger(finalDistance)
                                    .eta(finalEta)
                                    .brand(v.brand())
                                    .model(v.vehicleModelId())
                                    .licensePlate(v.registrationNumber())
                                    .build());
                });
    }
    // ==================================================================================
    // CRUD ET GESTION
    // ==================================================================================

    @Override
    public Flux<Offer> getAllOffers() {
        return repository.findAll()
                .flatMap(this::enrichOffer); // ‚úÖ Enrichit toute la liste
    }

    @Override
    public Mono<Offer> getOfferById(UUID id) {
        return repository.findById(id)
                .switchIfEmpty(Mono.error(new OfferNotFoundException("Offer not found: " + id)))
                .flatMap(this::enrichOffer); // ‚úÖ Enrichit l'offre unique
    }

    @Override
    public Mono<Offer> updateOffer(UUID id, Offer offerDetails) {
        return repository.findById(id)
                .switchIfEmpty(Mono.error(new OfferNotFoundException("Offer not found: " + id)))
                .flatMap(existing -> {
                    Offer updated = new Offer(
                            existing.id(),
                            existing.passengerId(),
                            existing.selectedDriverId(),
                            offerDetails.startPoint() != null ? offerDetails.startPoint() : existing.startPoint(),
                            offerDetails.startLat() != null ? offerDetails.startLat() : existing.startLat(),
                            offerDetails.startLon() != null ? offerDetails.startLon() : existing.startLon(),
                            offerDetails.endPoint() != null ? offerDetails.endPoint() : existing.endPoint(),
                            // ‚úÖ Gestion des nouvelles coordonn√©es d'arriv√©e
                            offerDetails.endLat() != null ? offerDetails.endLat() : existing.endLat(),
                            offerDetails.endLon() != null ? offerDetails.endLon() : existing.endLon(),
                            offerDetails.price() > 0 ? offerDetails.price() : existing.price(),
                            offerDetails.passengerPhone() != null ? offerDetails.passengerPhone()
                                    : existing.passengerPhone(),
                            offerDetails.departureTime() != null ? offerDetails.departureTime()
                                    : existing.departureTime(),
                            existing.state(),
                            existing.bids(),
                            existing.version(),
                            existing.createdAt());
                    return repository.save(updated);
                })
                .flatMap(saved -> cache.saveInCache(saved).thenReturn(saved));
    }

    @Override
    public Mono<Boolean> deleteOffer(UUID id) {
        return repository.findById(id)
                .flatMap(offer -> repository.delete(offer).thenReturn(true))
                .defaultIfEmpty(false);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/ReviewService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.model.Review;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.ReviewRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.ReviewResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class ReviewService {
    private final ReviewRepositoryPort reviewRepository;
    private final RideRepositoryPort rideRepository;
    private final DriverRepositoryPort driverRepository;
    private final UserRepositoryPort userRepository;

    @Transactional
    public Mono<Review> submitReview(UUID rideId, UUID passengerId, int stars, String comment) {
        log.info("‚≠ê Process start: Submitting {} stars for ride {}", stars, rideId);

        return rideRepository.findRideById(rideId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Course introuvable")))
                .flatMap(ride -> {
                    // Validations m√©tier
                    if (ride.state() != RideState.COMPLETED) {
                        return Mono.error(new IllegalStateException("Seule une course COMPLETED peut √™tre not√©e."));
                    }
                    if (!ride.passengerId().equals(passengerId)) {
                        return Mono.error(new IllegalStateException("Acc√®s refus√©: vous n'√™tes pas le passager de cette course."));
                    }

                    Review review = Review.builder()
                            .id(Utils.generateUUID())
                            .rideId(rideId)
                            .driverId(ride.driverId())
                            .passengerId(passengerId)
                            .rating(stars)
                            .comment(comment)
                            .build();

                    // 1. Sauvegarde l'avis 
                    // 2. D√©clenche le recalcul imm√©diat
                    // 3. Retourne l'avis sauvegard√©
                    return reviewRepository.save(review)
                            .doOnSuccess(saved -> log.info("‚úÖ Review saved. Triggering driver stats update..."))
                            .flatMap(savedReview -> updateDriverStats(ride.driverId())
                                    .thenReturn(savedReview));
                });
    }

    private Mono<Void> updateDriverStats(UUID driverId) {
        return Mono.zip(
                reviewRepository.getAverageRatingForDriver(driverId),
                reviewRepository.countReviewsForDriver(driverId)
        ).flatMap(tuple -> {
            Double avg = tuple.getT1();
            Long count = tuple.getT2();
            
            log.info("üìä New Stats for driver {}: Avg={}, Count={}", driverId, avg, count);

            return driverRepository.findById(driverId)
                    .flatMap(driver -> {
                        var updatedDriver = driver.toBuilder()
                                .rating(avg != null ? avg : 0.0)
                                .totalReviewsCount(count != null ? count.intValue() : 0)
                                .build();
                        return driverRepository.save(updatedDriver);
                    });
        }).then();
    }

    public Flux<ReviewResponse> getReviewsForDriver(UUID driverId) {
        return reviewRepository.findAllByDriverId(driverId)
                .flatMap(review -> userRepository.findUserById(review.passengerId())
                        .map(user -> mapToResponse(review, user))
                        .defaultIfEmpty(mapToResponse(review, User.builder().firstName("Client").lastName("Anonyme").build()))
                );
    }

    private ReviewResponse mapToResponse(Review review, User passenger) {
        return ReviewResponse.builder()
                .reviewId(review.id())
                .rating(review.rating())
                .comment(review.comment())
                .createdAt(review.createdAt())
                .passengerName(passenger.firstName() + " " + passenger.lastName())
                .passengerPhoto(passenger.photoUri())
                .build();
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/RideService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.in.UpdateRideStatusUseCase;
import com.yowyob.rideandgo.domain.ports.out.DriverRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.OfferRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.VehicleRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.EnrichedRideResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class RideService implements UpdateRideStatusUseCase {
    private final RideRepositoryPort rideRepository;
    private final OfferRepositoryPort offerRepository;
    private final UserRepositoryPort userRepository;
    private final DriverRepositoryPort driverRepository;
    private final VehicleRepositoryPort vehicleRepository;

    @Override
    @Transactional
    public Mono<Ride> updateRideStatus(UUID rideId, RideState newStatus, UUID actorId) {
        log.info("üîÑ Transitioning Ride {} to state {}", rideId, newStatus);

        return rideRepository.findRideById(rideId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Course introuvable")))
                .flatMap(ride -> {
                    // 1. V√©rification des droits (Chauffeur ou Passager)
                    boolean isDriver = ride.driverId().equals(actorId);
                    boolean isPassenger = ride.passengerId().equals(actorId);

                    if (!isDriver && !isPassenger) {
                        return Mono.error(
                                new IllegalStateException("Acc√®s refus√© : vous ne faites pas partie de cette course."));
                    }

                    // 2. Seul le chauffeur peut passer √† ONGOING ou COMPLETED
                    if ((newStatus == RideState.ONGOING || newStatus == RideState.COMPLETED) && !isDriver) {
                        return Mono.error(
                                new IllegalStateException("Seul le chauffeur peut d√©marrer ou terminer la course."));
                    }

                    // 3. Validation de la transition d'√©tat
                    if (!isValidTransition(ride.state(), newStatus)) {
                        return Mono.error(new IllegalStateException(
                                "Transition impossible de " + ride.state() + " vers " + newStatus));
                    }

                    // 4. Application du changement
                    Ride updatedRide = Ride.builder()
                            .id(ride.id())
                            .offerId(ride.offerId())
                            .passengerId(ride.passengerId())
                            .driverId(ride.driverId())
                            .distance(ride.distance())
                            .duration(ride.duration())
                            .state(newStatus) // ‚úÖ NOUVEL √âTAT
                            .timeReal(ride.timeReal())
                            .build();

                    return rideRepository.save(updatedRide)
                            .doOnSuccess(r -> log.info("‚úÖ Ride {} is now {}", rideId, newStatus));
                });
    }

    public Flux<EnrichedRideResponse> getEnrichedHistory(UUID userId, int page, int size) {
        return rideRepository.findRideHistoryByUserId(userId, page, size)
                .flatMap(ride -> enrichRide(ride, userId));
    }

    private Mono<EnrichedRideResponse> enrichRide(Ride ride, UUID requesterId) {
        // 1. D√©terminer qui est le partenaire (l'autre personne)
        UUID partnerId = ride.driverId().equals(requesterId) ? ride.passengerId() : ride.driverId();

        // 2. Appel Partenaire (Robuste)
        Mono<User> partnerMono = userRepository.findUserById(partnerId)
                .onErrorResume(e -> Mono.empty())
                .defaultIfEmpty(User.builder().name("Inconnu").firstName("Utilisateur").lastName("Inconnu").build());

        // 3. Appel Offre (pour r√©cup√©rer points de d√©part/arriv√©e et prix)
        Mono<Offer> offerMono = offerRepository.findById(ride.offerId())
                .onErrorResume(e -> Mono.empty())
                .defaultIfEmpty(Offer.builder().startPoint("N/A").endPoint("N/A").price(0.0).build());

        // 4. Appel V√©hicule (Uniquement si le demandeur est le passager)
        Mono<Vehicle> vehicleMono = Mono.empty();
        if (requesterId.equals(ride.passengerId())) {
            vehicleMono = driverRepository.findById(ride.driverId())
                    .flatMap(d -> d.vehicleId() != null ? vehicleRepository.getVehicleById(d.vehicleId()) : Mono.empty())
                    .onErrorResume(e -> Mono.empty());
        }

        // 5. Agr√©gation avec ZIP (Toutes les branches sont s√©curis√©es)
        return Mono.zip(partnerMono, offerMono, vehicleMono.defaultIfEmpty(Vehicle.builder().brand("N/A").build()))
                .map(tuple -> {
                    User partner = tuple.getT1();
                    Offer offer = tuple.getT2();
                    Vehicle vehicle = tuple.getT3();

                    return EnrichedRideResponse.builder()
                            .rideId(ride.id())
                            .state(ride.state())
                            .distance(ride.distance())
                            .price(offer.price())
                            .startPoint(offer.startPoint())
                            .endPoint(offer.endPoint())
                            .partnerName(partner.firstName() + " " + partner.lastName())
                            .partnerPhone(partner.telephone())
                            .partnerPhoto(partner.photoUri())
                            .createdAt(ride.createdAt())
                            .vehicle(vehicle.id() != null ? vehicle : null)
                            .build();
                })
                .onErrorResume(e -> {
                    log.error("CRITICAL: Failed to enrich ride {}, skipping item", ride.id(), e);
                    return Mono.empty(); // En dernier recours, on ignore cette course plut√¥t que de tout faire planter
                });
    }

    public Mono<Ride> getCurrentRideForDriver(UUID driverId) {
        return rideRepository.findCurrentRideByDriverId(driverId);
    }

    public Mono<Ride> getRideByOfferId(UUID offerId) {
        return rideRepository.findRideByOfferId(offerId);
    }

    public Mono<Ride> getRideById(UUID rideId) {
        return rideRepository.findRideById(rideId);
    }

    public Flux<Ride> getHistoryForUser(UUID userId, int page, int size) {
        return rideRepository.findRideHistoryByUserId(userId, page, size);
    }

    public Flux<Ride> getHistoryForDriver(UUID driverId, int page, int size) {
        return rideRepository.findRideHistoryByDriverId(driverId, page, size);
    }

    private boolean isValidTransition(RideState current, RideState target) {
        if (current == target)
            return true;
        return switch (current) {
            case CREATED -> target == RideState.ONGOING || target == RideState.CANCELLED;
            case ONGOING -> target == RideState.COMPLETED || target == RideState.CANCELLED;
            case COMPLETED, CANCELLED -> false;
        };
    }
}


--- FILE: src/main/java/com/yowyob/rideandgo/application/service/TrackingCalculatorService.java ---
package com.yowyob.rideandgo.application.service;

import org.springframework.stereotype.Service;

@Service
public class TrackingCalculatorService {

    private static final int EARTH_RADIUS_KM = 6371;
    // Vitesse moyenne en ville estim√©e √† 30 km/h pour le MVP
    private static final double AVERAGE_SPEED_KMH = 30.0; 

    /**
     * Calcule la distance √† vol d'oiseau (Formule de Haversine).
     * @return Distance en kilom√®tres.
     */
    public double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        if ((lat1 == lat2) && (lon1 == lon2)) {
            return 0.0;
        }

        double latDistance = Math.toRadians(lat2 - lat1);
        double lonDistance = Math.toRadians(lon2 - lon1);
        
        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
        
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        double distance = EARTH_RADIUS_KM * c;
        
        // Arrondi √† 2 d√©cimales (ex: 1.54 km)
        return Math.round(distance * 100.0) / 100.0;
    }

    /**
     * Estime le temps d'arriv√©e (ETA) bas√© sur la distance et une vitesse moyenne.
     * @param distanceKm La distance en kilom√®tres.
     * @return Temps estim√© en minutes (arrondi √† l'entier sup√©rieur).
     */
    public int calculateEtaInMinutes(double distanceKm) {
        if (distanceKm <= 0) return 0;

        // Temps (heures) = Distance / Vitesse
        double timeInHours = distanceKm / AVERAGE_SPEED_KMH;
        
        // Conversion en minutes
        double timeInMinutes = timeInHours * 60;

        // On arrondit toujours √† la minute sup√©rieure pour ne pas √™tre en retard
        return (int) Math.ceil(timeInMinutes);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/TrajectoryCronService.java ---
package com.yowyob.rideandgo.application.service;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.model.DriverTrajectory;
import com.yowyob.rideandgo.domain.ports.out.DriverTrajectoryRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.core.ScanOptions;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class TrajectoryCronService {

    private final ReactiveRedisTemplate<String, Object> redisTemplate;
    private final DriverTrajectoryRepositoryPort trajectoryRepository;
    private final ObjectMapper objectMapper;

    private static final String PREFIX_HISTORY = "history:driver:";

    @Scheduled(fixedRateString = "${application.trajectory.dump-interval-ms:600000}")
    public void processTrajectories() {
        log.info("‚è∞ Starting Trajectory Dump (Interval: {}ms)...",
                System.getProperty("application.trajectory.dump-interval-ms", "600000"));

        redisTemplate.scan(ScanOptions.scanOptions().match(PREFIX_HISTORY + "*").build())
                .flatMap(this::processSingleDriverHistory)
                .subscribe(
                        null,
                        e -> log.error("‚ùå Error during trajectory dump", e),
                        () -> log.info("‚úÖ Trajectory Dump cycle finished."));
    }

    private Mono<Void> processSingleDriverHistory(String key) {
        UUID driverId = UUID.fromString(key.replace(PREFIX_HISTORY, ""));

        // 1. R√©cup√©rer tous les points (LRANGE 0 -1)
        return redisTemplate.opsForList().range(key, 0, -1)
                .cast(String.class)
                .collectList()
                .flatMap(points -> {
                    if (points.isEmpty())
                        return Mono.empty();

                    // 2. Supprimer la cl√© dans Redis imm√©diatement (Atout: On √©vite de traiter 2
                    // fois)
                    return redisTemplate.delete(key)
                            .then(saveToPostgres(driverId, points));
                });
    }

    private Mono<Void> saveToPostgres(UUID driverId, List<String> rawPoints) {
        try {
            List<Object[]> trajectoryArray = new ArrayList<>();
            long firstTs = Long.MAX_VALUE;
            long lastTs = Long.MIN_VALUE;

            for (String raw : rawPoints) {
                String[] parts = raw.split(",");
                double lat = Double.parseDouble(parts[0]);
                double lon = Double.parseDouble(parts[1]);
                long ts = Long.parseLong(parts[2]);

                // On pr√©pare le tableau pour le JSON [[lat, lon, ts], ...]
                trajectoryArray.add(new Object[] { lat, lon, ts });

                if (ts < firstTs)
                    firstTs = ts;
                if (ts > lastTs)
                    lastTs = ts;
            }

            // Conversion des timestamps en LocalDateTime
            LocalDateTime start = LocalDateTime.ofInstant(Instant.ofEpochSecond(firstTs), ZoneId.systemDefault());
            LocalDateTime end = LocalDateTime.ofInstant(Instant.ofEpochSecond(lastTs), ZoneId.systemDefault());

            // S√©rialisation du tableau en String JSON
            String json = objectMapper.writeValueAsString(trajectoryArray);

            DriverTrajectory trajectory = DriverTrajectory.builder()
                    .id(Utils.generateUUID())
                    .driverId(driverId)
                    .startTime(start)
                    .endTime(end)
                    .pointsCount(rawPoints.size())
                    .trajectoryDataJson(json)
                    .build();

            return trajectoryRepository.save(trajectory)
                    .doOnSuccess(v -> log.debug("üíæ Saved trajectory for driver {} ({} points)", driverId,
                            rawPoints.size()));

        } catch (Exception e) {
            log.error("‚ùå Error parsing trajectory for driver {}", driverId, e);
            return Mono.empty();
        }
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/TrajectoryService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.DriverTrajectory;
import com.yowyob.rideandgo.domain.ports.out.DriverTrajectoryRepositoryPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class TrajectoryService {
    private final DriverTrajectoryRepositoryPort repositoryPort;

    public Flux<DriverTrajectory> getMyTrajectories(UUID driverId) {
        return repositoryPort.findAllByDriverId(driverId);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/UserService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.exception.WalletNotFoundException;
import com.yowyob.rideandgo.domain.model.Driver;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.UserUseCases;
import com.yowyob.rideandgo.domain.ports.out.*;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.BecomeDriverRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.DriverProfileResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FullDriverProfileResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UserResponse;
import com.yowyob.rideandgo.infrastructure.mappers.UserMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import lombok.extern.slf4j.Slf4j;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
public class UserService implements UserUseCases {
    private final UserRepositoryPort userRepositoryPort;
    private final ExternalUserPort externalUserPort;
    private final DriverRepositoryPort driverRepositoryPort;
    private final VehicleRepositoryPort vehicleRepositoryPort;
    private final SyndicatePort syndicatePort;
    private final PaymentPort paymentPort;
    private final UserMapper userMapper;

    @Override
    public Mono<User> saveUser(User user) {
        return userRepositoryPort.save(user);
    }

    @Override
    public Mono<Boolean> deleteUserById(UUID userId) {
        return userRepositoryPort.deleteById(userId);
    }

    @Override
    public Flux<User> getUsersByRole(RoleType role) {
        return userRepositoryPort.findByRoleName(role);
    }

    @Override
    public Mono<User> getUserById(UUID userId) {
        return externalUserPort.fetchRemoteUserById(userId).flatMap(userRepositoryPort::save);
    }

    @Override
    public Flux<User> getAllUsers() {
        return externalUserPort.fetchAllRemoteUsers().flatMap(userRepositoryPort::save);
    }

    @Override
    public Mono<User> updateProfile(UUID userId, String firstName, String lastName, String phone) {
        return externalUserPort.updateProfile(userId, firstName, lastName, phone)
                .flatMap(updated -> userRepositoryPort.findUserById(userId)
                        .map(local -> new User(local.id(), local.name(), local.firstName(), local.lastName(), local.email(), phone, local.password(),
                                local.photoUri(), local.roles(), local.directPermissions()))
                        .flatMap(userRepositoryPort::save));
    }

    @Override
    public Mono<Void> changePassword(UUID userId, String currentPassword, String newPassword) {
        return externalUserPort.changePassword(userId, currentPassword, newPassword);
    }

    @Override
    public Flux<User> getAllRemoteUsersByService(String serviceName) {
        return externalUserPort.fetchAllRemoteUsersByService(serviceName).flatMap(userRepositoryPort::save);
    }

    @Override
    public Mono<Void> upgradeToDriver(UUID userId) {
        return driverRepositoryPort.createDriver(userId)
                .flatMap(d -> externalUserPort.addRole(userId, RoleType.RIDE_AND_GO_DRIVER.name()))
                .flatMap(v -> userRepositoryPort.addRoleToUser(userId, RoleType.RIDE_AND_GO_DRIVER))
                .flatMap(v -> paymentPort.createWallet(userId, "Driver_" + userId.toString().substring(0, 5)))
                .then();
    }

    @Override
    public Mono<FullDriverProfileResponse> getFullDriverProfile(UUID userId) {
        log.info("üéØ Fetching Full Aggregated Profile for Driver {}", userId);

        Mono<UserResponse> userMono = getUserById(userId)
                .map(u -> {
                    UserResponse res = userMapper.toResponse(u);
                    if (u.roles() != null) {
                        res.setRoles(u.roles().stream().map(r -> r.type()).collect(Collectors.toList()));
                    }
                    return res;
                });

        Mono<DriverVehicleContainer> driverVehicleMono = driverRepositoryPort.findById(userId)
                .flatMap(driver -> {
                    if (driver.vehicleId() != null) {
                        return vehicleRepositoryPort.getVehicleById(driver.vehicleId())
                                .map(v -> new DriverVehicleContainer(driver, v))
                                .onErrorReturn(new DriverVehicleContainer(driver, null));
                    }
                    return Mono.just(new DriverVehicleContainer(driver, null));
                })
                .defaultIfEmpty(new DriverVehicleContainer(null, null));

        Mono<com.yowyob.rideandgo.domain.model.Wallet> walletMono = paymentPort.getWalletByOwnerId(userId)
                .onErrorResume(e -> {
                    log.warn("Wallet not found for driver profile {}", userId);
                    return Mono.empty();
                });

        return Mono
                .zip(userMono, driverVehicleMono,
                        walletMono.defaultIfEmpty(com.yowyob.rideandgo.domain.model.Wallet.builder().build()))
                .map(tuple -> FullDriverProfileResponse.builder()
                        .user(tuple.getT1())
                        .driver(tuple.getT2().driver)
                        .vehicle(tuple.getT2().vehicle)
                        .wallet(tuple.getT3().id() != null ? tuple.getT3() : null)
                        .build());
    }

    private record DriverVehicleContainer(Driver driver, Vehicle vehicle) {
    }

    @Override
    public Mono<DriverProfileResponse> upgradeToDriverComplete(UUID userId, BecomeDriverRequest request,
            FilePart regPhoto, FilePart serialPhoto) {
        log.info("üöÄ Starting Driver Onboarding for User {} (Full Flow)", userId);

        return userRepositoryPort.findUserById(userId)
                .flatMap(user -> {
                    boolean alreadyHasRole = user.roles() != null && user.roles().stream()
                            .anyMatch(r -> r.type() == RoleType.RIDE_AND_GO_DRIVER);

                    var vInfo = request.vehicle();
                    Vehicle vehicleDomain = Vehicle.builder()
                            .vehicleMakeId(vInfo.makeName())
                            .vehicleModelId(vInfo.modelName())
                            .transmissionTypeId(vInfo.transmissionType())
                            .manufacturerId(vInfo.manufacturerName())
                            .vehicleSizeId(vInfo.sizeName())
                            .vehicleTypeId(vInfo.typeName())
                            .fuelTypeId(vInfo.fuelTypeName())
                            .vehicleSerialNumber(vInfo.vehicleSerialNumber())
                            .registrationNumber(vInfo.registrationNumber())
                            .tankCapacity(vInfo.tankCapacity())
                            .luggageMaxCapacity(vInfo.luggageMaxCapacity())
                            .totalSeatNumber(vInfo.totalSeatNumber())
                            .averageFuelConsumptionPerKm(vInfo.averageFuelConsumptionPerKm())
                            .mileageAtStart(vInfo.mileageAtStart())
                            .mileageSinceCommissioning((int) vInfo.mileageSinceCommissioning())
                            .vehicleAgeAtStart((int) vInfo.vehicleAgeAtStart())
                            .brand(vInfo.makeName())
                            .build();

                    return vehicleRepositoryPort.createVehicle(vehicleDomain)
                            .flatMap(createdVehicle -> {
                                Mono<Vehicle> chain = Mono.just(createdVehicle);
                                if (regPhoto != null)
                                    chain = chain.flatMap(
                                            v -> vehicleRepositoryPort.uploadRegistrationDocument(v.id(), regPhoto));
                                if (serialPhoto != null)
                                    chain = chain.flatMap(
                                            v -> vehicleRepositoryPort.uploadSerialDocument(v.id(), serialPhoto));
                                return chain;
                            })
                            .flatMap(finalVehicle -> {
                                Driver newDriver = Driver.builder()
                                        .id(userId)
                                        .status("OFFLINE")
                                        .licenseNumber(request.licenseNumber())
                                        .hasCar(true)
                                        .isOnline(false)
                                        .isProfileCompleted(false)
                                        .isProfileValidated(true)
                                        .isSyndicated(false)
                                        .vehicleId(finalVehicle.id())
                                        .build();

                                return driverRepositoryPort.save(newDriver)
                                        .flatMap(savedDriver ->
                                // ‚úÖ V√âRIFICATION WALLET EXISTANT
                                paymentPort.getWalletByOwnerId(userId)
                                        .doOnSuccess(w -> log.info(
                                                "üí≥ Wallet already exists for driver {}, skipping creation.", userId))
                                        .onErrorResume(WalletNotFoundException.class, e -> {
                                            log.info("üí≥ Wallet not found for {}, creating new one...", userId);
                                            return paymentPort.createWallet(userId, user.name());
                                        })
                                        .thenReturn(savedDriver))
                                        .map(savedDriver -> new DriverProfileResponse(
                                                savedDriver.id(),
                                                user.firstName(),           // ‚úÖ Ajout√©
                                                user.lastName(),            // ‚úÖ Ajout√©
                                                savedDriver.status(),
                                                savedDriver.licenseNumber(),
                                                savedDriver.isOnline(),
                                                savedDriver.isProfileValidated(),
                                                savedDriver.isSyndicated(),
                                                savedDriver.isProfileCompleted(),
                                                savedDriver.rating(),       // ‚úÖ Ajout√©
                                                savedDriver.totalReviewsCount(), // ‚úÖ Ajout√©
                                                finalVehicle));
                            })
                            .flatMap(response -> {
                                if (!alreadyHasRole) {
                                    return externalUserPort.addRole(userId, RoleType.RIDE_AND_GO_DRIVER.name())
                                            .then(userRepositoryPort.addRoleToUser(userId, RoleType.RIDE_AND_GO_DRIVER))
                                            .thenReturn(response);
                                } else {
                                    return Mono.just(response);
                                }
                            });
                });
    }

    @Override
    @Transactional
    public Mono<DriverProfileResponse> verifySyndicateStatus(UUID userId) {
        log.info("üõ† Verifying Syndicate status for Driver {}", userId);

        return syndicatePort.checkIsSyndicated(userId)
                .flatMap(isVerified -> 
                    // 1. On r√©cup√®re le chauffeur et l'utilisateur en parall√®le
                    Mono.zip(
                        driverRepositoryPort.findById(userId)
                            .switchIfEmpty(Mono.error(new IllegalArgumentException("Chauffeur non trouv√©"))),
                        userRepositoryPort.findUserById(userId)
                            .switchIfEmpty(Mono.error(new IllegalArgumentException("Utilisateur non trouv√©")))
                    ).flatMap(tuple -> {
                        Driver driver = tuple.getT1();
                        User user = tuple.getT2();

                        // 2. On pr√©pare la mise √† jour du chauffeur
                        Driver updatedDriver = driver.toBuilder()
                                .isSyndicated(isVerified)
                                .isProfileCompleted(isVerified) // Un chauffeur est complet s'il est syndiqu√© (r√®gle m√©tier)
                                .build();

                        // 3. On sauvegarde et on enrichit avec le v√©hicule
                        return driverRepositoryPort.save(updatedDriver)
                                .flatMap(savedDriver -> {
                                    Mono<Vehicle> vehicleMono = Mono.justOrEmpty(savedDriver.vehicleId())
                                            .flatMap(vehicleRepositoryPort::getVehicleById)
                                            .defaultIfEmpty(Vehicle.builder().brand("Inconnu").build());

                                    return vehicleMono.map(v -> new DriverProfileResponse(
                                            savedDriver.id(),
                                            user.firstName(),           // ‚úÖ Ajout√©
                                            user.lastName(),            // ‚úÖ Ajout√©
                                            savedDriver.status(),
                                            savedDriver.licenseNumber(),
                                            savedDriver.isOnline(),
                                            savedDriver.isProfileValidated(),
                                            savedDriver.isSyndicated(),
                                            savedDriver.isProfileCompleted(),
                                            savedDriver.rating(),       // ‚úÖ Ajout√©
                                            savedDriver.totalReviewsCount(), // ‚úÖ Ajout√©
                                            v
                                    ));
                                });
                    })
                );
    }

    @Override
    public Mono<DriverProfileResponse> getDriverProfile(UUID driverId) {
        log.info("üîç Fetching public profile for driver {}", driverId);

        return Mono.zip(
                driverRepositoryPort.findById(driverId)
                        .switchIfEmpty(Mono.error(new IllegalArgumentException("Chauffeur non trouv√©"))),
                userRepositoryPort.findUserById(driverId)
                        .switchIfEmpty(Mono.error(new IllegalArgumentException("Utilisateur non trouv√©")))
        ).flatMap(tuple -> {
            Driver driver = tuple.getT1();
            User user = tuple.getT2();
            
            log.info("here is the driver : {} \n and user: {}", user, driver);
            return Mono.justOrEmpty(driver.vehicleId())
                    .flatMap(vehicleRepositoryPort::getVehicleById)
                    .map(v -> mapToProfileResponse(user, driver, v))
                    .defaultIfEmpty(mapToProfileResponse(user, driver, null));
        });
    }

    private DriverProfileResponse mapToProfileResponse(User user, Driver driver, Vehicle vehicle) {
        return new DriverProfileResponse(
                user.id(),
                user.firstName(),           // ‚úÖ Ajout√©
                user.lastName(),            // ‚úÖ Ajout√©
                driver.status(),
                driver.licenseNumber(),
                driver.isOnline(),
                driver.isProfileValidated(),
                driver.isSyndicated(),
                driver.isProfileCompleted(),
                driver.rating(),            // ‚úÖ Ajout√©
                driver.totalReviewsCount(), // ‚úÖ Ajout√©
                vehicle
        );
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/service/VehicleService.java ---
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.Vehicle;
import com.yowyob.rideandgo.domain.ports.out.VehicleRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.codec.multipart.FilePart;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class VehicleService {
    private final VehicleRepositoryPort repository;

    /**
     * Flux complet de cr√©ation :
     * 1. Cr√©e le v√©hicule (donn√©es JSON)
     * 2. Upload la photo d'immatriculation (si pr√©sente)
     * 3. Upload la photo du num√©ro de s√©rie (si pr√©sente)
     */
    public Mono<Vehicle> createVehicleWithDocuments(Vehicle vehicleData, FilePart regPhoto, FilePart serialPhoto) {
        return repository.createVehicle(vehicleData)
                .flatMap(created -> {
                    Mono<Vehicle> chain = Mono.just(created);

                    if (regPhoto != null) {
                        chain = chain.flatMap(v -> repository.uploadRegistrationDocument(v.id(), regPhoto)
                                .doOnSuccess(x -> log.info("‚úÖ Registration photo uploaded for {}", v.id())));
                    }

                    if (serialPhoto != null) {
                        chain = chain.flatMap(v -> repository.uploadSerialDocument(v.id(), serialPhoto)
                                .doOnSuccess(x -> log.info("‚úÖ Serial photo uploaded for {}", v.id())));
                    }

                    return chain;
                });
    }

    public Mono<Vehicle> getVehicleById(UUID id) {
        return repository.getVehicleById(id);
    }

    public Mono<Vehicle> patchVehicle(UUID id, Vehicle partial) {
        return repository.patchVehicle(id, partial);
    }

    public Mono<String> addImage(UUID id, FilePart image) {
        return repository.uploadVehicleImage(id, image);
    }

    public Flux<String> getImages(UUID id) {
        return repository.getVehicleImages(id);
    }
}

--- FILE: src/main/java/com/yowyob/rideandgo/application/utils/Constants.java ---
package com.yowyob.rideandgo.application.utils;

public class Constants {
    public static final String NOTIFICATION_SERVICE_TOKEN_HEADER = "X-Service-Token";
}


--- FILE: src/main/java/com/yowyob/rideandgo/application/utils/Utils.java ---
package com.yowyob.rideandgo.application.utils;

import java.util.UUID;

public class Utils {
    public static UUID generateUUID(){
        return UUID.randomUUID();
    }

    public static int generateRandomNumber(){
        return (int) (Math.random()*100);
    }

    public static int generateRandomNumber(int max){
        return (int) (Math.random()*max);
    }
}

--- FILE: src/main/resources/application.yml ---
server:
  port: 8080
  forward-headers-strategy: framework

spring:
  application:
    name: ride-and-go
  profiles:
    active: local
  docker:
    compose:
      enabled: false

  # POSTGRESQL (R2DBC)
  r2dbc:
    url: r2dbc:postgresql://${DB_HOST:127.0.0.1}:${DB_PORT:5432}/${DB_NAME:yowyob_db}?schema=ride_and_go
    username: ${DB_USERNAME:fleet_admin}
    password: ${DB_PASSWORD:fleet_password}
    pool:
      enabled: true
      initial-size: 1
      max-size: 5
      max-idle-time: 30m
      max-life-time: 10m
      acquire-retry: 3
      max-acquire-time: 30s
      validation-query: SELECT 1

  datasource:
    url: jdbc:postgresql://${DB_HOST:127.0.0.1}:${DB_PORT:5432}/${DB_NAME:yowyob_db}?currentSchema=ride_and_go
    username: ${DB_USERNAME:fleet_admin}
    password: ${DB_PASSWORD:fleet_password}
    driver-class-name: org.postgresql.Driver

# Liquibase
  liquibase:
    enabled: true
    user: fleet_admin
    password: fleet_password
    change-log: classpath:db/changelog/db.changelog-master.yaml
    default-schema: ride_and_go # Force Liquibase √† travailler dans ce sch√©ma
    liquibase-schema: ride_and_go # Stocke les tables de gestion Liquibase ici aussi
    url: jdbc:postgresql://${DB_HOST:127.0.0.1}:${DB_PORT:5432}/${DB_NAME:yowyob_db}

  sql:
    init:
      mode: never 

  # REDIS CLUSTER 
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:password}
      cluster:
        enabled: false

  # KAFKA 
  kafka:
    bootstrap-servers: ${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}
    consumer:
      group-id: ride-and-go-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# CUSTOM CONFIG 
application:

  offer:
    search-radius-km: 5.0  # Rayon par d√©faut pour le matching

  trajectory:
    dump-interval-ms: 600000

  auth:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur r√©el
    url: https://auth-service.pynfi.com

  fare:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur r√©el
    url: https://fare-calculator-service.pynfi.com
    api-key: 974e9428-6ce2-48e7-b74b-93f572007ef8
    
  notification:
    mode: http # 'http' ou 'kafka'
    url: https://notification-service.pynfi.com # URL du Swagger fourni
    service-token: "a77599d3-8de7-4d52-b9d0-2202b2e13a9e" # Token r√©cup√©r√© apr√®s enregistrement du service
    templates:
      new-offer: 12        # ID template: Nouvelle offre pour les chauffeurs
      driver-applied: 13   # ID template: Un chauffeur a postul√© (pour le client)
      driver-selected: 14  # ID template: Vous avez √©t√© choisi (pour le chauffeur)
      ride-confirmed: 15   # ID template: Le chauffeur arrive (pour le client)
      ride-cancelled: 16   # ID template: Course annul√©e
      admin-validation: 17 # ID template: admin a valid√© le profil du driver

  vehicle:
    url: https://vehicule-service.pynfi.com

  syndicate:
    url: https://ugate.pynfi.com

  payment:
    url: https://payment-service.pynfi.com
    commission-rate: 0.10

  kafka:
    topics:
      notification-service-create-topic: notification-create-topic
      offer-created: offer-created-topic
      offer-send: notification-send-topic

management:
  endpoints:
    web:
      exposure:
        include: ["health","info","prometheus"]
  endpoint:
    health:
      show-details: "always"
      probes:
        enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

# ======================================================
# 2. CONFIGURATION TIMEOUT (Resilience4j)
# ======================================================
resilience4j:
  circuitbreaker:
    instances:

      # Config pour le service de prix
      fare-calculator-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        slidingWindowSize: 10
        permittedNumberOfCallsInHalfOpenState: 3

      # Config pour le service auth (si besoin)
      auth-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5

      notification-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        slidingWindowSize: 10

  timelimiter:
    instances:
      fare-calculator-service:
        timeoutDuration: 20s  
      auth-service:
        timeoutDuration: 20s

--- FILE: src/main/resources/prod.application.yml ---
# ===================================================================
# PRODUCTION CONFIGURATION - RIDE & GO API
# ===================================================================

server:
  port: 8080
  forward-headers-strategy: framework
  error:
    include-message: always # Useful for frontend debugging

spring:
  application:
    name: ride-and-go

  datasource:
    url: jdbc:postgresql://${DB_HOST:168.119.122.86}:${DB_PORT:5432}/${DB_NAME:yowyob}?currentSchema=ride_and_go
    username: ${DB_USERNAME:master}
    password: ${DB_PASSWORD:Azerty1234*}
    driver-class-name: org.postgresql.Driver

  liquibase:
    user: ${DB_USERNAME:master}
    password: ${DB_PASSWORD:Azerty1234*}
    enabled: true
    change-log: classpath:db/changelog/db.changelog-master.yaml
    default-schema: ride_and_go
    liquibase-schema: ride_and_go
    url: jdbc:postgresql://${DB_HOST:168.119.122.86}:${DB_PORT:5432}/${DB_NAME:yowyob}


  # DATABASE CONFIGURATION (REACTIVE R2DBC)
  r2dbc:
    url: r2dbc:postgresql://${DB_HOST:168.119.122.86}:${DB_PORT:5432}/${DB_NAME:yowyob}?schema=ride_and_go
    username: ${DB_USERNAME:master}
    password: ${DB_PASSWORD:Azerty1234*}
    pool:
      enabled: true
      initial-size: 5
      max-size: 20
      max-idle-time: 30m
      validation-query: SELECT 1

  # CRITICAL SECURITY: Never run local scripts on production server
  sql:
    init:
      mode: never

  # REDIS CACHE (CLUSTER MODE)
  data:
    redis:
      password: ${REDIS_PASSWORD:Azerty1234*}
      cluster:
        nodes:
          - ${REDIS_HOST:168.119.122.86}:7001
          - ${REDIS_HOST:168.119.122.86}:7002
          - ${REDIS_HOST:168.119.122.86}:7003

  # MESSAGING SYSTEM (KAFKA)
  kafka:
    bootstrap-servers: ${KAFKA_HOST:168.119.122.86}:${KAFKA_PORT:9092}
    consumer:
      group-id: ride-and-go-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# CUSTOM BUSINESS SERVICES CONFIGURATION
application:

  auth:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur r√©el
    url: https://auth-service.pynfi.com

  fare:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur r√©el
    url: https://fare-calculator-service.pynfi.com
    api-key: 974e9428-6ce2-48e7-b74b-93f572007ef8

  notification:
    mode: http
    url: https://notification-service.pynfi.com
    service-token: ${NOTIFICATION_SERVICE_TOKEN}
    templates:
      new-offer: 12        # ID template: Nouvelle offre pour les chauffeurs
      driver-applied: 13   # ID template: Un chauffeur a postul√© (pour le client)
      driver-selected: 14  # ID template: Vous avez √©t√© choisi (pour le chauffeur)
      ride-confirmed: 15   # ID template: Le chauffeur arrive (pour le client)
      ride-cancelled: 16   # ID template: Course annul√©e
      admin-validation: 17 # ID template: admin a valid√© le profil du driver

  vehicle:
    url: https://vehicule-service.pynfi.com

  syndicate:
    url: https://ugate.pynfi.com

  payment:
    url: https://payment-service.pynfi.com
    commission-rate: 0.10

  kafka:
    topics:
      notification-service-create-topic: notification-create-topic
      offer-created: offer-created-topic
      offer-send: notification-send-topic
    notification-registration:
      name: "Ride and Go"
      email:
        host: ${SMTP_HOST:smtp.gmail.com}
        port: ${SMTP_PORT:587}
        username: ${SMTP_USERNAME}
        password: ${SMTP_PASSWORD}
    notification-service:
      token: token-topic
      template:
        new-offer-id: 1001
        accepted-offer-id: 1002

# MONITORING & HEALTH CHECK (ACTUATOR)
management:
  endpoints:
    web:
      exposure:
        include: ["health", "info", "prometheus"]
  endpoint:
    health:
      show-details: "always"
      probes:
        enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

# ======================================================
# 2. CONFIGURATION TIMEOUT (Resilience4j)
# ======================================================
resilience4j:
  circuitbreaker:
    instances:
      # Config pour le service de prix
      fare-calculator-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 100s
        slidingWindowSize: 10
        permittedNumberOfCallsInHalfOpenState: 10

      # Config pour le service auth (si besoin)
      auth-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5

  # C'est ici qu'on r√®gle le probl√®me "Did not observe any item... within 1000ms"
  timelimiter:
    instances:
      fare-calculator-service:
        timeoutDuration: 100s  
      auth-service:
        timeoutDuration: 20s


--- FILE: src/main/resources/local/data.sql ---
-- =====================================================
-- YOWYOB DB - DATA SEEDING SCRIPT
-- PostgreSQL
-- =====================================================

-- =====================================================
-- 1. CLEANUP EXISTING DATA
-- =====================================================
TRUNCATE TABLE 
    users, images, countries, business_actors, 
    admins, fleet_managers, drivers, customers, 
    providers, employees, prospects, sales_persons,
    profiles, settings, addresses, contacts,
    roles, permissions, role_has_permissions, user_has_permissions, user_has_roles,
    organizations, agencies, business_domains, organization_business_domains,
    certifications, third_parties, proposed_activities, services, branches,
    fleets, vehicles, geofence_zones, geofence_points, geofence_events,
    roads, trips, offers, rides, reviews, offer_driver_linkages,
    operational_parameters, financial_parameters, maintenance_parameters,
    geofence_point_zone_linkages,
    syndicats, abstract_products, products, 
    publications, publication_images, publication_votes, votes,
    events, event_images, reactions, comments, avis,
    subscriptions, payments
    RESTART IDENTITY CASCADE;

-- =====================================================
-- 2. STATIC REFERENCE DATA
-- =====================================================

-- Countries
INSERT INTO countries (name, code) VALUES
('Cameroun', 'CM'), ('S√©n√©gal', 'SN'), ('C√¥te d''Ivoire', 'CI'), 
('Gabon', 'GA'), ('Nig√©ria', 'NG'), ('Togo', 'TG');

-- Roles
INSERT INTO roles (name, guard_name) VALUES
('ADMIN', 'web'), ('FLEET_MANAGER', 'web'), ('DRIVER', 'web'), ('CUSTOMER', 'web');

-- Images
INSERT INTO images (url, alt_text) 
SELECT 
    'https://picsum.photos/seed/' || i || '/800/600', 
    'Image al√©atoire ' || i
FROM generate_series(1, 50) as i;

-- =====================================================
-- 3. USERS GENERATION
-- =====================================================

-- 3.1 GOLDEN USERS (Pour les tests Swagger avec Tokens fixes)
-- Client (7f13909e...)
INSERT INTO users (id, name, phone_number, email_address) VALUES 
('7f13909e-7170-4f91-872e-333333333333', 'Test Client', '+237600000001', 'client@test.com');

-- Driver 1 (a1b2c3d4...1111)
INSERT INTO users (id, name, phone_number, email_address) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'Eto''o Fils', '+237600000002', 'etoo@test.com');

-- Driver 2 (a1b2c3d4...2222)
INSERT INTO users (id, name, phone_number, email_address) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', 'Aboubakar V', '+237600000003', 'aboubakar@test.com');


-- 3.2 RANDOM USERS (97 autres pour faire masse)
INSERT INTO users (name, phone_number, email_address)
SELECT 
    (ARRAY['Mamadou', 'Jean-Pierre', 'Ibrahim', 'Fatou', 'Aminata', 'Ngolo', 'Clarisse', 'Samuel', 'Kouam√©', 'Aissatou', 'Bachelard', 'Landry', 'Th√©r√®se'])[floor(random()*13)+1] 
    || ' ' || 
    (ARRAY['Diop', 'Njoya', 'Mbarga', 'Kone', 'Sow', 'Etoundi', 'Kamga', 'Traor√©', 'Diallo', 'Fofana', 'Mensah', 'Atangana', 'Drogba'])[floor(random()*13)+1],
    (ARRAY['+237', '+221', '+225'])[floor(random()*3)+1] || (600000000 + floor(random()*99999999)::int),
    'user_' || i || '@yowyob.test'
FROM generate_series(1, 97) as i;

-- Settings & Profiles
INSERT INTO settings (user_id, theme, language, receive_push_notifications)
SELECT id, 'LIGHT', 'fr', true FROM users;

INSERT INTO profiles (user_id, first_name, nationality, is_verified)
SELECT id, split_part(name, ' ', 1), 'Camerounais', (random() > 0.5) FROM users;

-- =====================================================
-- 4. ACTORS DISPATCHING
-- =====================================================

-- 4.1 Golden Users Dispatching
-- Client -> Customer
INSERT INTO customers (id, code, payment_method) VALUES 
('7f13909e-7170-4f91-872e-333333333333', 'CUST-TEST', 'CASH');

-- Drivers -> BusinessActor + Driver
INSERT INTO business_actors (id, name, phone_number, email_address) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'Eto''o Fils', '+237600000002', 'etoo@test.com'),
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', 'Aboubakar V', '+237600000003', 'aboubakar@test.com');

INSERT INTO drivers (id, status, license_number, has_car) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'AVAILABLE', 'LIC-ETOO-09', true),
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', 'AVAILABLE', 'LIC-ABOU-10', true);

-- Assign Roles for Golden Users
INSERT INTO user_has_roles (user_id, role_id) VALUES 
('7f13909e-7170-4f91-872e-333333333333', (SELECT id FROM roles WHERE name = 'CUSTOMER')),
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', (SELECT id FROM roles WHERE name = 'DRIVER')),
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', (SELECT id FROM roles WHERE name = 'DRIVER'));


-- 4.2 Random Users Dispatching
-- Admins (Next 5)
INSERT INTO admins (id, name, email_address)
SELECT id, name, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 5;

-- Fleet Managers (Next 5)
INSERT INTO business_actors (id, name, phone_number, email_address)
SELECT id, name, phone_number, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 5 OFFSET 5;

INSERT INTO fleet_managers (id, name, email_address)
SELECT id, name, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 5 OFFSET 5;

-- Drivers (Next 30)
INSERT INTO business_actors (id, name, phone_number, email_address)
SELECT id, name, phone_number, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 30 OFFSET 10;

INSERT INTO drivers (id, status, license_number, has_car)
SELECT 
    id, 
    (ARRAY['AVAILABLE', 'BUSY', 'OFFLINE'])[floor(random()*3)+1], 
    'LIC-' || floor(random()*100000) || '-CM',
    (random() > 0.3)
FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 30 OFFSET 10;

-- Customers (Remaining)
INSERT INTO customers (id, code, payment_method)
SELECT 
    id, 
    'CUST-' || substr(id::text, 1, 8),
    (ARRAY['CASH', 'MOBILE_MONEY', 'CARD'])[floor(random()*3)+1]
FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
AND id NOT IN (SELECT id FROM admins)
AND id NOT IN (SELECT id FROM fleet_managers)
AND id NOT IN (SELECT id FROM drivers);

-- Roles assignment (generic) omitted for brevity as handled above logic, 
-- but ensuring 'user_has_roles' is filled for everyone is good practice.

-- =====================================================
-- 5. ORGANIZATIONS & AGENCIES
-- =====================================================

INSERT INTO organizations (
    business_actor_id, logo_id, code, short_name, long_name, 
    description, tax_number, is_active, status
)
SELECT
    (SELECT id FROM fleet_managers ORDER BY random() LIMIT 1),
    (SELECT id FROM images ORDER BY random() LIMIT 1),
    'ORG-' || i,
    'Transport ' || i,
    'Soci√©t√© de Transport ' || i,
    'Description ' || i,
    'TAX-' || floor(random()*1000000),
    true,
    'PUBLISHED'
FROM generate_series(1, 35) as i;

INSERT INTO agencies (
    organization_id, manager_id, name, city, location, is_headquarter
)
SELECT 
    id, 
    (SELECT id FROM fleet_managers ORDER BY random() LIMIT 1),
    'Agence Centrale',
    (ARRAY['Douala', 'Yaound√©', 'Abidjan'])[floor(random()*3)+1],
    'Rue Principale',
    true
FROM organizations;

-- =====================================================
-- 6. FLEETS & VEHICLES
-- =====================================================

INSERT INTO fleets (fleet_manager_id, name, phone_number)
SELECT 
    id, 'Flotte de ' || name, '+237699000000'
FROM fleet_managers;

INSERT INTO vehicles (
    fleet_id, user_id, driver_id, license_plate, brand, model, type, color, manufacturing_year
)
SELECT 
    f.id,
    f.fleet_manager_id,
    (SELECT id FROM drivers ORDER BY random() LIMIT 1),
    'LT-' || floor(random()*999)::text || '-AA',
    (ARRAY['Toyota', 'Peugeot'])[floor(random()*2)+1],
    (ARRAY['Yaris', 'Partner'])[floor(random()*2)+1],
    (ARRAY['CAR', 'VAN'])[floor(random()*2)+1]::vehicle_type_enum,
    'Jaune',
    2020
FROM fleets f;

-- =====================================================
-- 7. OFFERS & RIDES (UPDATED)
-- =====================================================

INSERT INTO offers (
    passenger_id, start_point, end_point, price, state, created_at
)
SELECT 
    (SELECT id FROM customers ORDER BY random() LIMIT 1),
    'Point A', 'Point B', 
    2000, 
    'VALIDATED', -- UPDATE: 'CHOSEN' n'existe plus, remplac√© par 'VALIDATED'
    NOW()
FROM generate_series(1, 60) as i;

-- Rides
INSERT INTO rides (
    offer_id, passenger_id, driver_id, 
    distance, time_estimation, real_time, state, created_at
)
SELECT 
    id, 
    passenger_id,
    (SELECT id FROM drivers ORDER BY random() LIMIT 1),
    15.5, 30, 35,
    'COMPLETED',
    created_at
FROM offers 
LIMIT 40;

-- Reviews
INSERT INTO reviews (ride_id, author_id, subject, comment, rating)
SELECT 
    id,
    passenger_id,
    'Chauffeur',
    'Bonne course, chauffeur ponctuel',
    5
FROM rides
WHERE state = 'COMPLETED';

-- =====================================================
-- 8. PRODUCTS
-- =====================================================
-- (Le reste est identique, l'√©tat 'PUBLISHED' est valide pour status_enum)

INSERT INTO products (
    organization_id, name, description, standard_price, 
    status, is_active, departure_location
)
SELECT 
    (SELECT id FROM organizations ORDER BY random() LIMIT 1),
    'Trajet Sp√©cial ' || i,
    'Description produit',
    5000,
    'PUBLISHED',
    true,
    'Douala'
FROM generate_series(1, 40) as i;

-- =====================================================
-- 9. SUBSCRIPTIONS & PAYMENTS
-- =====================================================

INSERT INTO subscriptions (
    admin_id, label, price, duration_in_days, description, is_active
) VALUES 
((SELECT id FROM admins LIMIT 1), 'Pack Hebdo', 2500, 7, 'Standard', true),
((SELECT id FROM admins LIMIT 1), 'Pack Mensuel', 10000, 30, 'Pro', true),
((SELECT id FROM admins LIMIT 1), 'Pack Annuel', 100000, 365, 'VIP', true);

INSERT INTO payments (
    driver_id, user_id, subscription_id, amount_paid, status, id_provider_transaction, created_at
)
SELECT 
    d.id, -- Driver ID
    d.id, -- Payer ID
    s.id, -- Subscription ID
    s.price,
    'SUCCESS',
    'TXN-' || floor(random()*10000000),
    NOW()
FROM drivers d
CROSS JOIN subscriptions s
ORDER BY random()
LIMIT 50;

-- =====================================================
-- 10. SOCIAL & ADDRESSES
-- =====================================================

INSERT INTO syndicats (organization_id, name, is_approved)
SELECT id, 'Syndicat Transports', true FROM organizations LIMIT 1;

INSERT INTO branches (id, syndicat_id, name, location)
SELECT 
    ag.id,
    (SELECT id FROM syndicats LIMIT 1),
    'Branche ' || ag.name, 
    ag.location 
FROM agencies ag 
LIMIT 10;

INSERT INTO publications (branch_id, author_id, content, status, n_likes)
SELECT 
    (SELECT id FROM branches ORDER BY random() LIMIT 1),
    (SELECT id FROM admins ORDER BY random() LIMIT 1),
    'Info Trafic ' || i,
    'PUBLISHED',
    floor(random() * 50)::int
FROM generate_series(1, 40) as i;

-- =====================================================
-- SEEDING DIRECT PERMISSIONS
-- =====================================================

INSERT INTO permissions (id, name) VALUES 
(uuid_generate_v4(), 'extra:special_access'),
(uuid_generate_v4(), 'fleet:emergency_stop');

INSERT INTO user_has_permissions (user_id, permission_id)
VALUES (
    (SELECT id FROM users ORDER BY email_address LIMIT 1),
    (SELECT id FROM permissions WHERE name = 'extra:special_access' LIMIT 1)
);

--- FILE: src/main/resources/local/schema.sql ---
-- =====================================================
-- YOWYOB DB - INIT SCRIPT
-- PostgreSQL
-- Structure: Core -> Organization -> RBAC
-- =====================================================

-- Clean up existing tables and types to ensure a fresh start
-- We drop them in reverse order of dependency
DROP TABLE IF EXISTS user_has_roles CASCADE;
DROP TABLE IF EXISTS role_has_permissions CASCADE;
DROP TABLE IF EXISTS permissions CASCADE;
DROP TABLE IF EXISTS roles CASCADE;
DROP TABLE IF EXISTS reviews CASCADE;
DROP TABLE IF EXISTS payments CASCADE;
DROP TABLE IF EXISTS subscriptions CASCADE;
DROP TABLE IF EXISTS admins CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;
DROP TABLE IF EXISTS comments CASCADE;
DROP TABLE IF EXISTS reactions CASCADE;
DROP TABLE IF EXISTS event_images CASCADE;
DROP TABLE IF EXISTS events CASCADE;
DROP TABLE IF EXISTS publication_images CASCADE;
DROP TABLE IF EXISTS publications CASCADE;
DROP TABLE IF EXISTS branches CASCADE;
DROP TABLE IF EXISTS avis CASCADE;
DROP TABLE IF EXISTS votes CASCADE;
DROP TABLE IF EXISTS publication_votes CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS abstract_products CASCADE;
DROP TABLE IF EXISTS syndicats CASCADE;
DROP TABLE IF EXISTS offer_driver_linkages CASCADE;
DROP TABLE IF EXISTS geofence_events CASCADE;
DROP TABLE IF EXISTS geofence_point_zone_linkages CASCADE;
DROP TABLE IF EXISTS geofence_points CASCADE;
DROP TABLE IF EXISTS maintenance_parameters CASCADE;
DROP TABLE IF EXISTS financial_parameters CASCADE;
DROP TABLE IF EXISTS operational_parameters CASCADE;
DROP TABLE IF EXISTS trips CASCADE;
DROP TABLE IF EXISTS roads CASCADE;
DROP TABLE IF EXISTS vehicles CASCADE;
DROP TABLE IF EXISTS geofence_zones CASCADE;
DROP TABLE IF EXISTS fleets CASCADE;
DROP TABLE IF EXISTS fleet_managers CASCADE;
DROP TABLE IF EXISTS rides CASCADE;
DROP TABLE IF EXISTS offers CASCADE;
DROP TABLE IF EXISTS drivers CASCADE;
DROP TABLE IF EXISTS services CASCADE;
DROP TABLE IF EXISTS customers CASCADE;
DROP TABLE IF EXISTS sales_persons CASCADE;
DROP TABLE IF EXISTS prospects CASCADE;
DROP TABLE IF EXISTS employees CASCADE;
DROP TABLE IF EXISTS providers CASCADE;
DROP TABLE IF EXISTS addresses CASCADE;
DROP TABLE IF EXISTS proposed_activities CASCADE;
DROP TABLE IF EXISTS settings CASCADE;
DROP TABLE IF EXISTS third_parties CASCADE;
DROP TABLE IF EXISTS certifications CASCADE;
DROP TABLE IF EXISTS organization_business_domains CASCADE;
DROP TABLE IF EXISTS contacts CASCADE;
DROP TABLE IF EXISTS business_domains CASCADE;
DROP TABLE IF EXISTS agencies CASCADE;
DROP TABLE IF EXISTS organizations CASCADE;
DROP TABLE IF EXISTS business_actors CASCADE;
DROP TABLE IF EXISTS countries CASCADE;
DROP TABLE IF EXISTS images CASCADE;
DROP TABLE IF EXISTS users CASCADE;

-- Drop existing types
DROP TYPE IF EXISTS reaction_type_enum CASCADE;
DROP TYPE IF EXISTS type_enum CASCADE;
DROP TYPE IF EXISTS role_type_enum CASCADE;
DROP TYPE IF EXISTS engine_status_enum CASCADE;
DROP TYPE IF EXISTS maintenance_status_enum CASCADE;
DROP TYPE IF EXISTS event_type_enum CASCADE;
DROP TYPE IF EXISTS ride_state_enum CASCADE;
DROP TYPE IF EXISTS offer_state_enum CASCADE;
DROP TYPE IF EXISTS vehicle_type_enum CASCADE;
DROP TYPE IF EXISTS action_enum CASCADE;
DROP TYPE IF EXISTS category_enum CASCADE;
DROP TYPE IF EXISTS status_enum CASCADE;

-- Re-enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";


-- =====================================================
-- ENUM TYPES
-- =====================================================

CREATE TYPE status_enum AS ENUM (
  'DRAFT', 'WAITING_CONFIRMATION', 'PUBLISHED', 'IN_PROGRESS', 'CANCELLED', 'EXPIRED'
);

CREATE TYPE category_enum AS ENUM (
  'ANNOUNCE', 'PLANNING', 'VEHICLE', 'ADDRESS', 'EXPERIENCE'
);

CREATE TYPE action_enum AS ENUM (
  'CREATE', 'UPDATE', 'READ', 'DELETE'
);

CREATE TYPE vehicle_type_enum AS ENUM (
  'CAR', 'VAN', 'TRUCK', 'BIKE'
);

CREATE TYPE offer_state_enum AS ENUM (
  'PENDING', 
  'BID_RECEIVED', 
  'DRIVER_SELECTED', 
  'VALIDATED', 
  'CANCELLED'
);

CREATE TYPE ride_state_enum AS ENUM (
  'CREATED', 
  'ONGOING', 
  'COMPLETED', 
  'CANCELLED'
);

CREATE TYPE event_type_enum AS ENUM (
  'ENTRY', 'EXIT'
);

CREATE TYPE maintenance_status_enum AS ENUM (
  'UP_TO_DATE', 'PENDING', 'OVERDUE'
);

CREATE TYPE engine_status_enum AS ENUM (
  'OK', 'NEED_SERVICE', 'OUT_OF_SERVICE'
);

CREATE TYPE role_type_enum AS ENUM (
  'CUSTOMER', 'DRIVER', 'FLEET_MANAGER', 'ADMIN', 'PASSENGER', 'PRESIDENT', 'MODERATOR', 'CLIENT'
);

CREATE TYPE type_enum AS ENUM (
  'NOTIFICATION', 'CHAT', 'PAYMENT', 'MEDIA'
);

CREATE TYPE reaction_type_enum AS ENUM (
  'LIKE', 'LOVE', 'HAHA', 'WOW', 'SAD', 'ANGRY'
);


-- =====================================================
-- FIX: IMPLICIT CASTS (MANDATORY FOR R2DBC)
-- =====================================================
-- Cela permet √† Spring d'envoyer "PENDING" (String) et √† Postgres de le comprendre comme un Enum
CREATE CAST (character varying as offer_state_enum) WITH INOUT AS IMPLICIT;
CREATE CAST (character varying as ride_state_enum) WITH INOUT AS IMPLICIT;
CREATE CAST (character varying as role_type_enum) WITH INOUT AS IMPLICIT;
CREATE CAST (character varying as vehicle_type_enum) WITH INOUT AS IMPLICIT;

-- =====================================================
-- CORE TABLES
-- =====================================================

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  phone_number TEXT,
  email_address TEXT UNIQUE
);

CREATE TABLE images (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  url TEXT NOT NULL,
  alt_text TEXT,
  uploaded_at TIMESTAMP DEFAULT now()
);

CREATE TABLE countries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  code TEXT NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE business_actors (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT,
  phone_number TEXT,
  email_address TEXT,
  CONSTRAINT fk_business_actor_user
    FOREIGN KEY (id) REFERENCES users(id)
    ON DELETE CASCADE
);

-- =====================================================
-- ORGANIZATION TABLES
-- =====================================================

CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  business_actor_id UUID REFERENCES business_actors(id),
  logo_id UUID REFERENCES images(id),

  code TEXT,
  service TEXT,
  is_individual_business BOOLEAN DEFAULT false,
  email TEXT,
  short_name TEXT,
  long_name TEXT,
  description TEXT,
  logo_uri TEXT,
  website_url TEXT,
  social_network TEXT,
  business_registration_number TEXT,
  tax_number TEXT,
  capital_share NUMERIC,
  ceo_name TEXT,
  year_founded INT,
  keywords TEXT,
  number_of_employees INT,
  legal_form TEXT,
  is_active BOOLEAN DEFAULT true,
  status status_enum DEFAULT 'DRAFT',

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE agencies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- Must belong to an org

  owner_id UUID REFERENCES business_actors(id),
  manager_id UUID REFERENCES business_actors(id),
  logo_id UUID REFERENCES images(id),

  code TEXT,
  name TEXT,
  location TEXT,
  description TEXT,
  transferable BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  logo_uri TEXT,
  short_name TEXT,
  long_name TEXT,
  is_individual_business BOOLEAN DEFAULT false,
  is_headquarter BOOLEAN DEFAULT false,
  country TEXT,
  city TEXT,
  latitude NUMERIC,
  longitude NUMERIC,
  open_time TIME,
  close_time TIME,
  phone TEXT,
  email TEXT,
  whatsapp TEXT,
  greeting_message TEXT,
  average_revenue NUMERIC,
  capital_share NUMERIC,
  registration_number TEXT,
  social_network TEXT,
  tax_number TEXT,
  keywords TEXT,
  is_public BOOLEAN DEFAULT false,
  is_business BOOLEAN DEFAULT true,
  total_affiliated_customers INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE business_domains (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL, -- optional link to organization
  parent_id UUID REFERENCES business_domains(id) ON DELETE SET NULL,   -- self-referential for hierarchy
  image_id UUID REFERENCES images(id),

  code TEXT,
  service TEXT,
  name TEXT,
  image_uri TEXT,
  type TEXT,
  type_label TEXT,
  description TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE organization_business_domains (
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  business_domain_id UUID REFERENCES business_domains(id) ON DELETE CASCADE,
  PRIMARY KEY (organization_id, business_domain_id)
);

CREATE TABLE contacts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  contactable_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  contactable_type TEXT,
  first_name TEXT,
  last_name TEXT,
  title TEXT,
  is_email_verified BOOLEAN DEFAULT false,
  is_phone_number_verified BOOLEAN DEFAULT false,
  is_favorite BOOLEAN DEFAULT false,
  phone_number TEXT,
  secondary_phone_number TEXT,
  fax_number TEXT,
  email TEXT,
  secondary_email TEXT,
  email_verified_at TIMESTAMP,
  phone_verified_at TIMESTAMP,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE certifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  type TEXT,
  name TEXT,
  description TEXT,
  obtainment_date DATE,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE third_parties (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  logo_id UUID REFERENCES images(id),

  code TEXT,
  type TEXT,
  legal_form TEXT,
  unique_identification_number TEXT,
  trade_registration_number TEXT,
  name TEXT,
  acronym TEXT,
  long_name TEXT,
  logo_uri TEXT,
  accounting_account_numbers TEXT,
  authorized_payment_methods TEXT,
  authorized_credit_limit NUMERIC,
  max_discount_rate NUMERIC,
  vat_subject BOOLEAN,
  operations_balance NUMERIC,
  opening_balance NUMERIC,
  pay_term_number INT,
  pay_term_type TEXT,
  third_party_family TEXT,
  classification TEXT,
  tax_number TEXT,
  loyalty_points NUMERIC,
  loyalty_points_used NUMERIC,
  loyalty_points_expired NUMERIC,
  enabled BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE settings (
  user_id UUID PRIMARY KEY REFERENCES users(id),
  theme TEXT,
  language TEXT,
  long_ride_enabled BOOLEAN DEFAULT false,
  short_ride_enabled BOOLEAN DEFAULT false,
  privacy_enable BOOLEAN DEFAULT true,
  allow_calls BOOLEAN DEFAULT true,
  allow_messages BOOLEAN DEFAULT true,
  notify_new_rides BOOLEAN DEFAULT true,
  notify_ratings BOOLEAN DEFAULT true,
  notify_practical_tips BOOLEAN DEFAULT true,
  notify_promotions BOOLEAN DEFAULT true,
  notify_policy_updates BOOLEAN DEFAULT true,
  notify_peak_hour_recommendations BOOLEAN DEFAULT true,
  receive_email BOOLEAN DEFAULT true,
  receive_sms BOOLEAN DEFAULT true,
  receive_push_notifications BOOLEAN DEFAULT true,
  receive_whatsapp BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE proposed_activities (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  type TEXT,
  name TEXT,
  rate NUMERIC,
  description TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE addresses (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  addressable_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  country_id UUID REFERENCES countries(id) ON DELETE SET NULL,

  addressable_type TEXT,
  type TEXT,
  address_line_1 TEXT,
  address_line_2 TEXT,
  city TEXT,
  state TEXT,
  locality TEXT,
  zip_code TEXT,
  postal_code TEXT,
  po_box TEXT,
  is_default BOOLEAN DEFAULT false,
  neighbor_hood TEXT,
  informal_description TEXT,
  latitude NUMERIC,
  longitude NUMERIC,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

-- =====================================================
-- USERS EXTENDED
-- =====================================================

CREATE TABLE providers (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  contact_info TEXT,
  address TEXT,
  is_active BOOLEAN DEFAULT true,
  product_service_type TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE employees (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  is_manager BOOLEAN DEFAULT false,
  role TEXT,
  department TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE prospects (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  payment_method TEXT,
  amount_paid NUMERIC,
  interest_level TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE sales_persons (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  commission_rate NUMERIC,
  credit NUMERIC,
  current_balance NUMERIC,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE customers (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  payment_method TEXT,
  amount_paid NUMERIC,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE services (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  name TEXT,
  phone_number TEXT,
  email_address TEXT
);

-- =====================================================
-- RIDE & FLEET MANAGEMENT
-- =====================================================

CREATE TABLE drivers (
  id UUID PRIMARY KEY REFERENCES business_actors(id) ON DELETE CASCADE,

  status TEXT,
  license_number TEXT,
  has_car BOOLEAN DEFAULT false
);

CREATE TABLE offers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  passenger_id UUID REFERENCES customers(id) ON DELETE CASCADE,
  selected_driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,

  start_point TEXT,
  end_point TEXT,
  price NUMERIC,
  state offer_state_enum DEFAULT 'PENDING',
  ids_interested_drivers TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE rides (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  offer_id UUID REFERENCES offers(id) ON DELETE SET NULL,
  passenger_id UUID REFERENCES users(id) ON DELETE SET NULL,
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,

  distance NUMERIC,
  time_estimation NUMERIC,
  real_time NUMERIC,
  state ride_state_enum DEFAULT 'CREATED',

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE fleet_managers (
  id UUID PRIMARY KEY REFERENCES business_actors(id) ON DELETE CASCADE,

  name TEXT,
  phone_number TEXT,
  email_address TEXT
);

CREATE TABLE fleets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  fleet_manager_id UUID REFERENCES fleet_managers(id) ON DELETE SET NULL,

  name TEXT,
  phone_number TEXT,
  email_address TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE geofence_zones (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  surface_area NUMERIC,
  perimeter NUMERIC
);

CREATE TABLE vehicles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,
  fleet_id UUID REFERENCES fleets(id) ON DELETE SET NULL,
  zone_id UUID REFERENCES geofence_zones(id) ON DELETE SET NULL,

  license_plate TEXT,
  model TEXT,
  brand TEXT,
  manufacturing_year INT,
  type vehicle_type_enum,
  color TEXT
);

CREATE TABLE roads (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  start_point TEXT,
  end_point TEXT
);

CREATE TABLE trips (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  road_id UUID REFERENCES roads(id) ON DELETE SET NULL,
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,

  start_date DATE,
  end_date DATE,
  start_time TIME,
  end_time TIME,
  type TEXT,
  color TEXT
);

CREATE TABLE operational_parameters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,

  statut TEXT,
  current_location TEXT,
  current_speed NUMERIC,
  fuel_level NUMERIC,
  mileage NUMERIC,
  odometer_reading NUMERIC,
  bearing NUMERIC,

  timestamp TIMESTAMP DEFAULT now()
);

CREATE TABLE financial_parameters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,

  insurance_number TEXT,
  insurance_expired_at DATE,
  registered_at DATE,
  purchased_at DATE,
  depreciation_rate NUMERIC,
  cost_per_km NUMERIC
);

CREATE TABLE maintenance_parameters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,

  last_maintenance_at DATE,
  next_maintenance_at DATE,
  engine_status engine_status_enum DEFAULT 'OK',
  battery_health TEXT,
  maintenance_status maintenance_status_enum DEFAULT 'UP_TO_DATE'
);

CREATE TABLE geofence_points (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  latitude NUMERIC,
  longitude NUMERIC
);

CREATE TABLE geofence_point_zone_linkages (
  point_id UUID REFERENCES geofence_points(id) ON DELETE CASCADE,
  zone_id UUID REFERENCES geofence_zones(id) ON DELETE CASCADE,
  PRIMARY KEY (point_id, zone_id)
);

CREATE TABLE geofence_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  zone_id UUID REFERENCES geofence_zones(id) ON DELETE SET NULL,
  point_id UUID REFERENCES geofence_points(id) ON DELETE SET NULL,

  type event_type_enum,

  timestamp TIMESTAMP DEFAULT now()
);

CREATE TABLE offer_driver_linkages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), -- La seule Cl√© Primaire
  offer_id UUID REFERENCES offers(id) ON DELETE CASCADE,
  driver_id UUID REFERENCES drivers(id) ON DELETE CASCADE,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),

  -- R√®gle m√©tier transform√©e en contrainte d'unicit√©
  CONSTRAINT uk_offer_driver UNIQUE (offer_id, driver_id) 
);

-- =====================================================
-- OTHERS: PRODUCTS, SYNDICATS, PUBLICATIONS & REVIEWS
-- =====================================================

CREATE TABLE syndicats (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  is_approved BOOLEAN DEFAULT false,
  name TEXT,
  description TEXT,
  domain TEXT,
  type TEXT,
  charte_url TEXT,
  status_url TEXT,
  members_list_url TEXT,
  commitment_certificate_url TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE abstract_products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  syndicat_id UUID REFERENCES syndicats(id) ON DELETE SET NULL,

  name TEXT,
  description TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  abstract_product_id UUID REFERENCES abstract_products(id) ON DELETE SET NULL,

  name TEXT,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  standard_price NUMERIC,
  departure_location TEXT,
  arrival_location TEXT,
  start_date DATE,
  start_time TIME,
  end_date DATE,
  end_time TIME,
  baggage_info TEXT,
  is_negotiable BOOLEAN DEFAULT false,
  payment_method TEXT,
  title TEXT,
  status status_enum DEFAULT 'DRAFT',
  product_urls TEXT,
  regular_amount NUMERIC,
  discount_percentage NUMERIC,
  discounted_amount NUMERIC,
  metadata JSONB,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE publication_votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  title TEXT,
  description TEXT,
  closing_at TIMESTAMP,
  type category_enum
);

CREATE TABLE votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  publication_vote_id UUID REFERENCES publication_votes(id) ON DELETE CASCADE,

  label TEXT
);

CREATE TABLE avis (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  product_id UUID REFERENCES products(id) ON DELETE CASCADE,
  syndicat_id UUID REFERENCES syndicats(id) ON DELETE SET NULL,

  comment TEXT,
  number INT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE branches (
  id UUID PRIMARY KEY REFERENCES agencies(id),
  syndicat_id UUID REFERENCES syndicats(id) ON DELETE SET NULL,

  name TEXT,
  location TEXT,
  contact TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE publications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  branch_id UUID REFERENCES branches(id) ON DELETE SET NULL,
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,

  content TEXT,
  status status_enum DEFAULT 'DRAFT',
  n_likes INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE publication_images (
  publication_id UUID REFERENCES publications(id) ON DELETE CASCADE,
  image_id UUID REFERENCES images(id) ON DELETE CASCADE,
  PRIMARY KEY (publication_id, image_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  branch_id UUID REFERENCES branches(id) ON DELETE SET NULL,

  title TEXT,
  description TEXT,
  location TEXT,
  date DATE,
  start_time TIME,
  end_time TIME,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE event_images (
  event_id UUID REFERENCES events(id) ON DELETE CASCADE,
  image_id UUID REFERENCES images(id) ON DELETE CASCADE,
  PRIMARY KEY (event_id, image_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE reactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  publication_id UUID REFERENCES publications(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  type reaction_type_enum,

  reacted_at TIMESTAMP DEFAULT now()
);

CREATE TABLE comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,
  publication_id UUID REFERENCES publications(id) ON DELETE CASCADE,
  parent_id UUID REFERENCES comments(id) ON DELETE SET NULL,
  image_id UUID REFERENCES images(id) ON DELETE SET NULL,

  content TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE profiles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  first_name TEXT,
  last_name TEXT,
  nickname TEXT,
  profile_image_url TEXT,
  birth_date DATE,
  nationality TEXT,
  gender TEXT,
  language TEXT,
  company_name TEXT,
  biography TEXT,
  rating NUMERIC,
  total_trips INT,
  is_available BOOLEAN DEFAULT true,
  is_verified BOOLEAN DEFAULT false,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- =====================================================
-- PAYMENTS & SUBSCRIPTIONS
-- =====================================================

CREATE TABLE admins (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  name TEXT,
  phone_number TEXT,
  email_address TEXT
);

CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  admin_id UUID REFERENCES admins(id) ON DELETE SET NULL,

  label TEXT,
  price NUMERIC,
  duration_in_days INT,
  description TEXT,
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,
  subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
  user_id UUID REFERENCES business_actors(id) ON DELETE SET NULL,

  amount_paid NUMERIC,
  status TEXT,
  id_provider_transaction TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  ride_id UUID REFERENCES rides(id) ON DELETE CASCADE,
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,

  subject TEXT,
  comment TEXT,
  rating NUMERIC,

  created_at TIMESTAMP DEFAULT now()
);

-- =====================================================
-- ROLE-BASED ACCESS CONTROL (RBAC)
-- =====================================================

CREATE TABLE roles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  name TEXT NOT NULL,
  guard_name TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE permissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  name TEXT NOT NULL,
  guard_name TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE role_has_permissions (
  role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (role_id, permission_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE user_has_roles (
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, role_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- =====================================================
-- FIX: DIRECT PERMISSIONS (USER <-> PERMISSIONS)
-- =====================================================

-- Table de liaison pour les permissions accord√©es directement √† un utilisateur
CREATE TABLE IF NOT EXISTS user_has_permissions (
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, permission_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Commit the transaction


-- =====================================================
-- END OF SCRIPT. NOTHING AFTER HERE!
-- =====================================================


--- FILE: src/main/resources/db/changelog/db.changelog-master.yaml ---

databaseChangeLog:

  - include:
      file: db/changelog/changes/000-initial-schema.sql

  - include:
      file: db/changelog/changes/001-update-drivers-schema.sql

  - include:
      file: db/changelog/changes/002-create-user-devices.sql
      
  - include:
      file: db/changelog/changes/003-create-notification-settings.sql

  - include:
      file: db/changelog/changes/004-create-notifications-history.sql

  - include:
      file: db/changelog/changes/005-alter-notifications-json-to-text.sql

  - include:
      file: db/changelog/changes/006-update-drivers-vehicle.sql

  - include:
      file: db/changelog/changes/007-add-syndicate-field.sql

  - include:
      file: db/changelog/changes/008-add-user-photo-uri.sql

  - include:
      file: db/changelog/changes/009-add-user-names.sql

  - include:
      file: db/changelog/changes/010-create-reviews-schema.sql

  - include:
      file: db/changelog/changes/011-default-driver-validation.sql

  - include:
      file: db/changelog/changes/012-enrich-offer-and-bids.sql

  - include:
      file: db/changelog/changes/013-create-trajectory-history.sql

  - include:
      file: db/changelog/changes/014-add-offer-coordinates.sql

  - include:
      file: db/changelog/changes/015-add-offer-end-coordinates.sql

--- FILE: src/main/resources/db/changelog/changes/000-initial-schema.sql ---
--- FILE: src/main/resources/db/changelog/changes/000-initial-schema.sql ---
-- liquibase formatted sql

-- changeset yowyob:000-init-schema
-- comment: Initialisation du sch√©ma Ride & Go

-- 1. Cr√©ation du sch√©ma
CREATE SCHEMA IF NOT EXISTS ride_and_go;

-- 2. Extension UUID
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 3. Types ENUM & Casts (Crucial pour R2DBC)
DO $$ BEGIN
    CREATE TYPE offer_state_enum AS ENUM ('PENDING', 'BID_RECEIVED', 'DRIVER_SELECTED', 'VALIDATED', 'CANCELLED');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE TYPE ride_state_enum AS ENUM ('CREATED', 'ONGOING', 'COMPLETED', 'CANCELLED');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- Cr√©ation des CASTs implicites pour que Java String -> Postgres Enum fonctionne
DO $$ BEGIN
    CREATE CAST (character varying as offer_state_enum) WITH INOUT AS IMPLICIT;
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

DO $$ BEGIN
    CREATE CAST (character varying as ride_state_enum) WITH INOUT AS IMPLICIT;
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- 4. Table USERS (Socle commun)
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY, -- Pas de default car vient souvent de l'Auth Service
    name VARCHAR(255),
    email_address VARCHAR(255) UNIQUE,
    phone_number VARCHAR(50)
);

-- 5. Table DRIVERS (Extension de Users)
-- Un user devient driver en ayant une entr√©e ici
CREATE TABLE IF NOT EXISTS drivers (
    id UUID PRIMARY KEY, -- M√™me ID que users
    status VARCHAR(50) DEFAULT 'OFFLINE', -- AVAILABLE, BUSY, OFFLINE
    license_number VARCHAR(100),
    has_car BOOLEAN DEFAULT FALSE,
    is_online BOOLEAN DEFAULT FALSE,
    is_profile_completed BOOLEAN DEFAULT FALSE,
    
    CONSTRAINT fk_drivers_users FOREIGN KEY (id) REFERENCES users(id) ON DELETE CASCADE
);

-- 5. Table CUSTOMERS (Extension pour les passagers)
CREATE TABLE IF NOT EXISTS customers (
    id UUID PRIMARY KEY, -- M√™me ID que users
    code VARCHAR(50),
    payment_method VARCHAR(50), -- CASH, CARD...
    amount_paid DECIMAL(10, 2) DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT fk_customers_users FOREIGN KEY (id) REFERENCES users(id) ON DELETE CASCADE
);

-- 6. Table BUSINESS_ACTORS (Socle pour les pros)
CREATE TABLE IF NOT EXISTS business_actors (
    id UUID PRIMARY KEY,
    name VARCHAR(255),
    phone_number VARCHAR(50),
    email_address VARCHAR(255),
    
    CONSTRAINT fk_business_actors_users FOREIGN KEY (id) REFERENCES users(id) ON DELETE CASCADE
);


-- 6. Tables NOTIFICATIONS (Settings, Devices, History)
CREATE TABLE IF NOT EXISTS user_devices (
    user_id UUID PRIMARY KEY,
    device_token TEXT NOT NULL,
    platform VARCHAR(20),
    last_updated_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_devices_users FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS notification_settings (
    user_id UUID PRIMARY KEY,
    enable_email BOOLEAN DEFAULT TRUE,
    enable_sms BOOLEAN DEFAULT FALSE,
    enable_push BOOLEAN DEFAULT TRUE,
    enable_whatsapp BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_settings_users FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL,
    title VARCHAR(255),
    message TEXT,
    type VARCHAR(50),
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    data JSONB, -- Stock√© en JSONB pour Postgres, mapp√© en String cot√© Java si besoin
    CONSTRAINT fk_history_users FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
CREATE INDEX idx_notif_user ON notifications(user_id);

-- 7. Table OFFERS (La demande)
CREATE TABLE IF NOT EXISTS offers (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    passenger_id UUID NOT NULL,
    selected_driver_id UUID,
    start_point TEXT,
    end_point TEXT,
    price DECIMAL(10, 2),
    state offer_state_enum DEFAULT 'PENDING',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT fk_offers_passenger FOREIGN KEY (passenger_id) REFERENCES users(id),
    CONSTRAINT fk_offers_driver FOREIGN KEY (selected_driver_id) REFERENCES drivers(id)
);

-- 8. Table LINKAGE (Qui a postul√© √† quoi)
CREATE TABLE IF NOT EXISTS offer_driver_linkages (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    offer_id UUID NOT NULL,
    driver_id UUID NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT fk_link_offer FOREIGN KEY (offer_id) REFERENCES offers(id) ON DELETE CASCADE,
    CONSTRAINT fk_link_driver FOREIGN KEY (driver_id) REFERENCES drivers(id) ON DELETE CASCADE,
    CONSTRAINT uk_offer_driver UNIQUE (offer_id, driver_id)
);

-- 9. Table RIDES (La course valid√©e)
CREATE TABLE IF NOT EXISTS rides (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    offer_id UUID UNIQUE, -- 1 Offre = 1 Course max
    passenger_id UUID,
    driver_id UUID,
    distance DECIMAL(10,2),
    time_estimation INT, -- en minutes
    real_time INT,
    state ride_state_enum DEFAULT 'CREATED',
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    
    CONSTRAINT fk_rides_offer FOREIGN KEY (offer_id) REFERENCES offers(id),
    CONSTRAINT fk_rides_passenger FOREIGN KEY (passenger_id) REFERENCES users(id),
    CONSTRAINT fk_rides_driver FOREIGN KEY (driver_id) REFERENCES drivers(id)
);

-- 10. Tables RBAC (Gestion locale simple des r√¥les)
CREATE TABLE IF NOT EXISTS roles (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(50) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS permissions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS user_has_roles (
    user_id UUID,
    role_id UUID,
    PRIMARY KEY (user_id, role_id),
    CONSTRAINT fk_uhr_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_uhr_role FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS role_has_permissions (
    role_id UUID,
    permission_id UUID,
    PRIMARY KEY (role_id, permission_id),
    CONSTRAINT fk_rhp_role FOREIGN KEY (role_id) REFERENCES roles(id) ON DELETE CASCADE,
    CONSTRAINT fk_rhp_perm FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS user_has_permissions (
    user_id UUID,
    permission_id UUID,
    PRIMARY KEY (user_id, permission_id),
    CONSTRAINT fk_uhp_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_uhp_perm FOREIGN KEY (permission_id) REFERENCES permissions(id) ON DELETE CASCADE
);

--- FILE: src/main/resources/db/changelog/changes/001-update-drivers-schema.sql ---
--- FILE: src/main/resources/db/changelog/changes/001-update-drivers-schema.sql ---
-- liquibase formatted sql

-- changeset yowyob:001-add-driver-attributes
-- comment: Ajout des attributs de statut et profil pour les chauffeurs

ALTER TABLE drivers 
ADD COLUMN IF NOT EXISTS is_online BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS is_profile_completed BOOLEAN DEFAULT FALSE;

-- On s'assure que status est bien pr√©sent (au cas o√π on part d'une base vide)
-- Ceci n'est n√©cessaire que si la table drivers n'a pas √©t√© cr√©√©e correctement par schema.sql auparavant
-- Dans un vrai projet avec Liquibase, TOUT le schema.sql devrait √™tre converti en changelogs.
-- Pour l'instant, on se contente d'alt√©rer l'existant.

--- FILE: src/main/resources/db/changelog/changes/002-create-user-devices.sql ---
-- liquibase formatted sql

-- changeset yowyob:002-create-user-devices
-- comment: Table pour stocker les tokens FCM/APNS des utilisateurs pour le Push

CREATE TABLE IF NOT EXISTS user_devices (
    user_id UUID PRIMARY KEY,
    device_token TEXT NOT NULL,
    platform VARCHAR(20), -- ANDROID, IOS, WEB
    last_updated_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_user_device_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

--- FILE: src/main/resources/db/changelog/changes/003-create-notification-settings.sql ---
-- liquibase formatted sql

-- changeset yowyob:003-create-notification-settings
-- comment: Table pour stocker les pr√©f√©rences de notification des utilisateurs

CREATE TABLE IF NOT EXISTS notification_settings (
    user_id UUID PRIMARY KEY,
    enable_email BOOLEAN DEFAULT TRUE,
    enable_sms BOOLEAN DEFAULT FALSE,
    enable_push BOOLEAN DEFAULT TRUE,
    enable_whatsapp BOOLEAN DEFAULT FALSE,
    updated_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_notif_settings_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

--- FILE: src/main/resources/db/changelog/changes/004-create-notifications-history.sql ---
-- liquibase formatted sql

-- changeset yowyob:004-create-notifications-history
-- comment: Table pour l'historique des notifications in-app

CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY,
    user_id UUID NOT NULL,
    title VARCHAR(255),
    message TEXT,
    type VARCHAR(50), -- INFO, WARNING, SUCCESS
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW(),
    data JSONB, -- Pour stocker les m√©tadonn√©es (offerId, price, etc.)
    CONSTRAINT fk_notification_user FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE INDEX idx_notif_user_date ON notifications(user_id, created_at DESC);

--- FILE: src/main/resources/db/changelog/changes/005-alter-notifications-json-to-text.sql ---
-- liquibase formatted sql

-- changeset yowyob:005-alter-notifications-data-type
-- comment: Changement du type de la colonne data de JSONB √† TEXT pour compatibilit√© R2DBC simple

ALTER TABLE ride_and_go.notifications 
ALTER COLUMN data TYPE TEXT;

--- FILE: src/main/resources/db/changelog/changes/006-update-drivers-vehicle.sql ---
-- liquibase formatted sql

-- changeset yowyob:006-update-drivers-vehicle
-- comment: Ajout de vehicle_id et is_profile_validated pour les chauffeurs

ALTER TABLE ride_and_go.drivers 
ADD COLUMN IF NOT EXISTS vehicle_id UUID,
ADD COLUMN IF NOT EXISTS is_profile_validated BOOLEAN DEFAULT FALSE;

-- On ne met pas de FK (Foreign Key) contrainte SQL car le v√©hicule est dans un autre microservice (autre DB potentiellement)
-- C'est une r√©f√©rence logique (Soft Reference).

--- FILE: src/main/resources/db/changelog/changes/007-add-syndicate-field.sql ---
ALTER TABLE ride_and_go.drivers ADD COLUMN is_syndicated BOOLEAN DEFAULT false;

--- FILE: src/main/resources/db/changelog/changes/008-add-user-photo-uri.sql ---
ALTER TABLE ride_and_go.users ADD COLUMN photo_uri TEXT;

--- FILE: src/main/resources/db/changelog/changes/009-add-user-names.sql ---
-- liquibase formatted sql

-- changeset yowyob:009-add-user-names
-- comment: Ajout de first_name et last_name √† la table users
ALTER TABLE ride_and_go.users ADD COLUMN first_name VARCHAR(255);
ALTER TABLE ride_and_go.users ADD COLUMN last_name VARCHAR(255);

--- FILE: src/main/resources/db/changelog/changes/010-create-reviews-schema.sql ---
-- liquibase formatted sql
-- changeset yowyob:010-create-reviews
-- comment: Cr√©ation de la table des avis et enrichissement de la table drivers
CREATE TABLE IF NOT EXISTS ride_and_go.reviews (
    id UUID PRIMARY KEY,
    ride_id UUID NOT NULL,
    passenger_id UUID NOT NULL,
    driver_id UUID NOT NULL,
    rating INTEGER NOT NULL CHECK (
        rating >= 1
        AND rating <= 5
    ),
    comment TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    CONSTRAINT fk_review_ride FOREIGN KEY (ride_id) REFERENCES ride_and_go.rides(id),
    CONSTRAINT uk_review_ride UNIQUE (ride_id)
);

-- Ajout des champs de score au chauffeur
ALTER TABLE
    ride_and_go.drivers
ADD
    COLUMN IF NOT EXISTS rating DECIMAL(3, 2) DEFAULT 0.0;

ALTER TABLE
    ride_and_go.drivers
ADD
    COLUMN IF NOT EXISTS total_reviews_count INTEGER DEFAULT 0;

--- FILE: src/main/resources/db/changelog/changes/011-default-driver-validation.sql ---
-- liquibase formatted sql

-- changeset yowyob:011-default-driver-validation
-- comment: D√©finit la validation du profil √† TRUE par d√©faut 

-- 1. Modifier la valeur par d√©faut pour les futures insertions
ALTER TABLE ride_and_go.drivers 
ALTER COLUMN is_profile_validated SET DEFAULT TRUE;

-- 2. Mettre √† jour les enregistrements existants 
UPDATE ride_and_go.drivers 
SET is_profile_validated = TRUE 
WHERE is_profile_validated IS FALSE;

--- FILE: src/main/resources/db/changelog/changes/012-enrich-offer-and-bids.sql ---
-- liquibase formatted sql

-- changeset yowyob:012-enrich-offer-and-bids
ALTER TABLE ride_and_go.offers ADD COLUMN passenger_phone VARCHAR(50);
ALTER TABLE ride_and_go.offers ADD COLUMN departure_time VARCHAR(50);

--- FILE: src/main/resources/db/changelog/changes/013-create-trajectory-history.sql ---
-- liquibase formatted sql
-- changeset yowyob:013-create-trajectory-history
-- comment: Table pour l'historique massif des positions (Segments de trajets)

CREATE TABLE IF NOT EXISTS ride_and_go.driver_trajectory_history (
    id UUID PRIMARY KEY,
    driver_id UUID NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    points_count INTEGER,
    -- JSONB stockera le tableau [[lat, lon, ts], [lat, lon, ts], ...]
    trajectory_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT fk_trajectory_driver FOREIGN KEY (driver_id) REFERENCES ride_and_go.drivers(id) ON DELETE CASCADE
);

CREATE INDEX idx_trajectory_driver_time ON ride_and_go.driver_trajectory_history(driver_id, start_time DESC);

--- FILE: src/main/resources/db/changelog/changes/014-add-offer-coordinates.sql ---
-- liquibase formatted sql
-- changeset yowyob:014-add-offer-coordinates
-- comment: Ajout des colonnes de g√©olocalisation pour le matching des offres

ALTER TABLE ride_and_go.offers 
ADD COLUMN IF NOT EXISTS start_lat DOUBLE PRECISION,
ADD COLUMN IF NOT EXISTS start_lon DOUBLE PRECISION;

-- Note: DOUBLE PRECISION en Postgres correspond au type Double en Java 

--- FILE: src/main/resources/db/changelog/changes/015-add-offer-end-coordinates.sql ---
-- liquibase formatted sql
-- changeset yowyob:015-add-offer-end-coordinates
-- comment: Ajout des coordonn√©es de d√©part et d'arriv√©e pour le trajet

ALTER TABLE ride_and_go.offers 
ADD COLUMN IF NOT EXISTS end_lat DOUBLE PRECISION,
ADD COLUMN IF NOT EXISTS end_lon DOUBLE PRECISION;

--- FILE: src/test/java/com/yowyob/reactive_hexagonal/ReactiveHexagonalApplicationTests.java ---
package com.yowyob.reactive_hexagonal;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ReactiveHexagonalApplicationTests {

	@Test
	void contextLoads() {
	}

}

