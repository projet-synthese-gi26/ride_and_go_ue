# Contexte du Projet : Fleet & Geofence API
GÃ©nÃ©rÃ© le : Sat 03 Jan 2026 11:16:40 AM WAT
Framework : Spring Boot WebFlux (Reactive)

## 1. Arborescence du Projet
```
.
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ Dockerfile
â”œâ”€â”€ docs
â”‚Â Â  â”œâ”€â”€ bd
â”‚Â Â  â”‚Â Â  â””â”€â”€ modifs.md
â”‚Â Â  â”œâ”€â”€ context
â”‚Â Â  â”‚Â Â  â””â”€â”€ project_context.txt
â”‚Â Â  â”œâ”€â”€ prompts
â”‚Â Â  â”‚Â Â  â””â”€â”€ master_pair_programmer.md
â”‚Â Â  â”œâ”€â”€ roadmap
â”‚Â Â  â”‚Â Â  â””â”€â”€ todo.md
â”‚Â Â  â”œâ”€â”€ specs
â”‚Â Â  â”‚Â Â  â””â”€â”€ spec.md
â”‚Â Â  â””â”€â”€ tests
â”‚Â Â      â”œâ”€â”€ full_test_offer-course.md
â”‚Â Â      â”œâ”€â”€ test_offer_creation.md
â”‚Â Â      â””â”€â”€ test_ride_annulation.md
â”œâ”€â”€ .gitattributes
â”œâ”€â”€ .github
â”‚Â Â  â””â”€â”€ workflows
â”‚Â Â      â””â”€â”€ ci-cd.yml
â”œâ”€â”€ .gitignore
â”œâ”€â”€ import_context.sh
â”œâ”€â”€ mvnw
â”œâ”€â”€ mvnw.cmd
â”œâ”€â”€ pom.xml
â”œâ”€â”€ Readme.md
â””â”€â”€ src
    â”œâ”€â”€ main
    â”‚Â Â  â”œâ”€â”€ java
    â”‚Â Â  â”‚Â Â  â””â”€â”€ com
    â”‚Â Â  â”‚Â Â      â””â”€â”€ yowyob
    â”‚Â Â  â”‚Â Â          â””â”€â”€ rideandgo
    â”‚Â Â  â”‚Â Â              â”œâ”€â”€ application
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”œâ”€â”€ service
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AuthService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ EtaCalculatorService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FareService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LocationService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OfferService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RideService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TrackingCalculatorService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â””â”€â”€ UserService.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â””â”€â”€ utils
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”œâ”€â”€ Constants.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â””â”€â”€ Utils.java
    â”‚Â Â  â”‚Â Â              â”œâ”€â”€ domain
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”œâ”€â”€ exception
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OfferNotFoundException.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OfferStatutNotMatchException.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ TokenNotFoundException.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â””â”€â”€ UserIsNotDriverException.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”œâ”€â”€ model
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Bid.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ enums
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OfferState.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RideState.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ RoleType.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Fare.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Offer.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Permission.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Ride.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Role.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â””â”€â”€ User.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â””â”€â”€ ports
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”œâ”€â”€ in
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ AcceptedOfferUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ AuthUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ CreateOfferUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ GetAvailableOffersUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ GetRideLocationUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ OfferManagementUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ PutFareInCacheUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ ResponseToOfferUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ SelectDriverUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ UpdateLocationUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â”œâ”€â”€ UpdateRideStatusUseCase.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”‚Â Â  â””â”€â”€ UserUseCases.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â””â”€â”€ out
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ AuthPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ ExternalUserPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ FareCachePort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ FareClientPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ LocationCachePort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ OfferCachePort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ OfferEventPublisherPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ OfferRepositoryPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ RideRepositoryPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ RoleRepositoryPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ SendNotificationPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ StockClientPort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â”œâ”€â”€ UserCachePort.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â          â””â”€â”€ UserRepositoryPort.java
    â”‚Â Â  â”‚Â Â              â”œâ”€â”€ infrastructure
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”œâ”€â”€ adapters
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ inbound
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ kafka
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ kafkaAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ rest
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ AuthController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ dto
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ CreateOfferRequest.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ CreateUserRequest.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ FareRequest.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ FareResponse.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ NotificationType.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ OfferResponse.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ RideResponse.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ RideTrackingResponse.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ SendNotificationRequest.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ UpdateOfferRequest.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ UpdateStatusRequest.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ UserResponse.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ FareController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ GlobalExceptionHandler.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ HealthCheckController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ LocationController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ OfferController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â”œâ”€â”€ TripController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ UserController.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â””â”€â”€ outbound
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”œâ”€â”€ cache
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ RedisAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”œâ”€â”€ external
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ client
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AuthApiClient.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ FareCalculatorClient.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ FakeAuthAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ FakeFareAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ FakeUserAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ RemoteAuthAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ RemoteFareAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ RemoteUserAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”œâ”€â”€ messaging
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â”œâ”€â”€ OfferEventPublisherAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â”‚Â Â  â””â”€â”€ SendNotificationAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â      â””â”€â”€ persistence
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”œâ”€â”€ entity
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ OfferAgreementEntity.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ OfferEntity.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ PermissionEntity.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ RideEntity.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ RoleEntity.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â””â”€â”€ UserEntity.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”œâ”€â”€ OfferR2dbcAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”œâ”€â”€ repository
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ OfferAgreementR2dbcRepository.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ OfferR2dbcRepository.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ PermissionR2dbcRepository.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ RideR2dbcRepository.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â”œâ”€â”€ RoleR2dbcRepository.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”‚Â Â  â””â”€â”€ UserR2dbcRepository.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”œâ”€â”€ RideR2dbcAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â”œâ”€â”€ RoleR2dbcAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â          â””â”€â”€ UserR2dbcAdapter.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”œâ”€â”€ config
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ AuthConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ DatabaseInitConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FareConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ KafkaConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OpenApiConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ R2dbcConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RedisConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ SecurityConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â””â”€â”€ WebClientConfig.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”œâ”€â”€ mappers
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ FareMapper.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ OfferMapper.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RideMapper.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â”œâ”€â”€ RoleMapper.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â”‚Â Â  â””â”€â”€ UserMapper.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â  â””â”€â”€ security
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â”œâ”€â”€ JwtAuthenticationManager.java
    â”‚Â Â  â”‚Â Â              â”‚Â Â      â””â”€â”€ SecurityContextRepository.java
    â”‚Â Â  â”‚Â Â              â”œâ”€â”€ RideAndGoApplication.java
    â”‚Â Â  â”‚Â Â              â””â”€â”€ tmp
    â”‚Â Â  â””â”€â”€ resources
    â”‚Â Â      â”œâ”€â”€ application.yml
    â”‚Â Â      â”œâ”€â”€ local
    â”‚Â Â      â”‚Â Â  â”œâ”€â”€ data.sql
    â”‚Â Â      â”‚Â Â  â””â”€â”€ schema.sql
    â”‚Â Â      â””â”€â”€ prod.application.yml
    â””â”€â”€ test
        â””â”€â”€ java
            â””â”€â”€ com
                â””â”€â”€ yowyob
                    â””â”€â”€ reactive_hexagonal
                        â””â”€â”€ ReactiveHexagonalApplicationTests.java

49 directories, 139 files
```
## 2. Contenu des Fichiers

---
### Fichier : `./bin/src/main/resources/application.yml`
```yaml
server:
  port: 8080

spring:
  application:
    name: reactive-hexagonal
  
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/reactivedb
    username: user
    password: password
  
  sql:
    init:
      mode: always # start the scheme

  data:
    redis:
      host: localhost
      port: 6379

  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# Custom Config 
application:
  external:
    stock-service-url: http://localhost:8081 # Wiremock

# Resilience4j Config
resilience4j:
  circuitbreaker:
    instances:
      stock-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5```

---
### Fichier : `./bin/src/main/resources/schema.sql`
```sql
CREATE TABLE IF NOT EXISTS products (
    id UUID PRIMARY KEY,
    name VARCHAR(255),
    price DECIMAL(10, 2),
    status VARCHAR(50)
);```

---
### Fichier : `./bin/.mvn/wrapper/maven-wrapper.properties`
```properties
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip
```

---
### Fichier : `./bin/pom.xml`
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.4.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.yowyob</groupId>
    <artifactId>reactive-hexagonal</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>reactive-hexagonal</name>
    <description>Template Hexagonal Reactive pour com.yowyob</description>
    
    <properties>
        <java.version>21</java.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
    </properties>
    
    <dependencies>
        <!-- REACTIVE CORE -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- DATA (R2DBC & REDIS) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-r2dbc</artifactId>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>r2dbc-postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>

        <!-- MESSAGING (KAFKA) -->
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>

        <!-- CLOUD & RESILIENCE -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
        </dependency>

        <!-- TOOLS (Lombok & Mapstruct) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        
        <!-- Docker Compose Auto-setup -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-docker-compose</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>```

---
### Fichier : `./docs/roadmap/todo.md`
```md
### ðŸ“‹ Roadmap API RIDE & GO 

- [x] **TÃ¢che 1 :** Configuration du projet (config,SÃ©curitÃ©, alignement BD Centrale & Seeding,swagger).
- [x] **1.1 : IdentitÃ© & Nettoyage (Metadata)**
    - [x] Mettre Ã  jour le `pom.xml` (artifactId: `ride-and-go`, name: `Ride & Go API`).
    - [x] Renommer le package racine `com.yowyob.rideandgo` en `com.yowyob.rideandgo`.
    - [x] Supprimer tous les fichiers liÃ©s au domaine "Product" (Entities, Mappers, Services, Controllers).
    - [x] Nettoyer `application.yml` (nom de l'app, group-id Kafka, suppression des clÃ©s inutiles).

- [x] **1.2 : Alignement avec la DB Centrale (Structure)**
    - [x] Harmoniser les scripts SQL : Utiliser les noms de tables globaux (`users`, `roles`, `business_actors`) au lieu des prÃ©fixes `ride_and_go_`.
    - [x] Mettre Ã  jour les entitÃ©s Java (`UserEntity`, `RoleEntity`, etc.) avec les bonnes annotations `@Table`.
    - [x] Valider la cohÃ©rence des types UUID pour toutes les clÃ©s primaires et Ã©trangÃ¨res.

- [x] **1.3 : SÃ©curitÃ© RÃ©active & Documentation (Security/Swagger)**
    - [x] ImplÃ©mentation de `SecurityConfig` : Configuration WebFlux rÃ©active (Stateless, protection des routes, dÃ©sactivation du mot de passe par dÃ©faut).
    - [x] Autorisation des routes Swagger et HealthCheck dans la chaÃ®ne de filtres.
    - [x] Organisation du Swagger UI par tags mÃ©tier (Auth, Fares, Offers, Trips) selon les spÃ©cifications.

- [x] **1.4 : Automatisation & Seeding (DonnÃ©es de test)**
    - [x] Configurer `DatabaseInitConfig` pour une exÃ©cution sÃ©quentielle (Schema -> Check -> Data).
    - [x] PrÃ©parer `src/main/resources/local/data.sql` avec les rÃ´les (`PASSENGER`, `DRIVER`) et des utilisateurs de test Ride & Go.
    - [x] **Validation finale** : DÃ©marrage complet de l'application et vÃ©rification des 100+ utilisateurs via Swagger.

- [x] **TÃ¢che 2 :** Gestion de l'Authentification (auth fake,Liaison TraMaSys & Profils).
    - [x] **2.1 : Contrats du Domaine**
        - [x] Mettre Ã  jour `AuthPort` et `AuthUseCase` pour supporter Login/Register/Reset.
        - [x] Aligner le modÃ¨le `AuthResponse` sur le format TraMaSys (Token, RÃ´les, Permissions).
    - [x] **2.2 : ImplÃ©mentation des Adaptateurs**
        - [x] CrÃ©er `FakeAuthAdapter` (Mode dÃ©veloppement sans rÃ©seau).
        - [x] CrÃ©er `RemoteAuthAdapter` (Appels rÃ©els via `AuthApiClient`).
        - [x] Configurer `AuthConfig` pour le switch dynamique via `application.auth.mode`.
    - [x] **2.3 : SÃ©curisation par Token (JWT Validation)**
        - [x] ImplÃ©menter le `AuthenticationManager` rÃ©actif pour valider les tokens via TraMaSys.
        - [x] Configurer le filtre d'extraction du header `Authorization: Bearer`.
    - [x] **2.4 : API REST & Documentation**
        - [x] Finaliser `AuthController` avec les endpoints de Login et Register.
        - [x] **Validation Swagger** : ScÃ©nario "Login rÃ©el sur TraMaSys -> RÃ©cupÃ©ration du JWT -> AccÃ¨s au HealthCheck protÃ©gÃ©".

- [x] **TÃ¢che 3 : Gestion des Offres (Flux Marketplace Complet)**
    - [x] **3.1 : StratÃ©gie d'Estimation (Fares - Stateless)**
        - [x] CrÃ©er `FakeFareAdapter` et `RemoteFareAdapter`.
        - [x] Configurer `FareConfig` (Switch application.fare.mode).
    - [x] **3.2 : Infrastructure & Cache (Redis & SQL)**
        - [x] ImplÃ©menter `LocationCachePort` dans `RedisAdapter` (TTL 5 min).
        - [x] Configurer le Repository SQL pour `offer_driver_linkages`.
    - [x] **3.3 : ModÃ¨les de Domaine & Ports**
        - [x] CrÃ©er le record `Bid` (driverId, name, eta, latitude, longitude, rating).
        - [x] Mettre Ã  jour `Offer` pour inclure une `List<Bid>`.
    - [x] **3.4 : Services de Calcul & Tracking**
        - [x] ImplÃ©menter `EtaCalculatorService` (Logique dynamique via Redis).
        - [x] ImplÃ©menter `UpdateLocationUseCase` (Tracking acteur via JWT).
    - [x] **3.5 : Logique MÃ©tier Marketplace (Actions & Ã‰tats)**
        - [x] `CreateOfferUseCase` : Publication (PENDING).
        - [x] `GetAvailableOffersUseCase` : Liste des offres pour les chauffeurs.
        - [x] `ResponseToOfferUseCase` (Apply) : Inscription du postulant en SQL.
        - [x] `GetOfferBidsUseCase` : AgrÃ©gation rÃ©active (SQL + Redis + ETA).
        - [x] `SelectDriverUseCase` : Validation du choix passager (Passage Ã  DRIVER_SELECTED).
    - [x] **3.6 : API REST & Mapping**
        - [x] `POST /api/v1/fares/estimate` (Consultation).
        - [x] `POST /api/v1/location` (Tracking acteur).
        - [x] `GET /api/v1/offers/available` (Discovery chauffeur).
        - [x] `GET /api/v1/offers/{id}/bids` (Consultation passager).
        - [x] `PATCH /api/v1/offers/{id}/select-driver` (Action de sÃ©lection).
    - [x] **3.7 : test swagger d'un flux complet 1 client et 2 chauffeurs**

- [x] **TÃ¢che 4 : Gestion des Courses (Trips - Core Domain)**
    - [x] 4.1 : CrÃ©ation du Trip (Transition depuis l'Offre).
    - [x] 4.2 : Machine Ã  Ã©tats (CREATED -> ONGOING -> COMPLETED/CANCELLED).
    - [x] 4.3 : API de gestion d'Ã©tat (Start/End ride).
    - [x] 4.4 : RÃ¨gles mÃ©tier (Qui peut dÃ©marrer ? Qui peut finir ?).

- [x] **TÃ¢che 5 : Gestion du GPS (Tracking Temps RÃ©el)**
    - [x] 5.1 : Polling & Mise Ã  jour Redis.
    - [x] 5.2 : API de consultation Smart (Suivre son partenaire : Chauffeur <-> Passager).
    - [x] 5.3 : Calcul de distance & ETA (Service dÃ©diÃ© Haversine).

- [x] **TÃ¢che 6 : IntÃ©gration Services Externes (Switch Remote)**
    - [x] 7.1 : Test Auth Service en rÃ©el.
    - [x] 7.2 : Test Fare Calculator en rÃ©el.
    - [x] 7.3 : Gestion des Timeouts & Circuit Breakers (Resilience4j).

- [ ] **TÃ¢che 7 : Gestion des Utilisateurs (Interne)**
    - [ ] 6.1 : CRUD Admin (si nÃ©cessaire).
    - [ ] 6.2 : Profil User & Driver 
    - [ ] 6.3 : gestion de vehicules par le vehicule service

- [ ] **TÃ¢che 8 :** Services PÃ©riphÃ©riques & Notation (medias, Reviews,abonnement des chauffeurs).

- [ ] **TÃ¢che 9 : Fine-tuning & Consolidation (Post-Integration)**
    - [ ] 9.1 : Back-office Admin (CRUD complet Trips/Offers pour le support/debug).
    - [ ] 9.2 : Durcissement SÃ©curitÃ© (Rate Limiting, Renforcement JWT, Cors,gestion des roles et permissions).
    - [ ] 9.3 : Gestion Globale des Erreurs (Standardisation ProblemDetails 4xx/5xx).
    - [ ] 9.4 : Optimisation & Nettoyage (Refactoring, Logs de prod, Code mort).```

---
### Fichier : `./docs/tests/test_offer_creation.md`
```md
### Protocole de Test "1 Client + 2 Chauffeurs"

Suis ces Ã©tapes dans l'ordre exact :

#### 1. PrÃ©paration du terrain (GPS)
Il faut que les chauffeurs "existent" dans Redis pour que l'ETA puisse Ãªtre calculÃ© plus tard.
*   **Action** : Clique sur **Authorize** et saisis `driver-1-token`.
*   **Action** : Appelle `POST /api/v1/location` avec :
    ```json
    { "latitude": 3.8666, "longitude": 11.5166 }
    ```
*   **Action** : Change le token dans Authorize pour `driver-2-token`.
*   **Action** : Appelle `POST /api/v1/location` avec :
    ```json
    { "latitude": 3.8444, "longitude": 11.5000 }
    ```

#### 2. Publication de l'Offre
*   **Action** : Change le token pour `client-token`.
*   **Action** : Appelle `POST /api/v1/offers`.
    *   *Note* : Utilise le json `{
  "passengerId": "7f13909e-7170-4f91-872e-333333333333",
  "startPoint": "Bastos",
  "endPoint": "Poste Centrale",
  "price": 2500,
  "state": "PENDING"
}` dans le body pour Ãªtre raccord avec le token.
    *   **RÃ©cupÃ¨re l'ID de l'offre** crÃ©Ã© dans la rÃ©ponse.

#### 3. Bidding (Les chauffeurs postulent)
*   **Action** : Reprends le token `driver-1-token`.
*   **Action** : Appelle `POST /api/v1/offers/{id}/apply` (avec l'ID de l'offre et l'UUID driver `a1b2c3d4-e5f6-4a5b-8c9d-111111111111`).
*   **Action** : Fais de mÃªme avec le token et l'UUID du chauffeur 2 (`a1b2c3d4-e5f6-4a5b-8c9d-222222222222`).

#### 4. Consultation et SÃ©lection (Le moment de vÃ©ritÃ©)
*   **Action** : Reprends le token `client-token`.
*   **Action** : Appelle `GET /api/v1/offers/{id}/bids`.
    *   **VÃ©rification** : Tu devrais voir une liste de 2 `bids` avec les noms des chauffeurs (issus de Postgres), leurs coordonnÃ©es (issues de Redis) et un ETA (issu du service random).
*   **Action** : Appelle `PATCH /api/v1/offers/{id}/select-driver` avec l'ID d'un des chauffeurs.

---

### Points de vigilance (Debug)
*   Si le `POST /offers` Ã©choue avec une erreur de clÃ© Ã©trangÃ¨re (FK), vÃ©rifie que l'UUID du passager existe bien dans ta table `customers`.
*   Si le `GET /bids` renvoie des coordonnÃ©es `0.0`, c'est que le TTL de 5 minutes de Redis a expirÃ© ou que le token n'Ã©tait pas le bon lors du `POST /location`.
```

---
### Fichier : `./docs/tests/test_ride_annulation.md`
```md
### ðŸ§ª Comment Tester l'Annulation (Swagger)

Une fois le fichier mis Ã  jour et l'app redÃ©marrÃ©e :

#### Cas A : Le Chauffeur annule (N'importe quand)
1.  **Auth** : `driver-1-token`
2.  **Route** : `PATCH /api/v1/trips/{TRIP_ID}/status`
3.  **Body** :
    ```json
    { "status": "CANCELLED" }
    ```
4.  **RÃ©sultat** : `200 OK`, Ã©tat `CANCELLED`.

#### Cas B : Le Passager annule (Avant dÃ©part)
1.  **Auth** : `client-token`
2.  **Condition** : La course doit Ãªtre en Ã©tat `CREATED` (juste aprÃ¨s l'acceptation).
3.  **Route** : `PATCH /api/v1/trips/{TRIP_ID}/status`
4.  **Body** : `{ "status": "CANCELLED" }`
5.  **RÃ©sultat** : `200 OK`.

#### Cas C : Le Passager essaie de tricher (AprÃ¨s dÃ©part)
1.  Fais passer la course Ã  `ONGOING` avec le Chauffeur.
2.  Essaie d'annuler avec le Passager.
3.  **RÃ©sultat** : `400` ou `500` avec le message *"Too late to cancel..."*.```

---
### Fichier : `./docs/tests/full_test_offer-course.md`
```md
# ðŸ“± Guide de Test E2E : ScÃ©nario Multi-Clients

**PrÃ©requis** : Ouvre 3 onglets/fenÃªtres de ton navigateur avec Swagger.
1.  **FenÃªtre A** : Passager (Client) `uID`:`7f13909e-7170-4f91-872e-333333333333`
2.  **FenÃªtre B** : Chauffeur 1 (Eto'o - Douala) `UID`:`a1b2c3d4-e5f6-4a5b-8c9d-111111111111`
3.  **FenÃªtre C** : Chauffeur 2 (Aboubakar - YaoundÃ©) `UUID`:`a1b2c3d4-e5f6-4a5b-8c9d-222222222222`

---

## ðŸ” Phase 0 : Authentification (Sur chaque fenÃªtre)

*   **FenÃªtre A (Passager)** : Clique sur `Authorize` -> `client-token`
*   **FenÃªtre B (Chauffeur 1)** : Clique sur `Authorize` -> `driver-1-token`
*   **FenÃªtre C (Chauffeur 2)** : Clique sur `Authorize` -> `driver-2-token`

---

## ðŸ“ Phase 1 : Mise en place (GPS)
*Les chauffeurs doivent s'activer pour Ãªtre visibles.*

1.  **FenÃªtre B (Chauffeur 1)**
    *   **Route** : `POST /api/v1/location`
    *   **Body** : `{ "latitude": 3.8666, "longitude": 11.5166 }`
    *   **Attendu** : `200 OK`

2.  **FenÃªtre C (Chauffeur 2)**
    *   **Route** : `POST /api/v1/location`
    *   **Body** : `{ "latitude": 3.8444, "longitude": 11.5000 }`
    *   **Attendu** : `200 OK`

---

## ðŸŸ¢ SCÃ‰NARIO PRINCIPAL : La Course Parfaite

### Ã‰tape 1 : Le besoin (Passager)
**FenÃªtre A (Passager)**
*   **Action** : Publier une demande de course.
*   **Route** : `POST /api/v1/offers`
*   **Body** :
    ```json
    {
      "passengerId": "7f13909e-7170-4f91-872e-333333333333",
      "startPoint": "Bastos",
      "endPoint": "Poste Centrale",
      "price": 2500,
      "state": "PENDING"
    }
    ```
*   **Attendu** : `200 OK`. L'objet Offre est crÃ©Ã©.
*   ðŸ“ **NOTE L'ID DE L'OFFRE (OFFER_ID) :** `__________________________`

### Ã‰tape 2 : La dÃ©couverte (Chauffeurs)
**FenÃªtre B (Chauffeur 1)**
*   **Action** : VÃ©rifier s'il y a du boulot.
*   **Route** : `GET /api/v1/offers/available`
*   **Attendu** : Une liste JSON contenant ton `OFFER_ID`.

### Ã‰tape 3 : La candidature (Chauffeurs)
**FenÃªtre B (Chauffeur 1)**
*   **Action** : "Je suis intÃ©ressÃ©".
*   **Route** : `POST /api/v1/offers/{OFFER_ID}/apply?driverId=a1b2c3d4-e5f6-4a5b-8c9d-111111111111`
*   **Attendu** : `200 OK`.

**FenÃªtre C (Chauffeur 2)**
*   **Action** : "Moi aussi".
*   **Route** : `POST /api/v1/offers/{OFFER_ID}/apply?driverId=a1b2c3d4-e5f6-4a5b-8c9d-222222222222`
*   **Attendu** : `200 OK`.

### Ã‰tape 4 : Le Choix (Passager)
**FenÃªtre A (Passager)**
*   **Action** : Voir qui a postulÃ©.
*   **Route** : `GET /api/v1/offers/{OFFER_ID}/bids`
*   **Attendu** : Liste de 2 chauffeurs avec leurs noms et ETA calculÃ©s.

**FenÃªtre A (Passager)**
*   **Action** : Choisir Chauffeur 1 (Eto'o).
*   **Route** : `PATCH /api/v1/offers/{OFFER_ID}/select-driver?driverId=a1b2c3d4-e5f6-4a5b-8c9d-111111111111`
*   **Attendu** : `200 OK`.
    *   **VÃ©rif** : `state` doit Ãªtre **`DRIVER_SELECTED`**.

### Ã‰tape 5 : La Confirmation "Handshake" (Chauffeur 1)
*Le Chauffeur 1 reÃ§oit une notif "Vous avez Ã©tÃ© choisi". Il doit confirmer.*

**FenÃªtre B (Chauffeur 1)**
*   **Action** : "Ok, j'arrive !" (C'est ici que la Course est crÃ©Ã©e).
*   **Route** : `POST /api/v1/offers/{OFFER_ID}/accept?driverId=a1b2c3d4-e5f6-4a5b-8c9d-111111111111`
*   **Attendu** : `200 OK`. Retourne un objet **Ride**.
    *   **VÃ©rif** : `state` du Ride est `CREATED`.
*   ðŸ“ **NOTE L'ID DE LA COURSE (TRIP_ID) :** `__________________________`

### Ã‰tape 6 : L'Approche et Pickup (Chauffeur 1)
*Le chauffeur roule vers le client... Il arrive.*

**FenÃªtre B (Chauffeur 1)**
*   **Action** : "Client Ã  bord, on dÃ©marre".
*   **Route** : `PATCH /api/v1/trips/{TRIP_ID}/status`
*   **Body** : `{ "status": "ONGOING" }`
*   **Attendu** : `200 OK`. `state` passe Ã  `ONGOING`.

### Ã‰tape 7 : La Fin de Course (Chauffeur 1)
*ArrivÃ©e Ã  destination.*

**FenÃªtre B (Chauffeur 1)**
*   **Action** : "Course terminÃ©e, paiement cash".
*   **Route** : `PATCH /api/v1/trips/{TRIP_ID}/status`
*   **Body** : `{ "status": "COMPLETED" }`
*   **Attendu** : `200 OK`. `state` passe Ã  `COMPLETED`.

---

## ðŸ”´ SCÃ‰NARIO ALTERNATIF : Annulation par le Client

*Condition : Ce test se fait sur une NOUVELLE offre, avant l'Ã©tape 5 (Acceptation chauffeur).*

### Cas 1 : Annulation avant sÃ©lection
1.  **FenÃªtre A** : CrÃ©er offre (`PENDING`). Note `OFFER_ID_2`.
2.  **FenÃªtre A** : "Finalement non, j'annule".
3.  **Route** : `POST /api/v1/offers/{OFFER_ID_2}/cancel`
4.  **Attendu** : `200 OK`. `state` passe Ã  `CANCELLED`.
5.  **VÃ©rif** : Les chauffeurs ne doivent plus voir cette offre dans `/available`.

### Cas 2 : Annulation aprÃ¨s sÃ©lection (mais avant arrivÃ©e)
1.  **FenÃªtre A** : CrÃ©er offre, attendre bids, faire `select-driver` (`DRIVER_SELECTED`).
2.  **FenÃªtre A** : "Le chauffeur met trop de temps, j'annule".
3.  **Route** : `POST /api/v1/offers/{OFFER_ID_3}/cancel`
4.  **Attendu** : `200 OK`. `state` passe Ã  `CANCELLED`.
5.  **Impact** : Le chauffeur qui tente d'`accept` doit recevoir une erreur (400 ou 404).

---

## ðŸ§ª RÃ¨gles de validation technique

1.  Un chauffeur **ne peut pas** accepter une offre qui ne lui est pas destinÃ©e (Test avec FenÃªtre C essayant d'accepter l'offre de FenÃªtre B).
2.  Un passager **ne peut pas** annuler une course (`Ride`) qui est dÃ©jÃ  `ONGOING` (seul le chauffeur gÃ¨re le statut du Ride).
3.  Les IDs (`OFFER_ID`, `TRIP_ID`) doivent Ãªtre copiÃ©s-collÃ©s depuis les rÃ©ponses JSON prÃ©cÃ©dentes, ne les invente pas.```

---
### Fichier : `./docs/specs/spec.md`
```md
# ðŸ“„ SpÃ©cifications Techniques : API RIDE & GO (Sprint Express)

## 1. PrÃ©sentation du projet
**Ride & Go** est une marketplace de transport urbain (VTC/Taxi). 
*   **Le Passager (Client)** : Calcule un coÃ»t estimÃ©, publie une offre de trajet.
*   **Le Chauffeur (Driver)** : Parcourt les offres disponibles et postule (Bidding).
*   **Le SystÃ¨me** : GÃ¨re la transition de l'offre vers une course rÃ©elle (Trip) une fois le chauffeur validÃ©.
*   **Stack** : Backend Spring Boot (Architecture Hexagonale) & Frontend React Native.

---

## 2. ModÃ©lisation des donnÃ©es & Ã‰tats (English)

### A. Offer States (Annonce client)
1.  `PENDING` : Offre crÃ©Ã©e, en attente de chauffeurs.
2.  `BID_RECEIVED` : Au moins un chauffeur a postulÃ©.
3.  `DRIVER_SELECTED` : Le passager a choisi un chauffeur.
4.  `VALIDATED` : Le chauffeur a acceptÃ© le choix, l'offre devient un "Trip".
5.  `CANCELLED` : AnnulÃ©e par le client ou expiration.

### B. Trip States (La course)
1.  `CREATED` : Course initialisÃ©e, chauffeur en route vers le client.
2.  `ONGOING` : Client rÃ©cupÃ©rÃ©, trajet en cours vers la destination.
3.  `COMPLETED` : ArrivÃ©e Ã  destination, paiement confirmÃ©.
4.  `CANCELLED` : Course interrompue.

---

Voici la section 3 mise Ã  jour de faÃ§on exhaustive, en reprenant chaque action simple de ton brouillon et en y associant la route correspondante pour que ton binÃ´me et toi sachiez exactement quoi appeler Ã  chaque Ã©tape.

---

## 3. Flux Principal (User Journey & Route Mapping)

### 1. Auth : Identification des utilisateurs
*   **S'enregistrer** : Le chauffeur ou le passager crÃ©e son compte (`POST /api/auth/register`).
*   **Se connecter** : L'utilisateur accÃ¨de Ã  l'application et rÃ©cupÃ¨re son token (`POST /api/auth/login`).

### 2. Estimate : PrÃ©paration du trajet (CÃ´tÃ© Client)
*   **Calculer le coÃ»t** : Le client saisit son trajet pour obtenir une estimation via le service externe (`POST /api/fares/estimate`).

    Endpoint principal d'estimation de prix.
    
    **FlexibilitÃ© des paramÃ¨tres :**
    - Les coordonnÃ©es (`lat`/`lon`) sont **optionnelles** si un nom de lieu (`label`) est fourni.
    - L'API effectuera un gÃ©ocodage automatique si nÃ©cessaire.
    - Les paramÃ¨tres `heure`, `meteo`, `type_zone` sont **optionnels** (dÃ©tectÃ©s automatiquement si omis).
    
    **Exemple minimaliste (Noms de lieux uniquement) :**
    ```json
    {
        "depart": {"label": "Poste Centrale"},
        "arrivee": {"label": "Mvan"}
    }
    ```
    response:

    {
"depart": "string",
"arrivee": "string",
"heure": "matin",
"meteo": 3,
"type_zone": 2,
"congestion_user": 10
}

*   **Visualiser l'estimation** : Le systÃ¨me renvoie le prix suggÃ©rÃ© et la distance pour aider le client Ã  fixer son offre.

### 3. Post Offer : Publication (CÃ´tÃ© Client)
*   **CrÃ©er l'offre** : Le client publie son offre avec le prix dÃ©finitif (`POST /api/offers`). -> Ã‰tat `PENDING`.
*   **Notifier les chauffeurs** : Le systÃ¨me rend l'offre visible pour les chauffeurs aux alentours. 

### 4. Bidding : Manifestation d'intÃ©rÃªt (CÃ´tÃ© Chauffeur)
*   **Recevoir les clients** : Le chauffeur consulte la liste des offres/clients disponibles dans sa zone (`GET /api/offers/available`).
*   **Postuler Ã  une offre** : Le chauffeur choisit une offre et envoie sa candidature (`POST /api/offers/{id}/apply`). -> Ã‰tat `BID_RECEIVED`.

### 5. Selection : Validation du binÃ´me (CÃ´tÃ© Client)
*   **Recevoir les chauffeurs** : Le client consulte la liste de tous les chauffeurs qui ont postulÃ© Ã  son offre (`GET /api/offers/{id}/bids`).
*   **Valider un chauffeur** : Le client choisit son chauffeur prÃ©fÃ©rÃ© parmi la liste (`PATCH /api/offers/{id}/select-driver`). -> Ã‰tat `DRIVER_SELECTED`.

C'est un point crucial pour l'expÃ©rience utilisateur. Voici le bloc **6. Trip Execution** mis Ã  jour pour intÃ©grer explicitement le suivi GPS pendant la phase d'approche (quand le chauffeur vient chercher le client) :

---

### 6. Trip Execution : DÃ©roulement de la course

*   **Initialiser la course** : Suite Ã  la sÃ©lection, le systÃ¨me crÃ©e le contexte de trajet (`POST /api/trips`). -> Ã‰tat **`CREATED`**.
*   **Phase d'approche (Tracking)** : Pendant que le chauffeur se dÃ©place vers le point de dÃ©part pour rÃ©cupÃ©rer le client :
    *   **Envoi GPS (Chauffeur)** : Le chauffeur envoie sa position GPS en temps rÃ©el pour signaler sa progression (`POST /api/trips/{id}/location`).
    *   **Suivi de l'approche (Client)** : Le client suit en direct l'arrivÃ©e du chauffeur sur sa carte pour savoir exactement quand il sera lÃ  (`GET /api/trips/{id}/location`).
*   **DÃ©marrer le trajet (Pickup)** : Une fois le client rÃ©cupÃ©rÃ©, le chauffeur confirme le dÃ©but de la course dans l'app (`PATCH /api/trips/{id}/status` avec body `{ "status": "ONGOING" }`). -> Ã‰tat **`ONGOING`**.
*   **Phase de trajet (Tracking continu)** : Pendant que le client est Ã  bord jusqu'Ã  la destination :
    *   **Mise Ã  jour GPS** : Le chauffeur continue d'envoyer sa position (`POST /api/trips/{id}/location`).
    *   **Consultation trajet** : Le client (et le systÃ¨me) suit le bon dÃ©roulement du trajet sur la carte (`GET /api/trips/{id}/location`).
*   **Terminer le trajet** : ArrivÃ© Ã  destination, le chauffeur clÃ´ture la course pour dÃ©clencher la facturation (`PATCH /api/trips/{id}/status` avec body `{ "status": "COMPLETED" }`). -> Ã‰tat **`COMPLETED`**.

---

**Astuce pour le code :**
Dans vos applications mobiles (React Native), utilisez un `setInterval` de **5 secondes** :
1.  **CÃ´tÃ© Chauffeur** : Pour appeler le `POST` de localisation.
2.  **CÃ´tÃ© Client** : Pour appeler le `GET` de localisation et mettre Ã  jour le marqueur (icÃ´ne voiture) sur la carte.

---

## 4. Contrats d'API (RequÃªtes & RÃ©ponses)

### I. Authentification (Service Externe)

**POST** `/api/auth/register`
*Request Body:*
```json
{
"username": "string",
"password": "stringst",
"email": "string",
"phone": "stringst",
"firstName": "string",
"lastName": "string",
"service": "RIDE_AND_GO",
"roles": [
    "string"
]
}
```
*Response (201):*
```json
{
"accessToken": "string",
"refreshToken": "string",
"user": {
    "id": "string",
    "username": "string",
    "email": "string",
    "phone": "string",
    "firstName": "string",
    "lastName": "string",
    "service": "LETS_GO",
    "roles": [
    "string"
    ],
    "permissions": [
    "string"
    ]
}
}
```

**POST** `/api/auth/login`
*Request Body:*
```json
{
"identifier": "nomo",
"password": "gabriel123"
}
```
*Response (200):*
```json
{
"accessToken": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiIxMjU1YTgyMy1iNWE0LTQ3MzEtOGQ2OC1iZGY0ZTM2MmMwYjciLCJzdWIiOiJmMGExMjQ2NC0zZGY1LTQ5NDgtYjIzMi1lNGMwYjBhMWZmOGQiLCJpc3MiOiJhdXRoLXNlcnZpY2UiLCJ1c2VybmFtZSI6Im5vbW8iLCJwZXJtaXNzaW9ucyI6W10sInJvbGVzIjpbIkFETUlOIl0sImlhdCI6MTc2Njk5NTI0MSwiZXhwIjoxNzY2OTk2MTQxfQ.XuUaVcZXuZpgxY_sT3vnVBSSnhdACljfU4d8trrI0j4",
"refreshToken": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjMzAzMTE1Ni02MzRkLTRlMGQtODA3Yi1mZTliMmQ4NWY2ZTgiLCJzdWIiOiJmMGExMjQ2NC0zZGY1LTQ5NDgtYjIzMi1lNGMwYjBhMWZmOGQiLCJpc3MiOiJhdXRoLXNlcnZpY2UiLCJpYXQiOjE3NjY5OTUyNDEsImV4cCI6MTc2OTU4NzI0MX0.lPakd_x7ckCI2az32ni1dAcs8ut-9MmcjfCLPySC4Zg",
"user": {
    "id": "f0a12464-3df5-4948-b232-e4c0b0a1ff8d",
    "username": "nomo",
    "email": "gabriel@test.com",
    "phone": "612345678",
    "firstName": "gabriel",
    "lastName": "gabriel",
    "service": "LETS_GO",
    "roles": [
    "ADMIN"
    ],
    "permissions": []
}
}

refresh token `/api/auth/refresh`

`json
    {
"refreshToken": "string"
}
`
```

---

### II. Calcul des coÃ»ts (Service Externe / Fallback)


**POST** `/api/fares/estimate`
Endpoint principal d'estimation de prix.
    
    **FlexibilitÃ© des paramÃ¨tres :**
    - Les coordonnÃ©es (`lat`/`lon`) sont **optionnelles** si un nom de lieu (`label`) est fourni.
    - L'API effectuera un gÃ©ocodage automatique si nÃ©cessaire.
    - Les paramÃ¨tres `heure`, `meteo`, `type_zone` sont **optionnels** (dÃ©tectÃ©s automatiquement si omis).
    
    **Exemple minimaliste (Noms de lieux uniquement) :**
    ```json
    {
        "depart": {"label": "Poste Centrale"},
        "arrivee": {"label": "Mvan"}
    }
    ```
*Request Body:*
```json
{
"depart": "string",
"arrivee": "string",
"heure": "matin",
"meteo": 3,
"type_zone": 2,
"congestion_user": 10
}
```
*Response (200):*
```json
{
"statut": "exact",
"prix_moyen": 0,
"prix_min": 0,
"prix_max": 0,
"distance": 0,
"duree": 0,
"estimations_supplementaires": {
    "ml_prediction": 0,
    "features_utilisees": {
    "distance_metres": 0,
    "duree_secondes": 0,
    "congestion": 0,
    "sinuosite": 0,
    "nb_virages": 0,
    "heure": "string",
    "meteo": 0,
    "type_zone": 0
    }
},
"ajustements_appliques": {
    "additionalProp1": "string",
    "additionalProp2": "string",
    "additionalProp3": "string"
},
"fiabilite": 1,
"message": "string",
"details_trajet": {
    "additionalProp1": "string",
    "additionalProp2": "string",
    "additionalProp3": "string"
},
"suggestions": [
    "string"
]
}
```

---

### III. Gestion des Offres (CÃ´tÃ© Passager)

**POST** `/api/offers`
*Request Body:*
```json
{
"passengerId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
"startPoint": "string",
"endPoint": "string",
"price": 0,
"state": "NEW"
}
```
*Response (201):*
```json
{
"id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
"passengerId": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
"startPoint": "string",
"endPoint": "string",
"price": 0,
"state": "NEW",
"interestedDrivers": [
    "3fa85f64-5717-4562-b3fc-2c963f66afa6"
]
}
```

**GET** `/api/offers/{id}/bids`
*Response (200):*
```json
[
{
    "driverId": "uuid-driver-1",
    "driverName": "Eto'o Fils",
    "carModel": "Toyota Avensis",
    "rating": 4.8,
    "eta": "5 min"
},
{
    "driverId": "uuid-driver-2",
    "driverName": "Aboubakar",
    "carModel": "Hyundai Elantra",
    "rating": 4.5,
    "eta": "8 min"
}
] // a bien concevoir
```

**PATCH** `/api/offers/{id}/select-driver`
voir image piece jointe
```

---

### IV. Gestion des Offres (CÃ´tÃ© Chauffeur)

**GET** `/api/offers/available`
*Response (200):*
```json
[
{
    "id": "uuid-offer-1",
    "origin": "Bastos",
    "destination": "Poste",
    "price": 2500,
    "timestamp": "2025-12-29T10:00:00Z"
}
]
```

**POST** `/api/offers/{id}/apply`
*Request Body:*
```json
{
"driverId": "uuid-driver",
"estimatedArrivalTime": 6 // temps en minutes
}
```
*Response (200):*
```json
{
"message": "Application successful",
"status": "BID_RECEIVED"
}
```

---

### V. ExÃ©cution de la Course (Trips)

**POST** `/api/trips`
*Request Body (AutomatisÃ© aprÃ¨s validation offre):*
```json
{
"offerId": "uuid-offer",
"driverId": "uuid-driver"
}
```
*Response (201):*
```json
{
"tripId": "uuid-trip",
"status": "CREATED"
}
```

**PATCH** `/api/trips/{id}/status`
*Request Body:*
```json
{
"status": "ONGOING"
}
```
*Response (200):*
```json
{
"tripId": "uuid-trip",
"currentStatus": "ONGOING"
}
```

**POST** `/api/trips/{id}/location`
*Request Body:*
```json
{
"latitude": 3.8485,
"longitude": 11.5021
}
```
*Response (200):*
```json
{ "status": "Location updated" }
```

**GET** `/api/trips/{id}/location`
*Response (200):*
```json
{
"latitude": 3.8485,
"longitude": 11.5021,
"updatedAt": "2025-12-29T10:15:00Z"
}
```

---

## 5. Liste rÃ©capitulative pour le Swagger
Organise tes contrÃ´leurs avec ces tags :
1.  **Auth-Service** : Inscription et Connexion.
2.  **Fare-Calculator** : Estimation du prix.
3.  **Offer-Controller** : CrÃ©ation, listing des offres disponibles, bidding (apply), et sÃ©lection du chauffeur.
4.  **Trip-Controller** : Initialisation du trajet, mise Ã  jour du statut (CREATED/ONGOING/COMPLETED) et tracking GPS.

---

## ðŸ’¡ Suggestions techniques

*   **Mock data** : Pour l'API de coÃ»t, si le service externe rÃ©pond avec une erreur (500), fais en sorte que ton backend renvoie un prix par dÃ©faut (ex: 2000 XAF) pour ne pas bloquer les tests frontend.
*   **Validation Spring** : Utilise `@NotBlank` et `@Size` sur tes DTOs pour valider les JSON de "Register".
*   **React Native** : Utilise un intervalle (setInterval) ou une petite lib de polling pour le `GET /location` afin de simuler le dÃ©placement de la voiture sur la carte du passager.

Bon code Ã  vous deux ! N'hÃ©site pas si tu as besoin d'un script `curl` pour tester une de ces routes.
---

# ðŸ§  Business Rules (Frontend-Oriented)

Cette section dÃ©finit **les rÃ¨gles mÃ©tier immuables** que le frontend doit respecter et faire appliquer via lâ€™API.

---

## 1. RÃ¨gles liÃ©es aux Offres (Offers)

1. **Postulation chauffeur**

* Un chauffeur **ne peut postuler quâ€™une seule fois** Ã  une mÃªme offre.
* Toute tentative multiple doit Ãªtre ignorÃ©e cÃ´tÃ© frontend (dÃ©sactivation du bouton).

2. **Modification du choix chauffeur**

* Une fois un chauffeur sÃ©lectionnÃ© par le client (`DRIVER_SELECTED`),
    **le choix nâ€™est plus modifiable**.
* Le frontend ne doit plus afficher la liste des chauffeurs aprÃ¨s validation.

3. **Expiration dâ€™une offre**

* Une offre **expire automatiquement aprÃ¨s 5 minutes** si aucun chauffeur nâ€™est sÃ©lectionnÃ©.
* Ã‰tat final : `CANCELLED`.
* Le frontend doit afficher un message :
    **Â« Aucune rÃ©ponse reÃ§ue. Lâ€™offre a expirÃ©. Â»**

4. **Annulation dâ€™une offre**

* Lâ€™offre peut Ãªtre annulÃ©e :

    * par le **client**
    * par le **chauffeur sÃ©lectionnÃ©**
* Lâ€™annulation nâ€™est possible **uniquement avant le dÃ©but de la course** (`CREATED`).
* AprÃ¨s dÃ©marrage (`ONGOING`), lâ€™annulation nâ€™est plus permise.

---

## 2. RÃ¨gles liÃ©es aux Courses (Trips)

1. **CrÃ©ation de la course**

* Une course (`Trip`) est crÃ©Ã©e **uniquement aprÃ¨s** :

    * sÃ©lection du chauffeur par le client
    * acceptation implicite du chauffeur
* Ã‰tat initial : `CREATED`.

2. **Paiement**

* **Aucun paiement nâ€™est effectuÃ© via lâ€™application**.
* Le paiement est effectuÃ© **en cash**, **aprÃ¨s la course**, **hors systÃ¨me**.
* Lâ€™Ã©tat `COMPLETED` signifie uniquement :

    * trajet terminÃ©
    * pas une confirmation de paiement Ã©lectronique.

3. **DÃ©marrage de la course**

* Seul le **chauffeur** peut dÃ©clencher le passage Ã  `ONGOING`.
* Le frontend client passe alors en mode **suivi trajet actif**.

4. **Fin de la course**

* Seul le **chauffeur** peut clÃ´turer la course (`COMPLETED`).
* Une fois `COMPLETED`, la course devient **en lecture seule** cÃ´tÃ© frontend.

---

## 3. RÃ¨gles de Tracking GPS

1. **Avant pickup (Approche)**

* Le chauffeur envoie sa position toutes les 5 secondes.
* Le client voit la progression en temps rÃ©el.

2. **Pendant le trajet**

* Le tracking continue jusquâ€™Ã  `COMPLETED`.

3. **ResponsabilitÃ© frontend**

* Le frontend **doit gÃ©rer le polling** (`setInterval`).
* Aucune logique temps rÃ©el (WebSocket) nâ€™est requise Ã  ce stade.

---

# âš ï¸ Gestion des Erreurs (Frontend Contract)

Cette section dÃ©finit **le comportement standard du frontend en cas dâ€™erreur backend**.

---

## 1. ModÃ¨le de rÃ©ponse dâ€™erreur attendu

Le backend renvoie une erreur JSON standardisÃ©e :

```json
{
"timestamp": "2025-12-29T10:30:00Z",
"status": 400,
"error": "Bad Request",
"message": "Offer already expired",
"path": "/api/offers/123/apply"
}
```

---

## 2. Comportement du Frontend

1. **Aucune logique mÃ©tier cÃ´tÃ© frontend**

* Le frontend **ne tente pas dâ€™interprÃ©ter le type dâ€™erreur**.
* Il ne distingue pas `400`, `403`, `409`, etc.

2. **Affichage utilisateur**

* En cas dâ€™erreur backend :

    * afficher un message gÃ©nÃ©rique :

    > **Â« Une erreur est survenue Â»**
    * afficher ensuite le message retournÃ© par le backend :

    > `error.message`

3. **Aucune action automatique**

* Le frontend :

    * ne retry pas automatiquement
    * ne change pas dâ€™Ã©tat local
    * attend une action utilisateur

---

## 3. Exemple de traitement Frontend (Conceptuel)

```ts
try {
await api.call()
} catch (error) {
showToast("Une erreur est survenue")
showToast(error.message)
}
```

*(Exemple conceptuel â€“ non contractuel)*
```

---
### Fichier : `./docs/bd/modifs.md`
```md
-cretaion de la tabble user_has_rpermissions
-modification des enums offers et ride
-ajout du mappig de conversion des enums
-modification de offer_driver_linkages```

---
### Fichier : `./docs/prompts/master_pair_programmer.md`
```md
# ðŸ¤– Master Prompt : Senior Pair Programmer WebFlux

Tu es mon Senior Pair Programmer expert en Java **Spring Boot WebFlux (RÃ©actif)**.
Nous dÃ©veloppons l'API *Ride and go* (Projet TraEnSys).

### ðŸ“‹ Ta MÃ©thode de Travail (IMPÃ‰RATIF)
Pour chaque tÃ¢che demandÃ©e, tu dois obligatoirement suivre ces Ã©tapes :

**Ã‰tape 1 : Conception fonctionnelle**
- Analyse du besoin, user stories et ajustement du modÃ¨le de donnÃ©es.
- **Attente de ma validation explicite avant d'aller plus loin.**

**Ã‰tape 2 : Explication du Concept RÃ©actif**
- Avant de coder, explique briÃ¨vement comment le flux rÃ©actif (`Mono`/`Flux`) sera gÃ©rÃ© pour cette tÃ¢che.

**Ã‰tape 3 : ImplÃ©mentation**
- Fournis le code complet par blocs Markdown copiables.
- Respecte l'architecture hexagonale du projet.

**Ã‰tape 4 : Tests & Validation**
- Instructions pour tester via swagger.

### ðŸš« Tes RÃ¨gles de Conduite
1. **ZÃ©ro code non sollicitÃ©** : Ne propose aucune solution technique avant l'Ã‰tape 3.
2. **Focus** : RÃ©ponds uniquement Ã  la question posÃ©e, de maniÃ¨re synthÃ©tique et prÃ©cise.
3. **Fichiers complets** : Sauf mention contraire, donne toujours le code complet du fichier pour Ã©viter les erreurs de copier-coller.
4. **PÃ©dagogie** : Si une opÃ©ration risque de bloquer un thread (ex: JDBC classique, thread sleep), arrÃªte-moi et propose l'alternative non-bloquante.

### ðŸ“‚ Contexte
Le code source complet est disponible dans le fichier `project_context.txt`.
La roadmap est suivie dans `todo.md`.
 les sepcifications sont dans le fichier spec.md

 je te fournis en entree le cahier de charges du proejt(spec.md) et l'etat actuel du contexte. les servcies a integrer seront pour le moment auth et farecalculator qui viennent d'api externes mais le application.yml pour gerrer des fake datas quand le service distant est indisponible. par exemple a partir d'une cle mode.

 acteuelement,on debogue les routes des offres via le swagger.je te fpurnis l'erreru on resoud ca et on continuera d'vancer dans la todo```

---
### Fichier : `./src/test/java/com/yowyob/reactive_hexagonal/ReactiveHexagonalApplicationTests.java`
```java
package com.yowyob.reactive_hexagonal;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ReactiveHexagonalApplicationTests {

	@Test
	void contextLoads() {
	}

}
```

---
### Fichier : `./src/main/resources/local/data.sql`
```sql
-- =====================================================
-- YOWYOB DB - DATA SEEDING SCRIPT
-- PostgreSQL
-- =====================================================

-- =====================================================
-- 1. CLEANUP EXISTING DATA
-- =====================================================
TRUNCATE TABLE 
    users, images, countries, business_actors, 
    admins, fleet_managers, drivers, customers, 
    providers, employees, prospects, sales_persons,
    profiles, settings, addresses, contacts,
    roles, permissions, role_has_permissions, user_has_permissions, user_has_roles,
    organizations, agencies, business_domains, organization_business_domains,
    certifications, third_parties, proposed_activities, services, branches,
    fleets, vehicles, geofence_zones, geofence_points, geofence_events,
    roads, trips, offers, rides, reviews, offer_driver_linkages,
    operational_parameters, financial_parameters, maintenance_parameters,
    geofence_point_zone_linkages,
    syndicats, abstract_products, products, 
    publications, publication_images, publication_votes, votes,
    events, event_images, reactions, comments, avis,
    subscriptions, payments
    RESTART IDENTITY CASCADE;

-- =====================================================
-- 2. STATIC REFERENCE DATA
-- =====================================================

-- Countries
INSERT INTO countries (name, code) VALUES
('Cameroun', 'CM'), ('SÃ©nÃ©gal', 'SN'), ('CÃ´te d''Ivoire', 'CI'), 
('Gabon', 'GA'), ('NigÃ©ria', 'NG'), ('Togo', 'TG');

-- Roles
INSERT INTO roles (name, guard_name) VALUES
('ADMIN', 'web'), ('FLEET_MANAGER', 'web'), ('DRIVER', 'web'), ('CUSTOMER', 'web');

-- Images
INSERT INTO images (url, alt_text) 
SELECT 
    'https://picsum.photos/seed/' || i || '/800/600', 
    'Image alÃ©atoire ' || i
FROM generate_series(1, 50) as i;

-- =====================================================
-- 3. USERS GENERATION
-- =====================================================

-- 3.1 GOLDEN USERS (Pour les tests Swagger avec Tokens fixes)
-- Client (7f13909e...)
INSERT INTO users (id, name, phone_number, email_address) VALUES 
('7f13909e-7170-4f91-872e-333333333333', 'Test Client', '+237600000001', 'client@test.com');

-- Driver 1 (a1b2c3d4...1111)
INSERT INTO users (id, name, phone_number, email_address) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'Eto''o Fils', '+237600000002', 'etoo@test.com');

-- Driver 2 (a1b2c3d4...2222)
INSERT INTO users (id, name, phone_number, email_address) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', 'Aboubakar V', '+237600000003', 'aboubakar@test.com');


-- 3.2 RANDOM USERS (97 autres pour faire masse)
INSERT INTO users (name, phone_number, email_address)
SELECT 
    (ARRAY['Mamadou', 'Jean-Pierre', 'Ibrahim', 'Fatou', 'Aminata', 'Ngolo', 'Clarisse', 'Samuel', 'KouamÃ©', 'Aissatou', 'Bachelard', 'Landry', 'ThÃ©rÃ¨se'])[floor(random()*13)+1] 
    || ' ' || 
    (ARRAY['Diop', 'Njoya', 'Mbarga', 'Kone', 'Sow', 'Etoundi', 'Kamga', 'TraorÃ©', 'Diallo', 'Fofana', 'Mensah', 'Atangana', 'Drogba'])[floor(random()*13)+1],
    (ARRAY['+237', '+221', '+225'])[floor(random()*3)+1] || (600000000 + floor(random()*99999999)::int),
    'user_' || i || '@yowyob.test'
FROM generate_series(1, 97) as i;

-- Settings & Profiles
INSERT INTO settings (user_id, theme, language, receive_push_notifications)
SELECT id, 'LIGHT', 'fr', true FROM users;

INSERT INTO profiles (user_id, first_name, nationality, is_verified)
SELECT id, split_part(name, ' ', 1), 'Camerounais', (random() > 0.5) FROM users;

-- =====================================================
-- 4. ACTORS DISPATCHING
-- =====================================================

-- 4.1 Golden Users Dispatching
-- Client -> Customer
INSERT INTO customers (id, code, payment_method) VALUES 
('7f13909e-7170-4f91-872e-333333333333', 'CUST-TEST', 'CASH');

-- Drivers -> BusinessActor + Driver
INSERT INTO business_actors (id, name, phone_number, email_address) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'Eto''o Fils', '+237600000002', 'etoo@test.com'),
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', 'Aboubakar V', '+237600000003', 'aboubakar@test.com');

INSERT INTO drivers (id, status, license_number, has_car) VALUES 
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'AVAILABLE', 'LIC-ETOO-09', true),
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', 'AVAILABLE', 'LIC-ABOU-10', true);

-- Assign Roles for Golden Users
INSERT INTO user_has_roles (user_id, role_id) VALUES 
('7f13909e-7170-4f91-872e-333333333333', (SELECT id FROM roles WHERE name = 'CUSTOMER')),
('a1b2c3d4-e5f6-4a5b-8c9d-111111111111', (SELECT id FROM roles WHERE name = 'DRIVER')),
('a1b2c3d4-e5f6-4a5b-8c9d-222222222222', (SELECT id FROM roles WHERE name = 'DRIVER'));


-- 4.2 Random Users Dispatching
-- Admins (Next 5)
INSERT INTO admins (id, name, email_address)
SELECT id, name, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 5;

-- Fleet Managers (Next 5)
INSERT INTO business_actors (id, name, phone_number, email_address)
SELECT id, name, phone_number, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 5 OFFSET 5;

INSERT INTO fleet_managers (id, name, email_address)
SELECT id, name, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 5 OFFSET 5;

-- Drivers (Next 30)
INSERT INTO business_actors (id, name, phone_number, email_address)
SELECT id, name, phone_number, email_address FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 30 OFFSET 10;

INSERT INTO drivers (id, status, license_number, has_car)
SELECT 
    id, 
    (ARRAY['AVAILABLE', 'BUSY', 'OFFLINE'])[floor(random()*3)+1], 
    'LIC-' || floor(random()*100000) || '-CM',
    (random() > 0.3)
FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
ORDER BY email_address LIMIT 30 OFFSET 10;

-- Customers (Remaining)
INSERT INTO customers (id, code, payment_method)
SELECT 
    id, 
    'CUST-' || substr(id::text, 1, 8),
    (ARRAY['CASH', 'MOBILE_MONEY', 'CARD'])[floor(random()*3)+1]
FROM users 
WHERE id NOT IN ('7f13909e-7170-4f91-872e-333333333333', 'a1b2c3d4-e5f6-4a5b-8c9d-111111111111', 'a1b2c3d4-e5f6-4a5b-8c9d-222222222222')
AND id NOT IN (SELECT id FROM admins)
AND id NOT IN (SELECT id FROM fleet_managers)
AND id NOT IN (SELECT id FROM drivers);

-- Roles assignment (generic) omitted for brevity as handled above logic, 
-- but ensuring 'user_has_roles' is filled for everyone is good practice.

-- =====================================================
-- 5. ORGANIZATIONS & AGENCIES
-- =====================================================

INSERT INTO organizations (
    business_actor_id, logo_id, code, short_name, long_name, 
    description, tax_number, is_active, status
)
SELECT
    (SELECT id FROM fleet_managers ORDER BY random() LIMIT 1),
    (SELECT id FROM images ORDER BY random() LIMIT 1),
    'ORG-' || i,
    'Transport ' || i,
    'SociÃ©tÃ© de Transport ' || i,
    'Description ' || i,
    'TAX-' || floor(random()*1000000),
    true,
    'PUBLISHED'
FROM generate_series(1, 35) as i;

INSERT INTO agencies (
    organization_id, manager_id, name, city, location, is_headquarter
)
SELECT 
    id, 
    (SELECT id FROM fleet_managers ORDER BY random() LIMIT 1),
    'Agence Centrale',
    (ARRAY['Douala', 'YaoundÃ©', 'Abidjan'])[floor(random()*3)+1],
    'Rue Principale',
    true
FROM organizations;

-- =====================================================
-- 6. FLEETS & VEHICLES
-- =====================================================

INSERT INTO fleets (fleet_manager_id, name, phone_number)
SELECT 
    id, 'Flotte de ' || name, '+237699000000'
FROM fleet_managers;

INSERT INTO vehicles (
    fleet_id, user_id, driver_id, license_plate, brand, model, type, color, manufacturing_year
)
SELECT 
    f.id,
    f.fleet_manager_id,
    (SELECT id FROM drivers ORDER BY random() LIMIT 1),
    'LT-' || floor(random()*999)::text || '-AA',
    (ARRAY['Toyota', 'Peugeot'])[floor(random()*2)+1],
    (ARRAY['Yaris', 'Partner'])[floor(random()*2)+1],
    (ARRAY['CAR', 'VAN'])[floor(random()*2)+1]::vehicle_type_enum,
    'Jaune',
    2020
FROM fleets f;

-- =====================================================
-- 7. OFFERS & RIDES (UPDATED)
-- =====================================================

INSERT INTO offers (
    passenger_id, start_point, end_point, price, state, created_at
)
SELECT 
    (SELECT id FROM customers ORDER BY random() LIMIT 1),
    'Point A', 'Point B', 
    2000, 
    'VALIDATED', -- UPDATE: 'CHOSEN' n'existe plus, remplacÃ© par 'VALIDATED'
    NOW()
FROM generate_series(1, 60) as i;

-- Rides
INSERT INTO rides (
    offer_id, passenger_id, driver_id, 
    distance, time_estimation, real_time, state, created_at
)
SELECT 
    id, 
    passenger_id,
    (SELECT id FROM drivers ORDER BY random() LIMIT 1),
    15.5, 30, 35,
    'COMPLETED',
    created_at
FROM offers 
LIMIT 40;

-- Reviews
INSERT INTO reviews (ride_id, author_id, subject, comment, rating)
SELECT 
    id,
    passenger_id,
    'Chauffeur',
    'Bonne course, chauffeur ponctuel',
    5
FROM rides
WHERE state = 'COMPLETED';

-- =====================================================
-- 8. PRODUCTS
-- =====================================================
-- (Le reste est identique, l'Ã©tat 'PUBLISHED' est valide pour status_enum)

INSERT INTO products (
    organization_id, name, description, standard_price, 
    status, is_active, departure_location
)
SELECT 
    (SELECT id FROM organizations ORDER BY random() LIMIT 1),
    'Trajet SpÃ©cial ' || i,
    'Description produit',
    5000,
    'PUBLISHED',
    true,
    'Douala'
FROM generate_series(1, 40) as i;

-- =====================================================
-- 9. SUBSCRIPTIONS & PAYMENTS
-- =====================================================

INSERT INTO subscriptions (
    admin_id, label, price, duration_in_days, description, is_active
) VALUES 
((SELECT id FROM admins LIMIT 1), 'Pack Hebdo', 2500, 7, 'Standard', true),
((SELECT id FROM admins LIMIT 1), 'Pack Mensuel', 10000, 30, 'Pro', true),
((SELECT id FROM admins LIMIT 1), 'Pack Annuel', 100000, 365, 'VIP', true);

INSERT INTO payments (
    driver_id, user_id, subscription_id, amount_paid, status, id_provider_transaction, created_at
)
SELECT 
    d.id, -- Driver ID
    d.id, -- Payer ID
    s.id, -- Subscription ID
    s.price,
    'SUCCESS',
    'TXN-' || floor(random()*10000000),
    NOW()
FROM drivers d
CROSS JOIN subscriptions s
ORDER BY random()
LIMIT 50;

-- =====================================================
-- 10. SOCIAL & ADDRESSES
-- =====================================================

INSERT INTO syndicats (organization_id, name, is_approved)
SELECT id, 'Syndicat Transports', true FROM organizations LIMIT 1;

INSERT INTO branches (id, syndicat_id, name, location)
SELECT 
    ag.id,
    (SELECT id FROM syndicats LIMIT 1),
    'Branche ' || ag.name, 
    ag.location 
FROM agencies ag 
LIMIT 10;

INSERT INTO publications (branch_id, author_id, content, status, n_likes)
SELECT 
    (SELECT id FROM branches ORDER BY random() LIMIT 1),
    (SELECT id FROM admins ORDER BY random() LIMIT 1),
    'Info Trafic ' || i,
    'PUBLISHED',
    floor(random() * 50)::int
FROM generate_series(1, 40) as i;

-- =====================================================
-- SEEDING DIRECT PERMISSIONS
-- =====================================================

INSERT INTO permissions (id, name) VALUES 
(uuid_generate_v4(), 'extra:special_access'),
(uuid_generate_v4(), 'fleet:emergency_stop');

INSERT INTO user_has_permissions (user_id, permission_id)
VALUES (
    (SELECT id FROM users ORDER BY email_address LIMIT 1),
    (SELECT id FROM permissions WHERE name = 'extra:special_access' LIMIT 1)
);```

---
### Fichier : `./src/main/resources/local/schema.sql`
```sql
-- =====================================================
-- YOWYOB DB - INIT SCRIPT
-- PostgreSQL
-- Structure: Core -> Organization -> RBAC
-- =====================================================

-- Clean up existing tables and types to ensure a fresh start
-- We drop them in reverse order of dependency
DROP TABLE IF EXISTS user_has_roles CASCADE;
DROP TABLE IF EXISTS role_has_permissions CASCADE;
DROP TABLE IF EXISTS permissions CASCADE;
DROP TABLE IF EXISTS roles CASCADE;
DROP TABLE IF EXISTS reviews CASCADE;
DROP TABLE IF EXISTS payments CASCADE;
DROP TABLE IF EXISTS subscriptions CASCADE;
DROP TABLE IF EXISTS admins CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;
DROP TABLE IF EXISTS comments CASCADE;
DROP TABLE IF EXISTS reactions CASCADE;
DROP TABLE IF EXISTS event_images CASCADE;
DROP TABLE IF EXISTS events CASCADE;
DROP TABLE IF EXISTS publication_images CASCADE;
DROP TABLE IF EXISTS publications CASCADE;
DROP TABLE IF EXISTS branches CASCADE;
DROP TABLE IF EXISTS avis CASCADE;
DROP TABLE IF EXISTS votes CASCADE;
DROP TABLE IF EXISTS publication_votes CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS abstract_products CASCADE;
DROP TABLE IF EXISTS syndicats CASCADE;
DROP TABLE IF EXISTS offer_driver_linkages CASCADE;
DROP TABLE IF EXISTS geofence_events CASCADE;
DROP TABLE IF EXISTS geofence_point_zone_linkages CASCADE;
DROP TABLE IF EXISTS geofence_points CASCADE;
DROP TABLE IF EXISTS maintenance_parameters CASCADE;
DROP TABLE IF EXISTS financial_parameters CASCADE;
DROP TABLE IF EXISTS operational_parameters CASCADE;
DROP TABLE IF EXISTS trips CASCADE;
DROP TABLE IF EXISTS roads CASCADE;
DROP TABLE IF EXISTS vehicles CASCADE;
DROP TABLE IF EXISTS geofence_zones CASCADE;
DROP TABLE IF EXISTS fleets CASCADE;
DROP TABLE IF EXISTS fleet_managers CASCADE;
DROP TABLE IF EXISTS rides CASCADE;
DROP TABLE IF EXISTS offers CASCADE;
DROP TABLE IF EXISTS drivers CASCADE;
DROP TABLE IF EXISTS services CASCADE;
DROP TABLE IF EXISTS customers CASCADE;
DROP TABLE IF EXISTS sales_persons CASCADE;
DROP TABLE IF EXISTS prospects CASCADE;
DROP TABLE IF EXISTS employees CASCADE;
DROP TABLE IF EXISTS providers CASCADE;
DROP TABLE IF EXISTS addresses CASCADE;
DROP TABLE IF EXISTS proposed_activities CASCADE;
DROP TABLE IF EXISTS settings CASCADE;
DROP TABLE IF EXISTS third_parties CASCADE;
DROP TABLE IF EXISTS certifications CASCADE;
DROP TABLE IF EXISTS organization_business_domains CASCADE;
DROP TABLE IF EXISTS contacts CASCADE;
DROP TABLE IF EXISTS business_domains CASCADE;
DROP TABLE IF EXISTS agencies CASCADE;
DROP TABLE IF EXISTS organizations CASCADE;
DROP TABLE IF EXISTS business_actors CASCADE;
DROP TABLE IF EXISTS countries CASCADE;
DROP TABLE IF EXISTS images CASCADE;
DROP TABLE IF EXISTS users CASCADE;

-- Drop existing types
DROP TYPE IF EXISTS reaction_type_enum CASCADE;
DROP TYPE IF EXISTS type_enum CASCADE;
DROP TYPE IF EXISTS role_type_enum CASCADE;
DROP TYPE IF EXISTS engine_status_enum CASCADE;
DROP TYPE IF EXISTS maintenance_status_enum CASCADE;
DROP TYPE IF EXISTS event_type_enum CASCADE;
DROP TYPE IF EXISTS ride_state_enum CASCADE;
DROP TYPE IF EXISTS offer_state_enum CASCADE;
DROP TYPE IF EXISTS vehicle_type_enum CASCADE;
DROP TYPE IF EXISTS action_enum CASCADE;
DROP TYPE IF EXISTS category_enum CASCADE;
DROP TYPE IF EXISTS status_enum CASCADE;

-- Re-enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";


-- =====================================================
-- ENUM TYPES
-- =====================================================

CREATE TYPE status_enum AS ENUM (
  'DRAFT', 'WAITING_CONFIRMATION', 'PUBLISHED', 'IN_PROGRESS', 'CANCELLED', 'EXPIRED'
);

CREATE TYPE category_enum AS ENUM (
  'ANNOUNCE', 'PLANNING', 'VEHICLE', 'ADDRESS', 'EXPERIENCE'
);

CREATE TYPE action_enum AS ENUM (
  'CREATE', 'UPDATE', 'READ', 'DELETE'
);

CREATE TYPE vehicle_type_enum AS ENUM (
  'CAR', 'VAN', 'TRUCK', 'BIKE'
);

CREATE TYPE offer_state_enum AS ENUM (
  'PENDING', 
  'BID_RECEIVED', 
  'DRIVER_SELECTED', 
  'VALIDATED', 
  'CANCELLED'
);

CREATE TYPE ride_state_enum AS ENUM (
  'CREATED', 
  'ONGOING', 
  'COMPLETED', 
  'CANCELLED'
);

CREATE TYPE event_type_enum AS ENUM (
  'ENTRY', 'EXIT'
);

CREATE TYPE maintenance_status_enum AS ENUM (
  'UP_TO_DATE', 'PENDING', 'OVERDUE'
);

CREATE TYPE engine_status_enum AS ENUM (
  'OK', 'NEED_SERVICE', 'OUT_OF_SERVICE'
);

CREATE TYPE role_type_enum AS ENUM (
  'CUSTOMER', 'DRIVER', 'FLEET_MANAGER', 'ADMIN', 'PASSENGER', 'PRESIDENT', 'MODERATOR', 'CLIENT'
);

CREATE TYPE type_enum AS ENUM (
  'NOTIFICATION', 'CHAT', 'PAYMENT', 'MEDIA'
);

CREATE TYPE reaction_type_enum AS ENUM (
  'LIKE', 'LOVE', 'HAHA', 'WOW', 'SAD', 'ANGRY'
);


-- =====================================================
-- FIX: IMPLICIT CASTS (MANDATORY FOR R2DBC)
-- =====================================================
-- Cela permet Ã  Spring d'envoyer "PENDING" (String) et Ã  Postgres de le comprendre comme un Enum
CREATE CAST (character varying as offer_state_enum) WITH INOUT AS IMPLICIT;
CREATE CAST (character varying as ride_state_enum) WITH INOUT AS IMPLICIT;
CREATE CAST (character varying as role_type_enum) WITH INOUT AS IMPLICIT;
CREATE CAST (character varying as vehicle_type_enum) WITH INOUT AS IMPLICIT;

-- =====================================================
-- CORE TABLES
-- =====================================================

CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  phone_number TEXT,
  email_address TEXT UNIQUE
);

CREATE TABLE images (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  url TEXT NOT NULL,
  alt_text TEXT,
  uploaded_at TIMESTAMP DEFAULT now()
);

CREATE TABLE countries (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  code TEXT NOT NULL UNIQUE,
  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE business_actors (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT,
  phone_number TEXT,
  email_address TEXT,
  CONSTRAINT fk_business_actor_user
    FOREIGN KEY (id) REFERENCES users(id)
    ON DELETE CASCADE
);

-- =====================================================
-- ORGANIZATION TABLES
-- =====================================================

CREATE TABLE organizations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  business_actor_id UUID REFERENCES business_actors(id),
  logo_id UUID REFERENCES images(id),

  code TEXT,
  service TEXT,
  is_individual_business BOOLEAN DEFAULT false,
  email TEXT,
  short_name TEXT,
  long_name TEXT,
  description TEXT,
  logo_uri TEXT,
  website_url TEXT,
  social_network TEXT,
  business_registration_number TEXT,
  tax_number TEXT,
  capital_share NUMERIC,
  ceo_name TEXT,
  year_founded INT,
  keywords TEXT,
  number_of_employees INT,
  legal_form TEXT,
  is_active BOOLEAN DEFAULT true,
  status status_enum DEFAULT 'DRAFT',

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE agencies (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID NOT NULL REFERENCES organizations(id) ON DELETE CASCADE, -- Must belong to an org

  owner_id UUID REFERENCES business_actors(id),
  manager_id UUID REFERENCES business_actors(id),
  logo_id UUID REFERENCES images(id),

  code TEXT,
  name TEXT,
  location TEXT,
  description TEXT,
  transferable BOOLEAN DEFAULT false,
  is_active BOOLEAN DEFAULT true,
  logo_uri TEXT,
  short_name TEXT,
  long_name TEXT,
  is_individual_business BOOLEAN DEFAULT false,
  is_headquarter BOOLEAN DEFAULT false,
  country TEXT,
  city TEXT,
  latitude NUMERIC,
  longitude NUMERIC,
  open_time TIME,
  close_time TIME,
  phone TEXT,
  email TEXT,
  whatsapp TEXT,
  greeting_message TEXT,
  average_revenue NUMERIC,
  capital_share NUMERIC,
  registration_number TEXT,
  social_network TEXT,
  tax_number TEXT,
  keywords TEXT,
  is_public BOOLEAN DEFAULT false,
  is_business BOOLEAN DEFAULT true,
  total_affiliated_customers INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE business_domains (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE SET NULL, -- optional link to organization
  parent_id UUID REFERENCES business_domains(id) ON DELETE SET NULL,   -- self-referential for hierarchy
  image_id UUID REFERENCES images(id),

  code TEXT,
  service TEXT,
  name TEXT,
  image_uri TEXT,
  type TEXT,
  type_label TEXT,
  description TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE organization_business_domains (
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  business_domain_id UUID REFERENCES business_domains(id) ON DELETE CASCADE,
  PRIMARY KEY (organization_id, business_domain_id)
);

CREATE TABLE contacts (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  contactable_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  contactable_type TEXT,
  first_name TEXT,
  last_name TEXT,
  title TEXT,
  is_email_verified BOOLEAN DEFAULT false,
  is_phone_number_verified BOOLEAN DEFAULT false,
  is_favorite BOOLEAN DEFAULT false,
  phone_number TEXT,
  secondary_phone_number TEXT,
  fax_number TEXT,
  email TEXT,
  secondary_email TEXT,
  email_verified_at TIMESTAMP,
  phone_verified_at TIMESTAMP,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE certifications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  type TEXT,
  name TEXT,
  description TEXT,
  obtainment_date DATE,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE third_parties (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  logo_id UUID REFERENCES images(id),

  code TEXT,
  type TEXT,
  legal_form TEXT,
  unique_identification_number TEXT,
  trade_registration_number TEXT,
  name TEXT,
  acronym TEXT,
  long_name TEXT,
  logo_uri TEXT,
  accounting_account_numbers TEXT,
  authorized_payment_methods TEXT,
  authorized_credit_limit NUMERIC,
  max_discount_rate NUMERIC,
  vat_subject BOOLEAN,
  operations_balance NUMERIC,
  opening_balance NUMERIC,
  pay_term_number INT,
  pay_term_type TEXT,
  third_party_family TEXT,
  classification TEXT,
  tax_number TEXT,
  loyalty_points NUMERIC,
  loyalty_points_used NUMERIC,
  loyalty_points_expired NUMERIC,
  enabled BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE settings (
  user_id UUID PRIMARY KEY REFERENCES users(id),
  theme TEXT,
  language TEXT,
  long_ride_enabled BOOLEAN DEFAULT false,
  short_ride_enabled BOOLEAN DEFAULT false,
  privacy_enable BOOLEAN DEFAULT true,
  allow_calls BOOLEAN DEFAULT true,
  allow_messages BOOLEAN DEFAULT true,
  notify_new_rides BOOLEAN DEFAULT true,
  notify_ratings BOOLEAN DEFAULT true,
  notify_practical_tips BOOLEAN DEFAULT true,
  notify_promotions BOOLEAN DEFAULT true,
  notify_policy_updates BOOLEAN DEFAULT true,
  notify_peak_hour_recommendations BOOLEAN DEFAULT true,
  receive_email BOOLEAN DEFAULT true,
  receive_sms BOOLEAN DEFAULT true,
  receive_push_notifications BOOLEAN DEFAULT true,
  receive_whatsapp BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE proposed_activities (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  type TEXT,
  name TEXT,
  rate NUMERIC,
  description TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE addresses (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  addressable_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  country_id UUID REFERENCES countries(id) ON DELETE SET NULL,

  addressable_type TEXT,
  type TEXT,
  address_line_1 TEXT,
  address_line_2 TEXT,
  city TEXT,
  state TEXT,
  locality TEXT,
  zip_code TEXT,
  postal_code TEXT,
  po_box TEXT,
  is_default BOOLEAN DEFAULT false,
  neighbor_hood TEXT,
  informal_description TEXT,
  latitude NUMERIC,
  longitude NUMERIC,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

-- =====================================================
-- USERS EXTENDED
-- =====================================================

CREATE TABLE providers (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  contact_info TEXT,
  address TEXT,
  is_active BOOLEAN DEFAULT true,
  product_service_type TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE employees (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  is_manager BOOLEAN DEFAULT false,
  role TEXT,
  department TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE prospects (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  payment_method TEXT,
  amount_paid NUMERIC,
  interest_level TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE sales_persons (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  commission_rate NUMERIC,
  credit NUMERIC,
  current_balance NUMERIC,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE customers (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  code TEXT,
  payment_method TEXT,
  amount_paid NUMERIC,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),
  deleted_at TIMESTAMP
);

CREATE TABLE services (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  name TEXT,
  phone_number TEXT,
  email_address TEXT
);

-- =====================================================
-- RIDE & FLEET MANAGEMENT
-- =====================================================

CREATE TABLE drivers (
  id UUID PRIMARY KEY REFERENCES business_actors(id) ON DELETE CASCADE,

  status TEXT,
  license_number TEXT,
  has_car BOOLEAN DEFAULT false
);

CREATE TABLE offers (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  passenger_id UUID REFERENCES customers(id) ON DELETE CASCADE,
  selected_driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,

  start_point TEXT,
  end_point TEXT,
  price NUMERIC,
  state offer_state_enum DEFAULT 'PENDING',
  ids_interested_drivers TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE rides (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  offer_id UUID REFERENCES offers(id) ON DELETE SET NULL,
  passenger_id UUID REFERENCES users(id) ON DELETE SET NULL,
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,

  distance NUMERIC,
  time_estimation NUMERIC,
  real_time NUMERIC,
  state ride_state_enum DEFAULT 'CREATED',

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE fleet_managers (
  id UUID PRIMARY KEY REFERENCES business_actors(id) ON DELETE CASCADE,

  name TEXT,
  phone_number TEXT,
  email_address TEXT
);

CREATE TABLE fleets (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  fleet_manager_id UUID REFERENCES fleet_managers(id) ON DELETE SET NULL,

  name TEXT,
  phone_number TEXT,
  email_address TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE geofence_zones (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  surface_area NUMERIC,
  perimeter NUMERIC
);

CREATE TABLE vehicles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,
  fleet_id UUID REFERENCES fleets(id) ON DELETE SET NULL,
  zone_id UUID REFERENCES geofence_zones(id) ON DELETE SET NULL,

  license_plate TEXT,
  model TEXT,
  brand TEXT,
  manufacturing_year INT,
  type vehicle_type_enum,
  color TEXT
);

CREATE TABLE roads (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  start_point TEXT,
  end_point TEXT
);

CREATE TABLE trips (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  road_id UUID REFERENCES roads(id) ON DELETE SET NULL,
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,

  start_date DATE,
  end_date DATE,
  start_time TIME,
  end_time TIME,
  type TEXT,
  color TEXT
);

CREATE TABLE operational_parameters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,

  statut TEXT,
  current_location TEXT,
  current_speed NUMERIC,
  fuel_level NUMERIC,
  mileage NUMERIC,
  odometer_reading NUMERIC,
  bearing NUMERIC,

  timestamp TIMESTAMP DEFAULT now()
);

CREATE TABLE financial_parameters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,

  insurance_number TEXT,
  insurance_expired_at DATE,
  registered_at DATE,
  purchased_at DATE,
  depreciation_rate NUMERIC,
  cost_per_km NUMERIC
);

CREATE TABLE maintenance_parameters (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  trip_id UUID REFERENCES trips(id) ON DELETE CASCADE,

  last_maintenance_at DATE,
  next_maintenance_at DATE,
  engine_status engine_status_enum DEFAULT 'OK',
  battery_health TEXT,
  maintenance_status maintenance_status_enum DEFAULT 'UP_TO_DATE'
);

CREATE TABLE geofence_points (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  latitude NUMERIC,
  longitude NUMERIC
);

CREATE TABLE geofence_point_zone_linkages (
  point_id UUID REFERENCES geofence_points(id) ON DELETE CASCADE,
  zone_id UUID REFERENCES geofence_zones(id) ON DELETE CASCADE,
  PRIMARY KEY (point_id, zone_id)
);

CREATE TABLE geofence_events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  vehicle_id UUID REFERENCES vehicles(id) ON DELETE CASCADE,
  zone_id UUID REFERENCES geofence_zones(id) ON DELETE SET NULL,
  point_id UUID REFERENCES geofence_points(id) ON DELETE SET NULL,

  type event_type_enum,

  timestamp TIMESTAMP DEFAULT now()
);

CREATE TABLE offer_driver_linkages (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), -- La seule ClÃ© Primaire
  offer_id UUID REFERENCES offers(id) ON DELETE CASCADE,
  driver_id UUID REFERENCES drivers(id) ON DELETE CASCADE,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now(),

  -- RÃ¨gle mÃ©tier transformÃ©e en contrainte d'unicitÃ©
  CONSTRAINT uk_offer_driver UNIQUE (offer_id, driver_id) 
);

-- =====================================================
-- OTHERS: PRODUCTS, SYNDICATS, PUBLICATIONS & REVIEWS
-- =====================================================

CREATE TABLE syndicats (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,

  is_approved BOOLEAN DEFAULT false,
  name TEXT,
  description TEXT,
  domain TEXT,
  type TEXT,
  charte_url TEXT,
  status_url TEXT,
  members_list_url TEXT,
  commitment_certificate_url TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE abstract_products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  syndicat_id UUID REFERENCES syndicats(id) ON DELETE SET NULL,

  name TEXT,
  description TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  organization_id UUID REFERENCES organizations(id) ON DELETE CASCADE,
  abstract_product_id UUID REFERENCES abstract_products(id) ON DELETE SET NULL,

  name TEXT,
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  standard_price NUMERIC,
  departure_location TEXT,
  arrival_location TEXT,
  start_date DATE,
  start_time TIME,
  end_date DATE,
  end_time TIME,
  baggage_info TEXT,
  is_negotiable BOOLEAN DEFAULT false,
  payment_method TEXT,
  title TEXT,
  status status_enum DEFAULT 'DRAFT',
  product_urls TEXT,
  regular_amount NUMERIC,
  discount_percentage NUMERIC,
  discounted_amount NUMERIC,
  metadata JSONB,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE publication_votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  title TEXT,
  description TEXT,
  closing_at TIMESTAMP,
  type category_enum
);

CREATE TABLE votes (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  publication_vote_id UUID REFERENCES publication_votes(id) ON DELETE CASCADE,

  label TEXT
);

CREATE TABLE avis (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  product_id UUID REFERENCES products(id) ON DELETE CASCADE,
  syndicat_id UUID REFERENCES syndicats(id) ON DELETE SET NULL,

  comment TEXT,
  number INT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE branches (
  id UUID PRIMARY KEY REFERENCES agencies(id),
  syndicat_id UUID REFERENCES syndicats(id) ON DELETE SET NULL,

  name TEXT,
  location TEXT,
  contact TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE publications (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  branch_id UUID REFERENCES branches(id) ON DELETE SET NULL,
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,

  content TEXT,
  status status_enum DEFAULT 'DRAFT',
  n_likes INT DEFAULT 0,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE publication_images (
  publication_id UUID REFERENCES publications(id) ON DELETE CASCADE,
  image_id UUID REFERENCES images(id) ON DELETE CASCADE,
  PRIMARY KEY (publication_id, image_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  branch_id UUID REFERENCES branches(id) ON DELETE SET NULL,

  title TEXT,
  description TEXT,
  location TEXT,
  date DATE,
  start_time TIME,
  end_time TIME,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE event_images (
  event_id UUID REFERENCES events(id) ON DELETE CASCADE,
  image_id UUID REFERENCES images(id) ON DELETE CASCADE,
  PRIMARY KEY (event_id, image_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE reactions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  publication_id UUID REFERENCES publications(id) ON DELETE CASCADE,
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  type reaction_type_enum,

  reacted_at TIMESTAMP DEFAULT now()
);

CREATE TABLE comments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,
  publication_id UUID REFERENCES publications(id) ON DELETE CASCADE,
  parent_id UUID REFERENCES comments(id) ON DELETE SET NULL,
  image_id UUID REFERENCES images(id) ON DELETE SET NULL,

  content TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE profiles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  first_name TEXT,
  last_name TEXT,
  nickname TEXT,
  profile_image_url TEXT,
  birth_date DATE,
  nationality TEXT,
  gender TEXT,
  language TEXT,
  company_name TEXT,
  biography TEXT,
  rating NUMERIC,
  total_trips INT,
  is_available BOOLEAN DEFAULT true,
  is_verified BOOLEAN DEFAULT false,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- =====================================================
-- PAYMENTS & SUBSCRIPTIONS
-- =====================================================

CREATE TABLE admins (
  id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  name TEXT,
  phone_number TEXT,
  email_address TEXT
);

CREATE TABLE subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  admin_id UUID REFERENCES admins(id) ON DELETE SET NULL,

  label TEXT,
  price NUMERIC,
  duration_in_days INT,
  description TEXT,
  is_active BOOLEAN DEFAULT true,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE payments (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  driver_id UUID REFERENCES drivers(id) ON DELETE SET NULL,
  subscription_id UUID REFERENCES subscriptions(id) ON DELETE SET NULL,
  user_id UUID REFERENCES business_actors(id) ON DELETE SET NULL,

  amount_paid NUMERIC,
  status TEXT,
  id_provider_transaction TEXT,

  created_at TIMESTAMP DEFAULT now()
);

CREATE TABLE reviews (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  ride_id UUID REFERENCES rides(id) ON DELETE CASCADE,
  author_id UUID REFERENCES users(id) ON DELETE SET NULL,

  subject TEXT,
  comment TEXT,
  rating NUMERIC,

  created_at TIMESTAMP DEFAULT now()
);

-- =====================================================
-- ROLE-BASED ACCESS CONTROL (RBAC)
-- =====================================================

CREATE TABLE roles (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  name TEXT NOT NULL,
  guard_name TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE permissions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),

  name TEXT NOT NULL,
  guard_name TEXT,

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE role_has_permissions (
  role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (role_id, permission_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

CREATE TABLE user_has_roles (
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  role_id UUID REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, role_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- =====================================================
-- FIX: DIRECT PERMISSIONS (USER <-> PERMISSIONS)
-- =====================================================

-- Table de liaison pour les permissions accordÃ©es directement Ã  un utilisateur
CREATE TABLE IF NOT EXISTS user_has_permissions (
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  permission_id UUID REFERENCES permissions(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, permission_id),

  created_at TIMESTAMP DEFAULT now(),
  updated_at TIMESTAMP DEFAULT now()
);

-- Commit the transaction


-- =====================================================
-- END OF SCRIPT. NOTHING AFTER HERE!
-- =====================================================
```

---
### Fichier : `./src/main/resources/application.yml`
```yaml
server:
  port: 8080

spring:
  application:
    name: ride-and-go
  profiles:
    active: local
  docker:
    compose:
      enabled: false

  # POSTGRESQL (R2DBC)
  r2dbc:
    url: r2dbc:postgresql://${DB_HOST:127.0.0.1}:${DB_PORT:5432}/${DB_NAME:yowyob_db}
    username: ${DB_USERNAME:fleet_admin}
    password: ${DB_PASSWORD:fleet_password}
    pool:
      enabled: true
      initial-size: 1
      max-size: 5
      max-idle-time: 30m
      max-life-time: 10m
      acquire-retry: 3
      max-acquire-time: 30s
      validation-query: SELECT 1
  sql:
    init:
      mode: never

  # REDIS CLUSTER 
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:password}
      cluster:
        enabled: false

  # KAFKA 
  kafka:
    bootstrap-servers: ${KAFKA_HOST:localhost}:${KAFKA_PORT:9092}
    consumer:
      group-id: ride-and-go-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# CUSTOM CONFIG 
application:
  auth:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur rÃ©el
    url: https://auth-service.pynfi.com
  fare:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur rÃ©el
    url: https://fare-calculator-service.pynfi.com
    api-key: 974e9428-6ce2-48e7-b74b-93f572007ef8

  kafka:
    topics:
      notification-service-create-topic: notification-create-topic
      offer-created: offer-created-topic
      offer-send: notification-send-topic
    notification-registration:
      name: "Ride and Go"
      email:
        host: ${SMTP_HOST:smtp.gmail.com}
        port: ${SMTP_PORT:587}
        username: ${SMTP_USERNAME}
        password: ${SMTP_PASSWORD}
    notification-service:
      token: token-topic
      template:
        new-offer-id: 1001
        accepted-offer-id: 1002

management:
  endpoints:
    web:
      exposure:
        include: ["health","info","prometheus"]
  endpoint:
    health:
      show-details: "always"
      probes:
        enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

# ======================================================
# 2. CONFIGURATION TIMEOUT (Resilience4j)
# ======================================================
resilience4j:
  circuitbreaker:
    instances:
      # Config pour le service de prix
      fare-calculator-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        slidingWindowSize: 10
        permittedNumberOfCallsInHalfOpenState: 3
      # Config pour le service auth (si besoin)
      auth-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5
  timelimiter:
    instances:
      fare-calculator-service:
        timeoutDuration: 20s  
      auth-service:
        timeoutDuration: 20s```

---
### Fichier : `./src/main/resources/prod.application.yml`
```yaml
# ===================================================================
# PRODUCTION CONFIGURATION - RIDE & GO API
# ===================================================================

server:
  port: 8080
  error:
    include-message: always # Useful for frontend debugging

spring:
  application:
    name: ride-and-go

  # DATABASE CONFIGURATION (REACTIVE R2DBC)
  r2dbc:
    url: r2dbc:postgresql://${DB_HOST:168.119.122.86}:${DB_PORT:5432}/${DB_NAME:yowyob}
    username: ${DB_USERNAME:master}
    password: ${DB_PASSWORD:Azerty1234*}
    pool:
      enabled: true
      initial-size: 5
      max-size: 20
      max-idle-time: 30m
      validation-query: SELECT 1

  # CRITICAL SECURITY: Never run local scripts on production server
  sql:
    init:
      mode: never

  # REDIS CACHE (CLUSTER MODE)
  data:
    redis:
      password: ${REDIS_PASSWORD:Azerty1234*}
      cluster:
        nodes:
          - ${REDIS_HOST:168.119.122.86}:7001
          - ${REDIS_HOST:168.119.122.86}:7002
          - ${REDIS_HOST:168.119.122.86}:7003

  # MESSAGING SYSTEM (KAFKA)
  kafka:
    bootstrap-servers: ${KAFKA_HOST:168.119.122.86}:${KAFKA_PORT:9092}
    consumer:
      group-id: ride-and-go-group
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.springframework.kafka.support.serializer.JsonDeserializer
      properties:
        spring.json.trusted.packages: "*"
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# CUSTOM BUSINESS SERVICES CONFIGURATION
application:
  auth:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur rÃ©el
    url: https://auth-service.pynfi.com
  fare:
    mode: remote # 'fake' pour ton dev local, 'remote' pour le serveur rÃ©el
    url: https://fare-calculator-service.pynfi.com
    api-key: 974e9428-6ce2-48e7-b74b-93f572007ef8

  kafka:
    topics:
      notification-service-create-topic: notification-create-topic
      offer-created: offer-created-topic
      offer-send: notification-send-topic
    notification-registration:
      name: "Ride and Go"
      email:
        host: ${SMTP_HOST:smtp.gmail.com}
        port: ${SMTP_PORT:587}
        username: ${SMTP_USERNAME}
        password: ${SMTP_PASSWORD}
    notification-service:
      token: token-topic
      template:
        new-offer-id: 1001
        accepted-offer-id: 1002

# MONITORING & HEALTH CHECK (ACTUATOR)
management:
  endpoints:
    web:
      exposure:
        include: ["health", "info", "prometheus"]
  endpoint:
    health:
      show-details: "always"
      probes:
        enabled: true
  metrics:
    export:
      prometheus:
        enabled: true

# ======================================================
# 2. CONFIGURATION TIMEOUT (Resilience4j)
# ======================================================
resilience4j:
  circuitbreaker:
    instances:
      # Config pour le service de prix
      fare-calculator-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
        slidingWindowSize: 10
        permittedNumberOfCallsInHalfOpenState: 3
      # Config pour le service auth (si besoin)
      auth-service:
        failureRateThreshold: 50
        waitDurationInOpenState: 5s
        slidingWindowSize: 5

  # C'est ici qu'on rÃ¨gle le problÃ¨me "Did not observe any item... within 1000ms"
  timelimiter:
    instances:
      fare-calculator-service:
        timeoutDuration: 20s  
      auth-service:
        timeoutDuration: 20s
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/RideAndGoApplication.java`
```java
package com.yowyob.rideandgo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class RideAndGoApplication {

	public static void main(String[] args) {
		SpringApplication.run(RideAndGoApplication.class, args);
	}

}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/mappers/RoleMapper.java`
```java
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface RoleMapper {

    @Mapping(target = "permissions", ignore = true)
    @Mapping(target = "type", source = "name") // IMPORTANT: Entity.name -> Domain.type
    Role toDomain(RoleEntity entity);

    @Mapping(target = "name", source = "type") // IMPORTANT: Domain.type -> Entity.name
    RoleEntity toEntity(Role domain);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/mappers/RideMapper.java`
```java
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RideEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface RideMapper {
    Ride toDomain(RideEntity entity);

    RideEntity toEntity(Ride domain);

    RideResponse toResponse(Ride domain);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/mappers/UserMapper.java`
```java
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateUserRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UserResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface UserMapper {

    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "directPermissions", ignore = true)
    User toDomain(UserEntity entity);

    UserEntity toEntity(User domain);

    @Mapping(target = "roles", ignore = true)
    @Mapping(target = "directPermissions", ignore = true)
    User toDomain(CreateUserRequest request);

    @Mapping(target = "roles", ignore = true) 
    UserResponse toResponse(User domain);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/mappers/FareMapper.java`
```java
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface FareMapper {

    /**
     * Mappe la rÃ©ponse de l'API (Pynfi/Yowyob) vers le Domaine.
     */
    @Mapping(target = "estimatedFare", source = "prixMoyen") // Mapping du prix
    @Mapping(target = "officialFare", source = "prixMoyen")
    // Les champs suivants ne sont pas dans la rÃ©ponse API racine, on les ignore ou on les laisse null
    @Mapping(target = "startPoint", ignore = true) 
    @Mapping(target = "endPoint", ignore = true)
    @Mapping(target = "userId", ignore = true)
    @Mapping(target = "id", ignore = true)
    Fare toDomain(FareResponse response);

    /**
     * Mappe la requÃªte entrante (DTO) vers le Domaine.
     */
    @Mapping(target = "startPoint", source = "depart") // Mapping franÃ§ais -> anglais
    @Mapping(target = "endPoint", source = "arrivee")
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "userId", ignore = true)
    @Mapping(target = "estimatedFare", ignore = true)
    @Mapping(target = "officialFare", ignore = true)
    Fare toDomain(FareRequest request);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/mappers/OfferMapper.java`
```java
package com.yowyob.rideandgo.infrastructure.mappers;

import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateOfferRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.OfferResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferEntity;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.ReportingPolicy;

@Mapper(componentModel = "spring", unmappedTargetPolicy = ReportingPolicy.IGNORE)
public interface OfferMapper {

    @Mapping(target = "bids", ignore = true)
    @Mapping(target = "version", ignore = true) 
    Offer toDomain(OfferEntity entity);

    @Mapping(target = "id", ignore = true)
    @Mapping(target = "bids", ignore = true)
    @Mapping(target = "version", ignore = true)
    @Mapping(target = "selectedDriverId", ignore = true) // Pas de driver Ã  la crÃ©ation
    Offer toDomain(CreateOfferRequest request);

    // MapStruct mappera automatiquement selectedDriverId -> selectedDriverId
    OfferResponse toResponse(Offer domain);

    @Mapping(target = "agreements", ignore = true) 
    OfferEntity toEntity(Offer domain);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/FakeUserAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.ports.out.ExternalUserPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import lombok.RequiredArgsConstructor;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

@RequiredArgsConstructor
public class FakeUserAdapter implements ExternalUserPort {

    private final UserRepositoryPort userRepository;

    @Override
    public Flux<User> fetchAllRemoteUsers() {
        // En mode FAKE : On fait semblant que le distant = le local
        return userRepository.findAll();
    }

    @Override
    public Mono<User> fetchRemoteUserById(UUID id) {
        // En mode FAKE : On rÃ©cupÃ¨re direct en base locale
        return userRepository.findUserById(id);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/FakeAuthAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;
import java.util.List;

@Slf4j
public class FakeAuthAdapter implements AuthPort {
    @Override
    public Mono<AuthResponse> login(String email, String password) {
        log.info("ðŸ›  MODE FAKE AUTH : Login pour {}", email);
        return Mono.just(new AuthResponse(
            "fake.jwt.token", 
            "fake.refresh.token", 
            email, 
            List.of("RIDE_AND_GO_DRIVER"), 
            List.of("*")
        ));
    }

    @Override
    public Mono<AuthResponse> register(String username, String email, String password, String phone, String firstName, String lastName, List<RoleType> roles) {
        log.info("ðŸ›  MODE FAKE AUTH : Inscription pour {} avec rÃ´les {}", username, roles);
        
        List<String> rolesStr = roles.stream().map(Enum::name).toList();

        return Mono.just(new AuthResponse(
            "fake.jwt.token", 
            "fake.refresh.token", 
            username, 
            rolesStr, 
            List.of("*")
        ));
    }

    @Override
    public Mono<Void> forgotPassword(String email) {
        return Mono.empty();
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/FakeFareAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

@Slf4j
public class FakeFareAdapter implements FareClientPort {

    @Override
    public Mono<FareResponse> caclculateFare(FareRequest request) {
        log.info("ðŸ›  MODE FAKE FARE : Calcul pour {} -> {}", request.depart(), request.arrivee());
        
        double randomPrice = ThreadLocalRandom.current().nextDouble(1500.0, 5000.0);
        double roundedPrice = Math.round(randomPrice / 100.0) * 100.0; // Arrondi Ã  100

        // Construction des sous-objets Fake
        FareResponse.FeaturesUtilisees features = new FareResponse.FeaturesUtilisees(
            5500.0, 900.0, 5.0, 1.2, 12, "matin", 1, 2
        );
        
        FareResponse.EstimationsSupplementaires estimations = new FareResponse.EstimationsSupplementaires(
            roundedPrice, features
        );

        return Mono.just(new FareResponse(
                "exact",
                roundedPrice,       // prix_moyen
                roundedPrice - 200, // prix_min
                roundedPrice + 200, // prix_max
                5.5,                // distance
                15.0,               // duree
                estimations,        // estimations_supplementaires
                Map.of("Heure de pointe", "+500F"), // ajustements_appliques
                1,                  // fiabilite
                "Estimation Fake rÃ©ussie",
                Map.of("type_route", "bitume"),     // details_trajet
                List.of("Eviter le centre ville")   // suggestions
        ));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/RemoteFareAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.FareCalculatorClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreaker;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreakerFactory;
import reactor.core.publisher.Mono;

@Slf4j
@RequiredArgsConstructor
public class RemoteFareAdapter implements FareClientPort {
    private final FareCalculatorClient client;
    private final ReactiveCircuitBreakerFactory<?, ?> cbFactory;
    private final FareClientPort fallbackAdapter;

    @Override
    public Mono<FareResponse> caclculateFare(FareRequest request) {
        log.info("ðŸŒ MODE REMOTE FARE : Calling external API for {} to {}", request.depart(), request.arrivee());
        ReactiveCircuitBreaker rcb = cbFactory.create("fare-calculator-service");

        return rcb.run(
                client.calculateFare(request),
                throwable -> {
                    log.warn("ðŸš¨ External Fare Service failed, using fallback: {}", throwable.getMessage());
                    return fallbackAdapter.caclculateFare(request);
                }
        );
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/RemoteAuthAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@RequiredArgsConstructor
public class RemoteAuthAdapter implements AuthPort {

    private final AuthApiClient client;
    private final UserRepositoryPort userRepository;

    private static final String SERVICE_NAME = "RIDE_AND_GO";

    @Override
    public Mono<AuthResponse> login(String identifier, String password) {
        log.info("ðŸŒ REMOTE AUTH : Login pour {}", identifier);
        return client.login(new AuthApiClient.LoginRequest(identifier, password))
                .map(this::mapToDomain)
                .doOnError(e -> log.error("Login failed: {}", e.getMessage()));
    }

    @Override
    public Mono<AuthResponse> register(String username, String email, String password, String phone, String firstName, String lastName, List<RoleType> roles) {
        log.info("ðŸŒ REMOTE AUTH : Register pour {} avec rÃ´les {}", username, roles);

        // Transformation dynamique : List<Enum> -> List<String>
        List<String> rolesToSend = roles.stream()
                .map(Enum::name)
                .toList();

        AuthApiClient.RegisterRequest request = new AuthApiClient.RegisterRequest(
            username, password, email, phone, firstName, lastName,
            SERVICE_NAME, 
            rolesToSend
        );

        return client.register(request)
                .flatMap(response -> {
                    // Sauvegarde locale (ID, Info, mais pas les rÃ´les car gÃ©rÃ©s Ã  distance)
                    User localUser = User.builder()
                            .id(UUID.fromString(response.user().id()))
                            .name(response.user().username())
                            .email(response.user().email())
                            .telephone(response.user().phone())
                            .roles(Collections.emptySet())
                            .directPermissions(Collections.emptySet())
                            .build();

                    return userRepository.save(localUser)
                            .doOnSuccess(u -> log.info("âœ… User synced locally: {}", u.id()))
                            .thenReturn(mapToDomain(response));
                })
                .onErrorResume(WebClientResponseException.class, ex -> {
                    log.error("âŒ Register Failed (Remote): {}", ex.getResponseBodyAsString());
                    return Mono.error(new RuntimeException("Erreur inscription : " + ex.getResponseBodyAsString()));
                });
    }

    @Override
    public Mono<Void> forgotPassword(String email) {
        return Mono.empty(); 
    }

    private AuthResponse mapToDomain(AuthApiClient.TraMaSysResponse res) {
        List<String> filteredRoles = res.user().roles().stream()
                .filter(roleStr -> {
                    try {
                        RoleType.valueOf(roleStr);
                        return true;
                    } catch (IllegalArgumentException e) {
                        return false;
                    }
                })
                .collect(Collectors.toList());

        return new AuthResponse(
            res.accessToken(),
            res.refreshToken(),
            res.user().username(),
            filteredRoles,
            res.user().permissions()
        );
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/RemoteUserAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.ports.out.ExternalUserPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.Collections;
import java.util.UUID;
import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import java.util.stream.Collectors;
import java.util.Set;

@Slf4j
@RequiredArgsConstructor
public class RemoteUserAdapter implements ExternalUserPort {
    private final AuthApiClient client;
    private static final String SERVICE_NAME = "RIDE_AND_GO";

    @Override
    public Flux<User> fetchAllRemoteUsers() {
        return client.getUsersByService(SERVICE_NAME).map(this::mapToDomain);
    }

    @Override
    public Mono<User> fetchRemoteUserById(UUID id) {
        // STRATÃ‰GIE DE CONTOURNEMENT :
        // La route directe /users/{id} renvoie 401.
        // On utilise la route de liste (qui marche) et on filtre nous-mÃªme.
        return client.getUsersByService(SERVICE_NAME)
                .filter(u -> u.id().equals(id.toString())) // On cherche l'utilisateur dans la liste
                .next() // On prend le premier (Mono)
                .map(this::mapToDomain)
                // Si on ne le trouve pas dans la liste, on renvoie empty
                .switchIfEmpty(Mono.empty());
    }

    private User mapToDomain(AuthApiClient.UserDetail dto) {
        // 1. Conversion des rÃ´les String -> Domain Role
        Set<Role> roles = dto.roles().stream()
                .filter(roleStr -> {
                    try {
                        // On filtre pour ne garder que les rÃ´les connus de notre Enum
                        RoleType.valueOf(roleStr);
                        return true;
                    } catch (IllegalArgumentException e) {
                        return false; 
                    }
                })
                .map(roleStr -> Role.builder()
                        .type(RoleType.valueOf(roleStr))
                        // On ne connait pas l'ID du rÃ´le ici, c'est la persistence qui le trouvera via le type
                        .build()) 
                .collect(Collectors.toSet());

        return User.builder()
                .id(UUID.fromString(dto.id()))
                .name(dto.username())
                .email(dto.email())
                .telephone(dto.phone())
                .roles(roles) // <--- ON PASSE LES RÃ”LES ICI
                .directPermissions(Collections.emptySet())
                .build();
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/FareCalculatorClient.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;


import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PostExchange;
import reactor.core.publisher.Mono;

@HttpExchange("/api")
public interface FareCalculatorClient {
    @PostExchange("/estimate/")
    Mono<FareResponse> calculateFare(@RequestBody FareRequest request);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/external/client/AuthApiClient.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client;

import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.service.annotation.GetExchange;
import org.springframework.web.service.annotation.HttpExchange;
import org.springframework.web.service.annotation.PostExchange;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.List;

@HttpExchange("/api")
public interface AuthApiClient {
    
    @PostExchange("/auth/login")
    Mono<TraMaSysResponse> login(@RequestBody LoginRequest request);

    @PostExchange("/auth/register")
    Mono<TraMaSysResponse> register(@RequestBody RegisterRequest request);

    @GetExchange("/users/service/{serviceName}")
    Flux<UserDetail> getUsersByService(@PathVariable String serviceName);

    @GetExchange("/users/{id}")
    Mono<UserDetail> getUserById(@PathVariable String id);

    // --- DTOs Internes ---

    record LoginRequest(String identifier, String password) {}

    record RegisterRequest(
        String username,
        String password,
        String email,
        String phone,
        String firstName,
        String lastName,
        String service, // FixÃ© Ã  "RIDE_AND_GO"
        List<String> roles
    ) {}

    // Structure de rÃ©ponse standard du service Auth
    record TraMaSysResponse(
        String accessToken, 
        String refreshToken, 
        UserDetail user
    ) {}

    record UserDetail(
        String id, 
        String username, 
        String email, 
        String phone,
        String firstName,
        String lastName,
        String service,
        List<String> roles, 
        List<String> permissions
    ) {}
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/messaging/SendNotificationAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.messaging;

import com.yowyob.rideandgo.application.utils.Constants;
import com.yowyob.rideandgo.domain.ports.out.SendNotificationPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Slf4j
@Component
@RequiredArgsConstructor
public class SendNotificationAdapter implements SendNotificationPort {

    private final KafkaTemplate<String, SendNotificationRequest> kafkaTemplate;

    @Value("${application.kafka.notification-service.token}")
    private String token;

    @Value("${application.kafka.topics.notification-service-create-topic}")
    private String topic;

    @Override
    public Mono<Boolean> sendNotification(SendNotificationRequest request) {
        ProducerRecord<String, SendNotificationRequest> record = new ProducerRecord<>(topic, request);
        record.headers().add(Constants.NOTIFICATION_SERVICE_TOKEN_HEADER, token.getBytes());

        return Mono.fromFuture(kafkaTemplate.send(record))
                .thenReturn(true)
                .onErrorReturn(false);
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/messaging/OfferEventPublisherAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.messaging;

import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.ports.out.OfferEventPublisherPort;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Value;
import lombok.extern.slf4j.Slf4j;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

@Slf4j
@Component
@RequiredArgsConstructor
public class OfferEventPublisherAdapter implements OfferEventPublisherPort {

    private final KafkaTemplate<String, Offer> kafkaTemplate;

    @Value("${application.kafka.topics.offer-created}")
    private String topic;

    @Override
    public Mono<Void> publishOfferCreatedEvent(Offer offer) {
        return Mono.fromFuture(kafkaTemplate.send(topic, offer.id().toString(), offer))
                .then();
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/PermissionEntity.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor 
@AllArgsConstructor
@Table("permissions")
public class PermissionEntity {
    @Id
    private UUID id;
    private String name;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/OfferAgreementEntity.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data 
@NoArgsConstructor
@AllArgsConstructor
@Table("offer_driver_linkages") 
public class OfferAgreementEntity implements Persistable<UUID> {
    @Id
    private UUID id;

    @Column("driver_id")
    private UUID driverId;

    @Column("offer_id")
    private UUID offerId;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    // --- Gestion Insert/Update ---

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public OfferAgreementEntity asNew() {
        this.newEntity = true;
        return this;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/OfferEntity.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import com.yowyob.rideandgo.domain.model.enums.OfferState;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.List;
import java.util.UUID;

@Data 
@NoArgsConstructor 
@AllArgsConstructor
@Table("offers") 
public class OfferEntity implements Persistable<UUID> {
    
    @Id
    private UUID id;

    @Column("passenger_id")
    private UUID passengerId;

    @Column("selected_driver_id") 
    private UUID selectedDriverId;

    @Column("start_point")
    private String startPoint;

    @Column("end_point")
    private String endPoint;

    private double price;

    @Column("state")
    private OfferState state;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    @Transient
    private List<OfferAgreementEntity> agreements;

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean isNew) {
        this.newEntity = isNew;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/UserEntity.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable; // <--- Import Important
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.util.UUID;

@Data 
@NoArgsConstructor 
@AllArgsConstructor
@Table("users") 
public class UserEntity implements Persistable<UUID> { // <--- ImplÃ©mente Persistable
    @Id
    private UUID id;

    private String name;
    
    @Column("email_address") 
    private String email;

    @Column("phone_number") 
    private String telephone;

    @Transient 
    private String password; 

    // --- Gestion Insert/Update (Magie R2DBC) ---

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        // Si on marque explicitement 'newEntity' Ã  true, ou si l'ID est null (cas classique)
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/RideEntity.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@NoArgsConstructor
@AllArgsConstructor
@Table("rides")
public class RideEntity implements Persistable<UUID> {
    @Id
    private UUID id;

    @Column("offer_id")
    private UUID offerId;

    @Column("driver_id")
    private UUID driverId;

    @Column("passenger_id")
    private UUID passengerId;

    private double distance;

    @Column("time_estimation") 
    private int duration;

    @Column("state")
    private RideState state;

    @Column("real_time") 
    private int timeReal;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    // --- Gestion Insert/Update ---

    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/entity/RoleEntity.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.Id;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.annotation.Transient;
import org.springframework.data.domain.Persistable; 
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;

import java.time.LocalDateTime;
import java.util.UUID;

@Data 
@NoArgsConstructor 
@AllArgsConstructor
@Table("roles")
public class RoleEntity implements Persistable<UUID> { 
    @Id
    private UUID id;

    @Column("name")
    private RoleType name;

    @CreatedDate
    @Column("created_at")
    private LocalDateTime createdDate;

    @LastModifiedDate
    @Column("updated_at")
    private LocalDateTime lastModifiedDate;

    // --- Gestion Insert/Update ---
    @Transient
    private boolean newEntity = false;

    @Override
    @Transient
    public boolean isNew() {
        return this.newEntity || id == null;
    }

    public void setNewEntity(boolean newEntity) {
        this.newEntity = newEntity;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/RoleR2dbcAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.Permission;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.RoleRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.PermissionR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.RoleR2dbcRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.UUID;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class RoleR2dbcAdapter implements RoleRepositoryPort {

    private final RoleR2dbcRepository roleRepository;
    private final PermissionR2dbcRepository permissionRepository;

    @Override
    public Mono<Role> findByRoleName(RoleType type) {
        return roleRepository.findByName(type).next()
                .flatMap(this::enrichRole);
    }

    @Override
    public Mono<Role> findRoleById(UUID roleId) {
        return roleRepository.findById(roleId)
                .flatMap(this::enrichRole);
    }

    private Mono<Role> enrichRole(RoleEntity entity) {
        return permissionRepository.findAllByRoleId(entity.getId())
                .map(p -> new Permission(p.getId(), p.getName()))
                .collect(Collectors.toSet())
                .map(perms -> Role.builder()
                        .id(entity.getId())
                        // âœ… CORRECTION : entity.getType() -> entity.getName()
                        .type(entity.getName()) 
                        .permissions(perms)
                        .build());
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/RideR2dbcAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RideEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.RideR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.mappers.RideMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class RideR2dbcAdapter implements RideRepositoryPort {

    private final RideR2dbcRepository repository;
    private final RideMapper mapper;

    @Override
    @Transactional
    public Mono<Ride> save(Ride ride) {
        log.info("ðŸ’¾ Saving Ride: ID={} State={}", ride.id(), ride.state());
        RideEntity entity = mapper.toEntity(ride);

        // ForÃ§age de l'INSERT si c'est une crÃ©ation
        if (ride.state() == RideState.CREATED) {
             entity.setNewEntity(true); 
             log.debug("ðŸ‘‰ Force INSERT for Ride {}", ride.id());
        } else {
             entity.setNewEntity(false);
             log.debug("ðŸ‘‰ Force UPDATE for Ride {}", ride.id());
        }

        return repository.save(entity)
                .doOnSuccess(e -> {
                    if (e == null) log.error("âŒ DB returned NULL for ride {}", ride.id());
                    else log.info("âœ… DB saved ride {}", e.getId());
                })
                .map(savedEntity -> {
                    Ride domain = mapper.toDomain(savedEntity);
                    if (domain == null) throw new IllegalStateException("Mapping Entity -> Domain returned null!");
                    return domain;
                })
                // CORRECTION CRITIQUE : Si le save retourne vide (ce qui ne devrait pas arriver sur un insert rÃ©ussi),
                // on renvoie l'objet qu'on a tentÃ© de sauvegarder pour ne pas briser la chaÃ®ne,
                // ou on lÃ¨ve une erreur explicite.
                .switchIfEmpty(Mono.defer(() -> {
                    log.error("âŒ CRITICAL: Repository returned empty for Ride {}. Falling back to input object.", ride.id());
                    // Fallback : On suppose que Ã§a a marchÃ© si pas d'exception, on renvoie l'objet entrant
                    return Mono.just(ride); 
                }));
    }

    @Override
    public Mono<Ride> findRideById(UUID id) {
        return repository.findById(id)
                .map(mapper::toDomain);
    }

    @Override
    public Mono<Ride> findCurrentRideByDriverId(UUID driverId) {
        return repository.findActiveRideByDriverId(driverId)
                .map(mapper::toDomain);
    }
    
    @Override
    public Mono<Ride> findRideByOfferId(UUID offerId) {
        return repository.findByOfferId(offerId)
                .map(mapper::toDomain);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/OfferAgreementR2dbcRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferAgreementEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface OfferAgreementR2dbcRepository extends ReactiveCrudRepository<OfferAgreementEntity, UUID> {
    
    /**
     * Checks if a driver has already applied to a specific offer.
     */
    Mono<OfferAgreementEntity> findByOfferIdAndDriverId(UUID offerId, UUID driverId);

    /**
     * Lists all applications for a given offer.
     */
    Flux<OfferAgreementEntity> findByOfferId(UUID offerId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/RideR2dbcRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RideEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface RideR2dbcRepository extends ReactiveCrudRepository<RideEntity, UUID> {
    // On cherche une course qui est soit CREATED (en approche), soit ONGOING (en cours)
    @Query("SELECT * FROM rides WHERE driver_id = :driverId AND state IN ('CREATED', 'ONGOING') LIMIT 1")
    Mono<RideEntity> findActiveRideByDriverId(UUID driverId);

    // --- NOUVEAU ---
    Mono<RideEntity> findByOfferId(UUID offerId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/RoleR2dbcRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux; // Import Flux
import java.util.UUID;

public interface RoleR2dbcRepository extends ReactiveCrudRepository<RoleEntity, UUID> {
    
    // CORRECTION : On renvoie Flux au lieu de Mono pour Ã©viter l'erreur "Non unique result"
    Flux<RoleEntity> findByName(RoleType name);

    @Query("SELECT r.* FROM roles r JOIN user_has_roles uhr ON r.id = uhr.role_id WHERE uhr.user_id = :userId")
    Flux<RoleEntity> findAllByUserId(UUID userId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/OfferR2dbcRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferEntity;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;

import java.util.UUID;

public interface OfferR2dbcRepository extends ReactiveCrudRepository<OfferEntity, UUID> {
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/UserR2dbcRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;

import java.util.UUID;

public interface UserR2dbcRepository extends ReactiveCrudRepository<UserEntity, UUID> {

    /**
     * Finds all users associated with a specific role ID using the join table.
     */
    @Query("SELECT u.* FROM users u JOIN user_has_roles uhr ON u.id = uhr.user_id WHERE uhr.role_id = :roleId")
    Flux<UserEntity> findAllByRoleId(UUID roleId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/repository/PermissionR2dbcRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.PermissionEntity;
import org.springframework.data.r2dbc.repository.Query;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import reactor.core.publisher.Flux;
import java.util.UUID;

public interface PermissionR2dbcRepository extends ReactiveCrudRepository<PermissionEntity, UUID> {
    
    @Query("SELECT p.* FROM permissions p JOIN role_has_permissions rhp ON p.id = rhp.permission_id WHERE rhp.role_id = :roleId")
    Flux<PermissionEntity> findAllByRoleId(UUID roleId);

    @Query("SELECT p.* FROM permissions p JOIN user_has_permissions uhp ON p.id = uhp.permission_id WHERE uhp.user_id = :userId")
    Flux<PermissionEntity> findDirectPermissionsByUserId(UUID userId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/UserR2dbcAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.Permission;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.UserEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.*;
import com.yowyob.rideandgo.infrastructure.mappers.UserMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDateTime;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.RoleEntity;


import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import org.springframework.r2dbc.core.DatabaseClient;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Component
@RequiredArgsConstructor
public class UserR2dbcAdapter implements UserRepositoryPort {

    private final UserR2dbcRepository userRepository;
    private final RoleR2dbcRepository roleRepository;
    private final PermissionR2dbcRepository permissionRepository;
    private final UserMapper userMapper;
     private final DatabaseClient databaseClient;

    @Override
    public Mono<User> findUserById(UUID userId) {
        return userRepository.findById(userId)
                .flatMap(this::enrichUser);
    }

  

    @Override
    public Flux<User> findAll() {
        return userRepository.findAll()
                .flatMap(this::enrichUser);
    }

    @Override
    public Flux<User> findByRoleName(RoleType type) {
        return roleRepository.findByName(type)
                .flatMap(role -> userRepository.findAllByRoleId(role.getId()))
                .flatMap(this::enrichUser);
    }

   @Override
    @Transactional
    public Mono<User> save(User user) {
        UserEntity entity = userMapper.toEntity(user);

        return userRepository.existsById(user.id())
                .flatMap(exists -> {
                    if (!exists) entity.setNewEntity(true);
                    return userRepository.save(entity);
                })
                .flatMap(savedEntity -> syncRoles(user, savedEntity))
                // --- AJOUT IMPORTANT : Sync des tables filles ---
                .flatMap(savedEntity -> syncActorTables(user, savedEntity)) 
                .map(savedEntity -> user);
    }

    /**
     * InsÃ¨re l'utilisateur dans la table 'customers' ou 'drivers' selon son rÃ´le.
     * C'est nÃ©cessaire pour satisfaire les FK des autres tables (offers, rides).
     */
    private Mono<UserEntity> syncActorTables(User user, UserEntity savedEntity) {
        if (user.roles() == null || user.roles().isEmpty()) return Mono.just(savedEntity);

        return Flux.fromIterable(user.roles())
            .flatMap(role -> {
                String roleName = role.type().name();
                
                if (roleName.contains("PASSENGER") || roleName.contains("CUSTOMER")) {
                    // On insÃ¨re dans 'customers' si pas dÃ©jÃ  prÃ©sent
                    // Note: customers hÃ©rite de users, mais ici on a des tables sÃ©parÃ©es avec FK
                    return databaseClient.sql("INSERT INTO customers (id, code, payment_method) VALUES (:id, :code, 'CASH') ON CONFLICT DO NOTHING")
                            .bind("id", savedEntity.getId())
                            .bind("code", "CUST-" + savedEntity.getId().toString().substring(0, 8))
                            .then();
                } 
                else if (roleName.contains("DRIVER")) {
                    // Pour un driver, il faut d'abord l'insÃ©rer dans 'business_actors' (si ton modÃ¨le le demande)
                    // puis dans 'drivers'.
                    return databaseClient.sql("INSERT INTO business_actors (id, name, email_address, phone_number) VALUES (:id, :name, :email, :phone) ON CONFLICT DO NOTHING")
                            .bind("id", savedEntity.getId())
                            .bind("name", savedEntity.getName())
                            .bind("email", savedEntity.getEmail())
                            .bind("phone", savedEntity.getTelephone())
                            .then()
                            .then(databaseClient.sql("INSERT INTO drivers (id, status, license_number) VALUES (:id, 'AVAILABLE', 'UNKNOWN') ON CONFLICT DO NOTHING")
                                .bind("id", savedEntity.getId())
                                .then());
                }
                return Mono.empty();
            })
            .then(Mono.just(savedEntity));
    }

    @Override
    public Mono<Boolean> delete(User user) {
        return userRepository.deleteById(user.id()).thenReturn(true).onErrorReturn(false);
    }

    @Override
    public Mono<Boolean> deleteById(UUID userId) {
        return userRepository.deleteById(userId).thenReturn(true).onErrorReturn(false);
    }

    @Override
    public Mono<Boolean> exists(User user) {
        return userRepository.existsById(user.id());
    }

    /**
     * Aggregates Roles and Permissions into a complete Domain User object.
     * Uses parallel fetching to optimize performance.
     */
    private Mono<User> enrichUser(UserEntity entity) {
        // Fetch Roles and their specific permissions
        Mono<Set<Role>> rolesMono = roleRepository.findAllByUserId(entity.getId())
                .flatMap(roleEntity -> 
                    permissionRepository.findAllByRoleId(roleEntity.getId())
                        .map(p -> new Permission(p.getId(), p.getName()))
                        .collect(Collectors.toSet())
                        .map(perms -> Role.builder()
                                .id(roleEntity.getId())
                                .type(roleEntity.getName())
                                .permissions(perms)
                                .build())
                ).collect(Collectors.toSet());

        // Fetch permissions assigned directly to the user
        Mono<Set<Permission>> directPermsMono = permissionRepository.findDirectPermissionsByUserId(entity.getId())
                .map(p -> new Permission(p.getId(), p.getName()))
                .collect(Collectors.toSet());

        // Combine all reactive streams
        return Mono.zip(rolesMono, directPermsMono)
                .map(tuple -> User.builder()
                        .id(entity.getId())
                        .name(entity.getName())
                        .email(entity.getEmail())
                        .telephone(entity.getTelephone())
                        .roles(tuple.getT1())
                        .directPermissions(tuple.getT2())
                        .build());
    }

     /**
     * MÃ©thode helper pour gÃ©rer la table de liaison user_has_roles
     * avec crÃ©ation automatique des rÃ´les manquants (Get or Create).
     */
    private Mono<UserEntity> syncRoles(User domainUser, UserEntity savedEntity) {
        if (domainUser.roles() == null || domainUser.roles().isEmpty()) {
            return Mono.just(savedEntity);
        }

        // A. On supprime les anciens liens pour cet user
        String deleteSql = "DELETE FROM user_has_roles WHERE user_id = :userId";
        
        return databaseClient.sql(deleteSql)
                .bind("userId", savedEntity.getId())
                .then()
                .thenMany(Flux.fromIterable(domainUser.roles()))
                .flatMap(domainRole -> 
                    // 1. On cherche le rÃ´le
                    roleRepository.findByName(domainRole.type()).next()
                        // 2. S'il n'existe pas, on le crÃ©e (SwitchIfEmpty)
                        .switchIfEmpty(Mono.defer(() -> {
                            // System.out.println("âš ï¸ Role " + domainRole.type() + " introuvable. CrÃ©ation automatique...");
                            RoleEntity newRole = new RoleEntity(
                                java.util.UUID.randomUUID(), 
                                domainRole.type(), 
                                LocalDateTime.now(), 
                                LocalDateTime.now(),
                                true 
                            );
                            return roleRepository.save(newRole);
                        }))
                        // 3. Une fois qu'on a le rÃ´le (trouvÃ© ou crÃ©Ã©), on insÃ¨re le lien
                        .flatMap(roleEntity -> 
                            databaseClient.sql("INSERT INTO user_has_roles (user_id, role_id) VALUES (:userId, :roleId) ON CONFLICT DO NOTHING")
                                    .bind("userId", savedEntity.getId())
                                    .bind("roleId", roleEntity.getId())
                                    .then()
                        )
                )
                .then(Mono.just(savedEntity));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/persistence/OfferR2dbcAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence;

import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.model.Bid;
import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.ports.out.OfferRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferAgreementEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.entity.OfferEntity;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.OfferAgreementR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.persistence.repository.OfferR2dbcRepository;
import com.yowyob.rideandgo.infrastructure.mappers.OfferMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class OfferR2dbcAdapter implements OfferRepositoryPort {

    private final OfferAgreementR2dbcRepository offerAgreementRepository;
    private final OfferR2dbcRepository offerRepository;
    private final OfferMapper offerMapper;

    @Override
    @Transactional
    public Mono<Offer> save(Offer offer) {
        OfferEntity entity = offerMapper.toEntity(offer);
        
        return offerRepository.existsById(offer.id())
                .flatMap(exists -> {
                    if (!exists) {
                        entity.setNewEntity(true); // Force INSERT
                    }
                    return offerRepository.save(entity);
                })
                .flatMap(savedEntity -> {
                    // OPTIMISATION : Si la liste des bids est vide (ex: crÃ©ation) ou null, on ne fait rien sur la table de liaison.
                    // Si on est dans un Update de statut (ex: SELECT_DRIVER), on ne touche pas aux bids non plus ici, 
                    // car ils ont Ã©tÃ© insÃ©rÃ©s lors du 'Apply'.
                    // On ne sauvegarde les bids que si c'est explicitement demandÃ© par le cas d'usage (ex: ResponseToOffer).
                    
                    if (offer.bids() == null || offer.bids().isEmpty()) {
                        return Mono.just(savedEntity);
                    }

                    // On ne traite les bids que s'ils ne sont pas dÃ©jÃ  liÃ©s.
                    // Pour Ã©viter les conflits SQL lors d'un update global, on utilise insert-ignore logique via 'switchIfEmpty'
                    return Flux.fromIterable(offer.bids())
                            .flatMap(bid -> offerAgreementRepository
                                    .findByOfferIdAndDriverId(savedEntity.getId(), bid.driverId())
                                    .switchIfEmpty(Mono.defer(() -> offerAgreementRepository.save(
                                            new OfferAgreementEntity(
                                                Utils.generateUUID(), 
                                                bid.driverId(), 
                                                savedEntity.getId(),
                                                null, 
                                                null, 
                                                true // Force INSERT
                                            )
                                    ))))
                            .collectList()
                            .map(agreements -> {
                                savedEntity.setAgreements(agreements);
                                return savedEntity;
                            });
                })
                .map(this::mapToDomainManual);
    }

    @Override
    public Mono<Offer> findById(UUID offerId) {
        return offerRepository.findById(offerId)
                .flatMap(this::enrichOfferWithAgreements)
                .map(this::mapToDomainManual);
    }

    @Override
    public Flux<Offer> findAll() {
        return offerRepository.findAll()
                .flatMap(this::enrichOfferWithAgreements)
                .map(this::mapToDomainManual);
    }

    private Mono<OfferEntity> enrichOfferWithAgreements(OfferEntity entity) {
        return offerAgreementRepository.findByOfferId(entity.getId())
                .collectList()
                .map(agreements -> {
                    entity.setAgreements(agreements);
                    return entity;
                });
    }

    private Offer mapToDomainManual(OfferEntity entity) {
        Offer domain = offerMapper.toDomain(entity);
        if (entity.getAgreements() != null) {
            return domain.withBids(entity.getAgreements().stream()
                    .map(a -> Bid.builder().driverId(a.getDriverId()).build())
                    .collect(Collectors.toList()));
        }
        return domain;
    }

    @Override
    public Mono<Boolean> delete(Offer offer) {
        return offerRepository.delete(offerMapper.toEntity(offer))
                .thenReturn(true)
                .onErrorReturn(false);
    }

    @Override
    public Mono<Boolean> exists(Offer offer) {
        return offerRepository.existsById(offer.id());
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/outbound/cache/RedisAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.outbound.cache;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.ports.out.FareCachePort;
import com.yowyob.rideandgo.domain.ports.out.OfferCachePort;
import com.yowyob.rideandgo.domain.ports.out.UserCachePort;
import com.yowyob.rideandgo.domain.ports.out.LocationCachePort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.util.Map;
import java.util.UUID;

@Slf4j
@Component
@RequiredArgsConstructor
public class RedisAdapter implements OfferCachePort, UserCachePort, FareCachePort, LocationCachePort {
    
    private final ReactiveRedisTemplate<String, Object> redisTemplate;
    
    private static final String LOCATION_KEY_PREFIX = "location:";
    private static final Duration LOCATION_TTL = Duration.ofMinutes(5);

    // --- LocationCachePort Implementation ---

    @Override
    public Mono<Boolean> saveLocation(UUID actorId, Double latitude, Double longitude) {
        String key = LOCATION_KEY_PREFIX + actorId.toString();
        // Using a Map for simple JSON serialization in Redis
        Map<String, Double> coords = Map.of(
            "lat", latitude, 
            "lon", longitude
        );
        
        return redisTemplate.opsForValue()
                .set(key, coords, LOCATION_TTL)
                .doOnSuccess(success -> log.debug("Location cached for actor {} (success: {})", actorId, success))
                .onErrorResume(e -> {
                    log.error("Failed to cache location for actor {}", actorId, e);
                    return Mono.just(false);
                });
    }

    @Override
    @SuppressWarnings("unchecked")
    public Mono<Location> getLocation(UUID actorId) {
        String key = LOCATION_KEY_PREFIX + actorId.toString();
        return redisTemplate.opsForValue()
                .get(key)
                .map(obj -> {
                    Map<String, Double> coords = (Map<String, Double>) obj;
                    return new Location(coords.get("lat"), coords.get("lon"));
                })
                .doOnError(e -> log.error("Error retrieving location for actor {}", actorId, e))
                .onErrorResume(e -> Mono.empty());
    }

    // --- OfferCachePort Implementation ---

    @Override
    public Mono<Boolean> saveInCache(Offer offer) {
        return redisTemplate.opsForValue()
                .set("offer:" + offer.id(), offer, Duration.ofMinutes(15));
    }

    @Override
    public Mono<Offer> findOfferById(UUID offerId) {
        return redisTemplate.opsForValue()
                .get("offer:" + offerId)
                .cast(Offer.class)
                .onErrorResume(e -> Mono.empty());
    }

    // --- UserCachePort Implementation ---

    @Override
    public Mono<Boolean> saveInCache(User user) {
        return redisTemplate.opsForValue()
                .set("user:" + user.id(), user, Duration.ofMinutes(10));
    }

    @Override
    public Mono<User> findUserById(UUID userId) {
        return redisTemplate.opsForValue()
                .get("user:" + userId)
                .cast(User.class);
    }

    // --- FareCachePort Implementation ---

    @Override
    public Mono<Boolean> saveInCache(Fare fare) {
        return redisTemplate.opsForValue()
                .set("fare:" + fare.id(), fare, Duration.ofMinutes(10));
    }

    @Override
    public Mono<Fare> findFareById(UUID fareId) {
        return redisTemplate.opsForValue()
                .get("fare:" + fareId)
                .cast(Fare.class);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/kafka/kafkaAdapter.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.kafka;

public class kafkaAdapter {
    
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/FareController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/fares")
@Tag(name = "Fare-Calculator", description = "Trip price estimation (Stateless)")
public class FareController {

    private final FareClientPort fareClientPort;

    @PostMapping("/estimate")
    @Operation(summary = "Calculate fare estimation", description = "Returns suggested price. No data persistence.")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "Estimation successful", 
                        content = @Content(schema = @Schema(implementation = FareResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid request parameters")
    })
    public Mono<FareResponse> estimateFare(@RequestBody FareRequest request) {
        return fareClientPort.caclculateFare(request);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/OfferController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.in.*;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateOfferRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.OfferResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideResponse;
import com.yowyob.rideandgo.infrastructure.mappers.OfferMapper;
import com.yowyob.rideandgo.infrastructure.mappers.RideMapper;
import com.yowyob.rideandgo.application.service.OfferService;
import com.yowyob.rideandgo.application.service.RideService; // Import ajoutÃ©
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UpdateOfferRequest;

import java.util.UUID;

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/offers")
@Tag(name = "Offer-Controller", description = "Matchmaking workflow")
public class OfferController {
    
    private final CreateOfferUseCase createOfferUseCase;
    private final GetAvailableOffersUseCase getAvailableOffersUseCase;
    private final ResponseToOfferUseCase responseToOfferUseCase;
    private final SelectDriverUseCase selectDriverUseCase;
    private final OfferService offerService; 
    private final RideService rideService; // Injection ajoutÃ©e
    private final OfferMapper mapper;
    private final RideMapper rideMapper; 

    @PostMapping
    @Operation(summary = "Publish an offer (Passenger)")
    public Mono<OfferResponse> createOffer(@RequestBody CreateOfferRequest request) {
        return createOfferUseCase.createOffer(mapper.toDomain(request), request.passengerId())
                .map(mapper::toResponse);
    }

    @GetMapping("/available")
    @Operation(summary = "List pending offers (Driver)")
    public Flux<OfferResponse> getAvailable() {
        return getAvailableOffersUseCase.getAvailableOffers().map(mapper::toResponse);
    }

    @PostMapping("/{id}/apply")
    @Operation(summary = "Apply to an offer (Driver)")
    public Mono<OfferResponse> apply(@PathVariable UUID id, @RequestParam UUID driverId) {
        return responseToOfferUseCase.responseToOffer(id, driverId).map(mapper::toResponse);
    }

    @GetMapping("/{id}/bids")
    @Operation(summary = "Review enriched bidders (Passenger)")
    public Mono<OfferResponse> getBids(@PathVariable UUID id) {
        return offerService.getOfferWithEnrichedBids(id).map(mapper::toResponse);
    }

    @PatchMapping("/{id}/select-driver")
    @Operation(summary = "1. Passenger selects driver", description = "Offer state -> DRIVER_SELECTED")
    public Mono<OfferResponse> select(@PathVariable UUID id, @RequestParam UUID driverId) {
        return selectDriverUseCase.selectDriver(id, driverId).map(mapper::toResponse);
    }

    @PostMapping("/{id}/accept")
    @Operation(summary = "2. Driver confirms pickup", description = "Offer state -> VALIDATED. Creates Ride.")
    public Mono<RideResponse> driverAccepts(@PathVariable UUID id, @RequestParam UUID driverId) {
        return offerService.driverAcceptsOffer(id, driverId).map(rideMapper::toResponse);
    }

    @PostMapping("/{id}/cancel")
    @Operation(summary = "Cancel offer (Passenger)")
    public Mono<OfferResponse> cancel(@PathVariable UUID id) {
        return offerService.cancelOffer(id).map(mapper::toResponse);
    }

    // --- NOUVEAU ENDPOINT : Transition Offre -> Course ---
    @GetMapping("/{id}/ride")
    @Operation(summary = "Get linked ride for an offer", description = "Returns the Ride object if the offer has been validated by a driver.")
    public Mono<RideResponse> getRideByOfferId(@PathVariable UUID id) {
        return rideService.getRideByOfferId(id)
                .map(rideMapper::toResponse);
    }

    // --- ENDPOINTS DE GESTION / DEBUG ---

    @GetMapping
    @Operation(summary = "Get all offers (Admin/Debug)", description = "Retrieves all offers regardless of status")
    public Flux<OfferResponse> getAllOffers() {
        return offerService.getAllOffers().map(mapper::toResponse);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get offer by ID", description = "Get details of a specific offer")
    public Mono<OfferResponse> getOfferById(@PathVariable UUID id) {
        return offerService.getOfferById(id).map(mapper::toResponse);
    }

    @PutMapping("/{id}")
    @Operation(summary = "Update offer", description = "Modifies start/end points or price. Does not change state.")
    public Mono<OfferResponse> updateOffer(@PathVariable UUID id, @RequestBody UpdateOfferRequest request) {
        com.yowyob.rideandgo.domain.model.Offer domainUpdate = com.yowyob.rideandgo.domain.model.Offer.builder()
                .startPoint(request.startPoint())
                .endPoint(request.endPoint())
                .price(request.price() != null ? request.price() : 0.0)
                .build();
        
        return offerService.updateOffer(id, domainUpdate).map(mapper::toResponse);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete offer", description = "Permanently removes an offer")
    public Mono<Void> deleteOffer(@PathVariable UUID id) {
        return offerService.deleteOffer(id).then();
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/GlobalExceptionHandler.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.exception.OfferNotFoundException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ProblemDetail;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(OfferNotFoundException.class)
    public ProblemDetail handleOfferNotFound(OfferNotFoundException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, e.getMessage());
    }
    
    @ExceptionHandler(IllegalStateException.class)
    public ProblemDetail handleIllegalState(IllegalStateException e) {
        // Renvoie 403 Forbidden si c'est un problÃ¨me de droits, ou 400 selon le contexte
        // Ici on met 400 Bad Request pour simplifier
        return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, e.getMessage());
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ProblemDetail handleIllegalArgument(IllegalArgumentException e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.BAD_REQUEST, e.getMessage());
    }
    
    @ExceptionHandler(com.yowyob.rideandgo.domain.exception.OfferStatutNotMatchException.class)
    public ProblemDetail handleStatutMatch(Exception e) {
        return ProblemDetail.forStatusAndDetail(HttpStatus.CONFLICT, e.getMessage());
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/AuthController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.AuthUseCase;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.List;

@RestController
@RequestMapping("/api/v1/auth")
@RequiredArgsConstructor
@Tag(name = "Authentication")
public class AuthController {

    private final AuthUseCase authUseCase;

    @PostMapping("/login")
    public Mono<AuthPort.AuthResponse> login(@RequestBody LoginRequest request) {
        return authUseCase.login(request.identifier(), request.password());
    }

    @PostMapping("/register")
    @Operation(summary = "Inscription Multi-RÃ´les")
    public Mono<AuthPort.AuthResponse> register(@RequestBody RegisterDto dto) {
        // Gestion par dÃ©faut : Si aucune liste n'est fournie, on assigne PASSENGER
        List<RoleType> rolesToAssign = (dto.roles() != null && !dto.roles().isEmpty()) 
                ? dto.roles() 
                : List.of(RoleType.RIDE_AND_GO_PASSENGER);

        return authUseCase.register(
            dto.username(), dto.password(), dto.email(), 
            dto.phone(), dto.firstName(), dto.lastName(),
            rolesToAssign
        );
    }

    public record LoginRequest(String identifier, String password) {}
    
    public record RegisterDto(
        String username, 
        String password, 
        String email, 
        String phone, 
        String firstName, 
        String lastName,
        List<RoleType> roles 
    ) {}
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/TripController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.application.service.RideService;
import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.ports.in.GetRideLocationUseCase;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideTrackingResponse;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UpdateStatusRequest;
import com.yowyob.rideandgo.infrastructure.mappers.RideMapper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@RestController
@RequestMapping("/api/v1/trips")
@RequiredArgsConstructor
@Tag(name = "Trip-Controller", description = "Ride lifecycle & GPS management")
public class TripController {

    private final RideService rideService;
    private final GetRideLocationUseCase getRideLocationUseCase;
    private final RideMapper rideMapper;

    // --- NOUVEAU ENDPOINT : RÃ©cupÃ©ration par ID ---
    @GetMapping("/{id}")
    @Operation(summary = "Get ride details", description = "Get details of a ride by its ID")
    public Mono<RideResponse> getRideById(@PathVariable UUID id) {
        return rideService.getRideById(id)
                .map(rideMapper::toResponse);
    }

    @GetMapping("/driver/current")
    @Operation(summary = "Get current active ride for driver", description = "Finds ride in CREATED or ONGOING state")
    public Mono<RideResponse> getCurrentRide() {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        UUID driverId = UUID.fromString(auth.getName());
                        return rideService.getCurrentRideForDriver(driverId);
                    } catch (Exception e) {
                        return Mono.<Ride>error(new IllegalStateException("Invalid Token"));
                    }
                })
                .map(rideMapper::toResponse);
    }

    @PatchMapping("/{id}/status")
    @Operation(summary = "Update ride status", description = "Transitions: CREATED -> ONGOING -> COMPLETED")
    public Mono<RideResponse> updateStatus(
            @PathVariable UUID id, 
            @RequestBody UpdateStatusRequest request) {
        
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        UUID actorId = UUID.fromString(auth.getName());
                        return rideService.updateRideStatus(id, request.status(), actorId);
                    } catch (IllegalArgumentException e) {
                        return Mono.<Ride>error(new IllegalStateException("Invalid User ID in Token"));
                    }
                })
                .map(rideMapper::toResponse);
    }

    @GetMapping("/{id}/location")
    @Operation(summary = "Smart Tracking", description = "Returns Partner Location + Distance + ETA")
    public Mono<RideTrackingResponse> getTrackingInfo(@PathVariable UUID id) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    try {
                        UUID requesterId = UUID.fromString(auth.getName());
                        return getRideLocationUseCase.getPartnerLocation(id, requesterId);
                    } catch (IllegalArgumentException e) {
                        return Mono.error(new IllegalStateException("Invalid User ID in Token"));
                    }
                });
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/SendNotificationRequest.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import lombok.Builder;

import java.util.List;
import java.util.Map;

@Builder
public record SendNotificationRequest(
        NotificationType notificationType,
        int templateId,
        List<String> to,
        Map<String, Object> data
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/RideResponse.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import lombok.Data;

import java.util.UUID;

@Data
public class RideResponse {
    private UUID id;

    private UUID offerId;

    private UUID driverId;

    private UUID passengerId;

    double distance;

    int duration;

    RideState state;

    int timeReal;
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/CreateOfferRequest.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.OfferState;

import java.util.UUID;

public record CreateOfferRequest(
        UUID passengerId,
        String startPoint,
        String endPoint,
        double price,
        OfferState state
) {}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UpdateStatusRequest.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RideState;

public record UpdateStatusRequest(
    RideState status
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/FareRequest.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

// Cette annotation retire les champs NULL du JSON envoyÃ©
@JsonInclude(JsonInclude.Include.NON_NULL) 
public record FareRequest(
    @JsonProperty("depart") String depart,
    @JsonProperty("arrivee") String arrivee,
    @JsonProperty("heure") String heure,
    @JsonProperty("meteo") Integer meteo,
    @JsonProperty("type_zone") Integer typeZone,
    @JsonProperty("congestion_user") Integer congestionUser
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/CreateUserRequest.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.Builder;
import lombok.Data;

@Data @Builder
public class CreateUserRequest {
    private String email;

    private String name;

    private String telephone;

    private String password;

    private RoleType type;
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UserResponse.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import lombok.Builder;
import lombok.Data;

import java.util.List; 
import java.util.UUID;

@Data @Builder
public class UserResponse {
    private UUID id;
    private String name;
    private String email;
    private String telephone;
    
    List<RoleType> roles; 
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/OfferResponse.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.yowyob.rideandgo.domain.model.Bid;
import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.model.Bid;

import java.util.List;
import java.util.UUID;

public record OfferResponse(
        UUID id,
        UUID passengerId,
        UUID selectedDriverId,
        String startPoint,
        String endPoint,
        double price,
        OfferState state,
        List<Bid> bids 
) {}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/FareResponse.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;
import java.util.Map;

/**
 * DTO complet alignÃ© sur la rÃ©ponse de l'API FareCalculator (Yowyob/Pynfi).
 */
public record FareResponse(
    @JsonProperty("statut") String statut,
    @JsonProperty("prix_moyen") Double prixMoyen,
    @JsonProperty("prix_min") Double prixMin,
    @JsonProperty("prix_max") Double prixMax,
    @JsonProperty("distance") Double distance,
    @JsonProperty("duree") Double duree,
    
    // Objets imbriquÃ©s complexes
    @JsonProperty("estimations_supplementaires") EstimationsSupplementaires estimationsSupplementaires,
    
    // Maps dynamiques pour les ajustements et dÃ©tails (clÃ©/valeur)
    @JsonProperty("ajustements_appliques") Map<String, Object> ajustementsAppliques,
    
    @JsonProperty("fiabilite") Integer fiabilite,
    @JsonProperty("message") String message,
    
    @JsonProperty("details_trajet") Map<String, Object> detailsTrajet,
    
    @JsonProperty("suggestions") List<String> suggestions
) {
    
    // --- Records internes pour la structure imbriquÃ©e ---

    public record EstimationsSupplementaires(
        @JsonProperty("ml_prediction") Double mlPrediction,
        @JsonProperty("features_utilisees") FeaturesUtilisees featuresUtilisees
    ) {}

    public record FeaturesUtilisees(
        @JsonProperty("distance_metres") Double distanceMetres,
        @JsonProperty("duree_secondes") Double dureeSecondes,
        @JsonProperty("congestion") Double congestion,
        @JsonProperty("sinuosite") Double sinuosite,
        @JsonProperty("nb_virages") Integer nbVirages,
        @JsonProperty("heure") String heure,
        @JsonProperty("meteo") Integer meteo,
        @JsonProperty("type_zone") Integer typeZone
    ) {}
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/NotificationType.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public enum NotificationType {
    EMAIL, SMS, PUSH
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/UpdateOfferRequest.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record UpdateOfferRequest(
    String startPoint,
    String endPoint,
    Double price
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/dto/RideTrackingResponse.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto;

public record RideTrackingResponse(
    Double latitude,       // La position de la cible
    Double longitude,
    Double distanceKm,     // Distance calculÃ©e
    Integer etaMinutes,    // Temps estimÃ©
    String targetRole      // "DRIVER" ou "PASSENGER"
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/UserController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.UserUseCases;
import com.yowyob.rideandgo.domain.ports.out.RoleRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.CreateUserRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.UserResponse;
import com.yowyob.rideandgo.infrastructure.mappers.UserMapper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collections;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/users")
@Tag(name = "Users", description = "Operations related to User profiles")
public class UserController {
    private final UserUseCases userUseCases;
    private final UserMapper userMapper;
    private final PasswordEncoder passwordEncoder;
    private final RoleRepositoryPort roleRepository;

    /**
     * Creates a new user and assigns a primary role.
     */
    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    @Operation(summary = "Create a user", description = "Creates a new user with a specified role type", hidden = true)
    @ApiResponses({
            @ApiResponse(responseCode = "201", description = "User created", content = @Content(schema = @Schema(implementation = UserResponse.class))),
            @ApiResponse(responseCode = "400", description = "Invalid input data")
    })
    public Mono<UserResponse> createUser(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "User creation payload", required = true,
                    content = @Content(schema = @Schema(implementation = CreateUserRequest.class)))
            @RequestBody CreateUserRequest request) {
        
        return roleRepository.findByRoleName(request.getType())
                .flatMap(role -> {
                    User userToSave = User.builder()
                            .id(Utils.generateUUID())
                            .name(request.getName())
                            .email(request.getEmail())
                            .telephone(request.getTelephone())
                            .password(passwordEncoder.encode(request.getPassword()))
                            .roles(Set.of(role)) 
                            .directPermissions(Collections.emptySet())
                            .build();

                    return userUseCases.saveUser(userToSave);
                })
                .map(this::mapToResponse); 
    }

    /**
     * Retrieves a detailed user profile including roles and permissions.
     */
    @GetMapping("/{userId}")
    @Operation(summary = "Get user by id", description = "Retrieve a user profile by its UUID")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "User found", content = @Content(schema = @Schema(implementation = UserResponse.class))),
            @ApiResponse(responseCode = "404", description = "User not found")
    })
    public Mono<UserResponse> getUserById(
            @Parameter(description = "User identifier", required = true) @PathVariable UUID userId) {
        log.info("Fetching user details for id: {}", userId);
        
        return userUseCases.getUserById(userId)
                .map(this::mapToResponse); 
    }

    /**
     * Lists all users, optionally filtered by their primary role.
     */
    @GetMapping
    @Operation(summary = "List users", description = "Get all users or filter by their primary role")
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "List of users", content = @Content(schema = @Schema(implementation = UserResponse.class)))
    })
    public Flux<UserResponse> getAllUsers(
            @Parameter(description = "Optional role filter") @RequestParam(required = false) RoleType role) {
        
        Flux<User> userFlux = (role != null) ? userUseCases.getUsersByRole(role) : userUseCases.getAllUsers();

        return userFlux.map(this::mapToResponse); 
    }

    /**
     * Deletes a user from the system.
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "Delete user", description = "Permanently delete a user by its UUID", hidden = true)
    @ApiResponses({
            @ApiResponse(responseCode = "200", description = "User successfully deleted"),
            @ApiResponse(responseCode = "404", description = "User not found")
    })
    public Mono<Boolean> deleteById(
            @Parameter(description = "User identifier", required = true) @PathVariable UUID id) {
        log.info("Deleting user with id: {}", id);
        return userUseCases.deleteUserById(id);
    }

    // --- Helper Unique pour Mapper les RÃ´les ---
    private UserResponse mapToResponse(User user) {
        UserResponse response = userMapper.toResponse(user);
        
        if (user.roles() != null) {
            // Conversion Set<Role> vers List<RoleType>
            response.setRoles(user.roles().stream()
                    .map(com.yowyob.rideandgo.domain.model.Role::type)
                    .collect(Collectors.toList()));
        }
        return response;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/LocationController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import com.yowyob.rideandgo.domain.ports.in.UpdateLocationUseCase;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;
import reactor.core.publisher.Mono;

@RestController
@RequestMapping("/api/v1/location")
@RequiredArgsConstructor
@Tag(name = "GPS-Tracking", description = "Real-time location updates")
public class LocationController {

    private final UpdateLocationUseCase updateLocationUseCase;

    @PostMapping
    @Operation(summary = "Update current location", description = "Updates the actor's coordinates in Redis. ID is extracted from JWT.")
    public Mono<Boolean> updateLocation(@RequestBody LocationRequest request) {
        return updateLocationUseCase.updateCurrentLocation(request.latitude(), request.longitude());
    }

    public record LocationRequest(Double latitude, Double longitude) {}
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/adapters/inbound/rest/HealthCheckController.java`
```java
package com.yowyob.rideandgo.infrastructure.adapters.inbound.rest;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.r2dbc.core.DatabaseClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/health")
@RequiredArgsConstructor
@Tag(name = "Health", description = "System diagnostic and connectivity checks")
public class HealthCheckController {

    private final DatabaseClient databaseClient;

    /**
     * Probes the database to ensure the R2DBC connection is active.
     */
    @GetMapping("/check-db")
    @Operation(summary = "Check database connectivity", description = "Executes a simple query to verify the DB link")
    public Mono<Map<String, Object>> checkDatabase() {
        return databaseClient.sql("SELECT 1")
                .map((row, metadata) -> row.get(0))
                .first()
                // Explicitly tell Java to treat this as a Map<String, Object>
                .map(res -> Map.<String, Object>of(
                        "status", "UP",
                        "database", "CONNECTED",
                        "message", "Database is responding correctly"
                ))
                .onErrorReturn(Map.of(
                        "status", "DOWN",
                        "database", "DISCONNECTED",
                        "message", "Could not connect to the database"
                ));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/AuthConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.FakeAuthAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.RemoteAuthAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


@Configuration
public class AuthConfig {
    private final UserRepositoryPort userRepositoryPort;

    public AuthConfig(UserRepositoryPort userRepositoryPort) {
        this.userRepositoryPort = userRepositoryPort;
    }

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "fake")
    public AuthPort fakeAuthPort() {
        return new FakeAuthAdapter();
    }

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "remote", matchIfMissing = true)
    public AuthPort remoteAuthPort(AuthApiClient authApiClient, UserRepositoryPort userRepositoryPort) {
        // Injection du repository pour la sauvegarde locale des utilisateurs lors du register
        return new RemoteAuthAdapter(authApiClient, userRepositoryPort);
    }

    // AJOUTER ces mÃ©thodes dans la classe AuthConfig

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "fake")
    public com.yowyob.rideandgo.domain.ports.out.ExternalUserPort fakeUserPort() {
        return new com.yowyob.rideandgo.infrastructure.adapters.outbound.external.FakeUserAdapter(userRepositoryPort);
    }

    

    @Bean
    @ConditionalOnProperty(name = "application.auth.mode", havingValue = "remote", matchIfMissing = true)
    public com.yowyob.rideandgo.domain.ports.out.ExternalUserPort remoteUserPort(AuthApiClient authApiClient) {
        return new com.yowyob.rideandgo.infrastructure.adapters.outbound.external.RemoteUserAdapter(authApiClient);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/WebClientConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.AuthApiClient;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.FareCalculatorClient;

import reactor.core.publisher.Mono;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.support.WebClientAdapter;
import org.springframework.web.service.invoker.HttpServiceProxyFactory;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.web.reactive.function.client.ClientRequest; 
import org.springframework.web.reactive.function.client.ExchangeFilterFunction; 
import lombok.extern.slf4j.Slf4j;


@Slf4j
@Configuration
public class WebClientConfig {

    @Bean
    public FareCalculatorClient fareCalculatorClient(WebClient.Builder builder,
                                         @Value("${application.fare.url}") String url,
                                         @Value("${application.fare.api-key}") String apiKey) {
        
        // Configuration pour API Key (Header standard)
        WebClient webClient = builder
                .baseUrl(url)
                .defaultHeader("Authorization", "ApiKey " + apiKey) 
                .build();

        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        return HttpServiceProxyFactory.builderFor(adapter).build().createClient(FareCalculatorClient.class);
    }

    @Bean
    public AuthApiClient authApiClient(WebClient.Builder builder, 
                                       @Value("${application.auth.url}") String url) {
        WebClient webClient = builder
                .baseUrl(url)
                .filter(addBearerToken()) 
                .build();

        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();
        return factory.createClient(AuthApiClient.class);
    }

    private <T> T createClient(WebClient.Builder builder, String url, Class<T> clientClass) {
        WebClient webClient = builder.baseUrl(url).build();
        WebClientAdapter adapter = WebClientAdapter.create(webClient);
        HttpServiceProxyFactory factory = HttpServiceProxyFactory.builderFor(adapter).build();
        return factory.createClient(clientClass);
    }
 
    /**
     * Filtre avec Logging pour diagnostiquer la perte de Token
     */
    private ExchangeFilterFunction addBearerToken() {
        return (request, next) -> ReactiveSecurityContextHolder.getContext()
            .map(ctx -> ctx.getAuthentication())
            .flatMap(auth -> {
                // LOG 1 : Voir si on a l'objet Authentication
                System.out.println("ðŸ” [DEBUG WebClient] Auth Principal: " + auth.getPrincipal());
                
                Object credentials = auth.getCredentials();
                // LOG 2 : Voir ce qu'il y a dans les credentials
                System.out.println("ðŸ” [DEBUG WebClient] Credentials Type: " + (credentials != null ? credentials.getClass().getName() : "NULL"));
                System.out.println("ðŸ” [DEBUG WebClient] Credentials Value: " + credentials);

                if (credentials instanceof String token) {
                    System.out.println("âœ… [DEBUG WebClient] Token trouvÃ© ! Injection dans le header...");
                    ClientRequest newRequest = ClientRequest.from(request)
                            .headers(headers -> headers.setBearerAuth(token))
                            .build();
                    return next.exchange(newRequest);
                } else {
                    System.out.println("âš ï¸ [DEBUG WebClient] Pas de Token String dans credentials. Envoi sans Auth.");
                }
                return next.exchange(request);
            })
            .switchIfEmpty(Mono.defer(() -> {
                System.out.println("âŒ [DEBUG WebClient] Contexte de SÃ©curitÃ© VIDE ! (Pas d'utilisateur connectÃ© ?)");
                return next.exchange(request);
            }));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/SecurityConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.infrastructure.security.JwtAuthenticationManager;
import com.yowyob.rideandgo.infrastructure.security.SecurityContextRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.http.HttpStatus;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.reactive.CorsConfigurationSource;
import org.springframework.web.cors.reactive.UrlBasedCorsConfigurationSource;
import reactor.core.publisher.Mono;

import java.util.List;

@Configuration
@EnableWebFluxSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtAuthenticationManager authenticationManager;
    private final SecurityContextRepository securityContextRepository;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        return http
                .exceptionHandling(exceptionHandling -> exceptionHandling
                        .authenticationEntryPoint((swe, e) -> Mono.fromRunnable(() -> swe.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED)))
                        .accessDeniedHandler((swe, e) -> Mono.fromRunnable(() -> swe.getResponse().setStatusCode(HttpStatus.FORBIDDEN)))
                )
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .formLogin(ServerHttpSecurity.FormLoginSpec::disable)
                .httpBasic(ServerHttpSecurity.HttpBasicSpec::disable)
                
                // --- AJOUT CORRECTION CORS ---
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                // -----------------------------

                .authenticationManager(authenticationManager)
                .securityContextRepository(securityContextRepository)
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers(
                                "/api/v1/auth/**", 
                                "/v3/api-docs/**", 
                                "/swagger-ui/**", 
                                "/swagger-ui.html", 
                                "/webjars/**",
                                "/api/v1/health/**" // Healthcheck public
                        ).permitAll()
                        .anyExchange().authenticated()
                )
                .build();
    }

    // --- BEAN CORS ---
    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        // En prod, idÃ©alement on met le domaine prÃ©cis, mais pour le dev/dÃ©mo "*" est OK
        configuration.setAllowedOrigins(List.of("*")); 
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(List.of("*")); // Autorise tous les headers (Authorization, etc.)
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/RedisConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.module.paramnames.ParameterNamesModule;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.ReactiveRedisConnectionFactory;
import org.springframework.data.redis.core.ReactiveRedisTemplate;
import org.springframework.data.redis.serializer.*;

@Configuration
public class RedisConfig {

    @Bean
    public ReactiveRedisTemplate<String, Object> reactiveRedisTemplate(
            ReactiveRedisConnectionFactory factory) {

        ObjectMapper mapper = new ObjectMapper()
                .registerModule(new ParameterNamesModule())
                .registerModule(new JavaTimeModule());

        Jackson2JsonRedisSerializer<Object> jsonSerializer =
                new Jackson2JsonRedisSerializer<>(mapper, Object.class);

        RedisSerializationContext<String, Object> context =
                RedisSerializationContext.<String, Object>newSerializationContext(new StringRedisSerializer())
                        .value(jsonSerializer)
                        .hashValue(jsonSerializer)
                        .build();

        return new ReactiveRedisTemplate<>(factory, context);
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/KafkaConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import org.apache.kafka.clients.producer.ProducerConfig;
import org.apache.kafka.common.serialization.StringSerializer;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.core.reactive.ReactiveKafkaProducerTemplate;
import reactor.kafka.sender.SenderOptions;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers}")
    private String bootstrapServers;

    @Bean
    public ReactiveKafkaProducerTemplate<String, Object> reactiveKafkaProducerTemplate() {
        Map<String, Object> props = new HashMap<>();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, org.springframework.kafka.support.serializer.JsonSerializer.class);

        SenderOptions<String, Object> senderOptions = SenderOptions.create(props);

        return new ReactiveKafkaProducerTemplate<>(senderOptions);
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/R2dbcConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import io.r2dbc.spi.ConnectionFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.convert.converter.Converter;
import org.springframework.data.convert.ReadingConverter;
import org.springframework.data.convert.WritingConverter;
import org.springframework.data.r2dbc.convert.R2dbcCustomConversions;
import org.springframework.data.r2dbc.dialect.PostgresDialect;
import org.springframework.r2dbc.connection.R2dbcTransactionManager;
import org.springframework.transaction.ReactiveTransactionManager;

import java.util.Arrays;

/**
 * Configuration R2DBC avec gestion des ENUMs PostgreSQL via Converters Spring Data.
 * Cette approche est plus fiable que EnumCodec car elle utilise CAST SQL explicites.
 */
@Configuration
public class R2dbcConfig {

    /**
     * Enregistre les converters personnalisÃ©s pour les ENUMs PostgreSQL.
     */
    @Bean
    public R2dbcCustomConversions r2dbcCustomConversions() {
        return R2dbcCustomConversions.of(PostgresDialect.INSTANCE, Arrays.asList(
                // OfferState converters
                new OfferStateWritingConverter(),
                new OfferStateReadingConverter(),
                // RideState converters
                new RideStateWritingConverter(),
                new RideStateReadingConverter()
        ));
    }

    /**
     * Active la gestion transactionnelle rÃ©active
     */
    @Bean
    public ReactiveTransactionManager transactionManager(ConnectionFactory connectionFactory) {
        return new R2dbcTransactionManager(connectionFactory);
    }

    // ========== OFFER STATE CONVERTERS ==========

    /**
     * Convertit l'enum Java OfferState vers String pour PostgreSQL.
     * PostgreSQL cast automatiquement "STRING"::offer_state_enum
     */
    @WritingConverter
    static class OfferStateWritingConverter implements Converter<OfferState, String> {
        @Override
        public String convert(OfferState source) {
            return source.name();
        }
    }

    /**
     * Convertit la String PostgreSQL vers l'enum Java OfferState
     */
    @ReadingConverter
    static class OfferStateReadingConverter implements Converter<String, OfferState> {
        @Override
        public OfferState convert(String source) {
            return OfferState.valueOf(source);
        }
    }

    // ========== RIDE STATE CONVERTERS ==========

    @WritingConverter
    static class RideStateWritingConverter implements Converter<RideState, String> {
        @Override
        public String convert(RideState source) {
            return source.name();
        }
    }

    @ReadingConverter
    static class RideStateReadingConverter implements Converter<String, RideState> {
        @Override
        public RideState convert(String source) {
            return RideState.valueOf(source);
        }
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/FareConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import com.yowyob.rideandgo.domain.ports.out.FareClientPort;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.FakeFareAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.RemoteFareAdapter;
import com.yowyob.rideandgo.infrastructure.adapters.outbound.external.client.FareCalculatorClient;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cloud.client.circuitbreaker.ReactiveCircuitBreakerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class FareConfig {

    /**
     * Always available as a candidate for fallback.
     */
    @Bean
    public FareClientPort fakeFareAdapter() {
        return new FakeFareAdapter();
    }

    /**
     * Active only when mode is 'remote'.
     */
    @Bean
    @Primary
    @ConditionalOnProperty(name = "application.fare.mode", havingValue = "remote")
    public FareClientPort remoteFareAdapter(FareCalculatorClient client, 
                                           ReactiveCircuitBreakerFactory<?, ?> cbFactory) {
        return new RemoteFareAdapter(client, cbFactory, fakeFareAdapter());
    }

    /**
     * Active only when mode is 'fake'.
     */
    @Bean
    @Primary
    @ConditionalOnProperty(name = "application.fare.mode", havingValue = "fake", matchIfMissing = true)
    public FareClientPort onlyFakeFareAdapter() {
        return fakeFareAdapter();
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/DatabaseInitConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Profile;
import org.springframework.core.io.ClassPathResource;
import org.springframework.r2dbc.core.DatabaseClient;
import jakarta.annotation.PostConstruct;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.stream.Collectors;

@Configuration
@Profile("local") // Only active in local development
public class DatabaseInitConfig {

    private final DatabaseClient databaseClient;

    public DatabaseInitConfig(DatabaseClient databaseClient) {
        this.databaseClient = databaseClient;
    }

    @PostConstruct
    public void init() {
        System.out.println("âš™ï¸ LOCAL ENVIRONMENT: Starting sequential database initialization...");

        // 1. Run Schema -> 2. Check if users exist -> 3. Run Seeding if empty
        executeSqlFile("local/schema.sql")
                .then(checkIfDataExists())
                .flatMap(hasData -> {
                    if (!hasData) {
                        System.out.println("ðŸŒ± Database is empty. Injecting seed data...");
                        return executeSqlFile("local/data.sql");
                    }
                    System.out.println("âœ… Database already has data. Skipping seeding.");
                    return Mono.empty();
                })
                .subscribe(
                        null,
                        err -> System.err.println("âŒ Local DB Init Error: " + err.getMessage()),
                        () -> System.out.println("ðŸš€ LOCAL DATABASE READY!")
                );
    }

    /**
     * Reads a SQL file and executes each statement sequentially using concatMap.
     */
    private Mono<Void> executeSqlFile(String filePath) {
        return Mono.fromCallable(() -> {
            ClassPathResource resource = new ClassPathResource(filePath);
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(resource.getInputStream()))) {
                return reader.lines().collect(Collectors.joining("\n"));
            }
        })
        .flatMapMany(sql -> Flux.fromArray(sql.split(";")))
        .map(String::trim)
        .filter(s -> !s.isEmpty())
        .concatMap(s -> databaseClient.sql(s).then()) // Execute in strict sequence
        .then();
    }

    /**
     * Checks if the central 'users' table is populated.
     */
    private Mono<Boolean> checkIfDataExists() {
        return databaseClient.sql("SELECT COUNT(*) FROM users")
                .map((row, metadata) -> row.get(0, Long.class))
                .first()
                .map(count -> count > 0)
                .onErrorReturn(false); // If table doesn't exist, consider it empty
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/config/OpenApiConfig.java`
```java
package com.yowyob.rideandgo.infrastructure.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {

    /**
     * Configures OpenAPI (Swagger) with JWT security support.
     */
    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth";
        
        return new OpenAPI()
                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
                .components(new Components()
                        .addSecuritySchemes(securitySchemeName,
                                new SecurityScheme()
                                        .name(securitySchemeName)
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")))
                .info(new Info()
                        .title("Ride & Go API")
                        .version("1.0.0")
                        .description("Reactive API for Urban Transport Marketplace (Ride & Go project).")
                        .contact(new Contact()
                                .name("Gabriel")
                                .email("dev@yowyob.com"))
                        .license(new License()
                                .name("Apache 2.0")
                                .url("http://springdoc.org")));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/security/SecurityContextRepository.java`
```java
package com.yowyob.rideandgo.infrastructure.security;

import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpHeaders;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication; 
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextImpl;
import org.springframework.security.web.server.context.ServerSecurityContextRepository;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Repository responsible for extracting the JWT token from the Authorization header
 * and initiating the authentication process.
 */
@Component
@RequiredArgsConstructor
public class SecurityContextRepository implements ServerSecurityContextRepository {

    private final JwtAuthenticationManager authenticationManager;

    @Override
    public Mono<Void> save(ServerWebExchange exchange, SecurityContext context) {
        return Mono.error(new UnsupportedOperationException("Stateless API: session saving is not supported."));
    }

    /**
     * Loads the security context by extracting the "Bearer" token from HTTP headers.
     */
    @Override
    public Mono<SecurityContext> load(ServerWebExchange exchange) {
        return Mono.justOrEmpty(exchange.getRequest().getHeaders().getFirst(HttpHeaders.AUTHORIZATION))
                .filter(authHeader -> authHeader.startsWith("Bearer "))
                .flatMap(authHeader -> {
                    String authToken = authHeader.substring(7);
                    // Create an unauthenticated token object
                    Authentication auth = new UsernamePasswordAuthenticationToken(authToken, authToken);
                    // Delegate validation to the AuthenticationManager
                    return this.authenticationManager.authenticate(auth)
                            .map(SecurityContextImpl::new);
                });
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/infrastructure/security/JwtAuthenticationManager.java`
```java
package com.yowyob.rideandgo.infrastructure.security;

import com.yowyob.rideandgo.domain.model.enums.RoleType; // <--- Import de tes vrais rÃ´les
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.ReactiveAuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.stereotype.Component;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationManager implements ReactiveAuthenticationManager {

    // Simulation de tokens liÃ©s Ã  des UUIDs rÃ©els de ta base
    private static final Map<String, String> STATIC_TOKENS = Map.of(
        "client-token", "7f13909e-7170-4f91-872e-333333333333",
        "driver-1-token", "a1b2c3d4-e5f6-4a5b-8c9d-111111111111",
        "driver-2-token", "a1b2c3d4-e5f6-4a5b-8c9d-222222222222"
    );

    @Override
    public Mono<Authentication> authenticate(Authentication authentication) {
        String authToken = authentication.getCredentials().toString();
        
        // 1. Cas des tokens de test statiques (Swagger)
        if (STATIC_TOKENS.containsKey(authToken)) {
            String userId = STATIC_TOKENS.get(authToken);
            
            // Logique simple pour donner le bon rÃ´le selon le nom du token de test
            RoleType role = authToken.contains("driver") 
                    ? RoleType.RIDE_AND_GO_DRIVER 
                    : RoleType.RIDE_AND_GO_PASSENGER;

            return Mono.just(new UsernamePasswordAuthenticationToken(
                    userId, 
                    authToken, // Token Relay activÃ©
                    List.of(new SimpleGrantedAuthority(role.name())) // Utilisation du vrai Enum
            ));
        }

        // 2. Cas des vrais JWT (Remote / Production)
        if (authToken != null && !authToken.isEmpty()) {
            // NOTE : Dans un futur sprint, on dÃ©codera le JWT pour extraire les rÃ´les "claims".
            // Pour l'instant, on assigne un rÃ´le par dÃ©faut valide pour que Spring Security ne bloque pas.
            return Mono.just(new UsernamePasswordAuthenticationToken(
                    authToken, // Principal
                    authToken, // Token Relay activÃ©
                    List.of(new SimpleGrantedAuthority(RoleType.RIDE_AND_GO_PASSENGER.name()))
            ));
        }
        
        return Mono.empty();
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/exception/OfferStatutNotMatchException.java`
```java
package com.yowyob.rideandgo.domain.exception;

public class OfferStatutNotMatchException extends RuntimeException{
    public OfferStatutNotMatchException(String message) {
        super(message);
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/exception/UserIsNotDriverException.java`
```java
package com.yowyob.rideandgo.domain.exception;

public class UserIsNotDriverException extends RuntimeException{
    public UserIsNotDriverException(String message) {
        super(message);
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/exception/TokenNotFoundException.java`
```java
package com.yowyob.rideandgo.domain.exception;

public class TokenNotFoundException extends RuntimeException{
    public TokenNotFoundException(String message) {
        super(message);
    }
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/exception/OfferNotFoundException.java`
```java
package com.yowyob.rideandgo.domain.exception;

public class OfferNotFoundException extends RuntimeException {
    public OfferNotFoundException(String message) {
        super(message);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/Ride.java`
```java
package com.yowyob.rideandgo.domain.model;

import com.yowyob.rideandgo.domain.model.enums.RideState;
import lombok.Builder;

import java.util.UUID;

@Builder
public record Ride(
        UUID id,
        UUID offerId,
        UUID passengerId,
        UUID driverId,
        double distance,
        int duration,
        RideState state,
        int timeReal) {}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/enums/OfferState.java`
```java
package com.yowyob.rideandgo.domain.model.enums;

/**
 * Lifecycle states of a transport Offer as defined in spec.md
 */
public enum OfferState {
    /** Initial state, waiting for drivers */
    PENDING,
    
    /** At least one driver applied */
    BID_RECEIVED,
    
    /** Passenger chose a driver */
    DRIVER_SELECTED,
    
    /** Driver confirmed, offer is closed and becomes a Ride */
    VALIDATED,
    
    /** Cancelled or expired */
    CANCELLED
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/enums/RoleType.java`
```java
package com.yowyob.rideandgo.domain.model.enums;

public enum RoleType {
    // RÃ´les MÃ©tier Ride & Go (Identiques Ã  la DB Distante)
    RIDE_AND_GO_PASSENGER,
    RIDE_AND_GO_DRIVER,
    RIDE_AND_GO_ADMIN
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/enums/RideState.java`
```java
package com.yowyob.rideandgo.domain.model.enums;

/**
 * Lifecycle states of a Trip (Ride) as defined in spec.md
 */
public enum RideState {
    /** Ride initialized, driver approaching passenger */
    CREATED,
    
    /** Passenger picked up, trip in progress */
    ONGOING,
    
    /** Trip finished at destination */
    COMPLETED,
    
    /** Trip interrupted or cancelled */
    CANCELLED
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/Fare.java`
```java
package com.yowyob.rideandgo.domain.model;

import java.util.UUID;

public record Fare(
        UUID id,
        UUID userId,
        String startPoint,
        String endPoint,
        Double estimatedFare,
        Double  officialFare
) {
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/Role.java`
```java
package com.yowyob.rideandgo.domain.model;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import java.util.Set;
import java.util.UUID;
import lombok.Builder;

@Builder
public record Role(
    UUID id, 
    RoleType type,
    Set<Permission> permissions
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/Permission.java`
```java
package com.yowyob.rideandgo.domain.model;
import java.util.UUID;

public record Permission(UUID id, String name) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/User.java`
```java
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.Set;
import java.util.UUID;

@Builder
public record User(
    UUID id,
    String name,
    String email,
    String telephone,
    String password,
    Set<Role> roles,
    Set<Permission> directPermissions
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/Bid.java`
```java
package com.yowyob.rideandgo.domain.model;

import lombok.Builder;
import java.util.UUID;

/**
 * Domain model representing a driver's application to an offer.
 */
@Builder
public record Bid(
    UUID driverId,
    String driverName,
    Integer eta,              // Temps en minutes
    Double latitude,          
    Double longitude,         
    Double rating,            // Note du chauffeur (ex: 4.8)
    
    // --- Nouveaux champs pour la DÃ©mo UI ---
    String carModel,          // ex: "Toyota Yaris"
    String carColor,          // ex: "Rouge"
    String licensePlate,      // ex: "LT-123-AB"
    String driverImage        // URL photo chauffeur
) {}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/model/Offer.java`
```java
package com.yowyob.rideandgo.domain.model;

import com.yowyob.rideandgo.domain.model.enums.OfferState;
import lombok.Builder;
import java.util.List;
import java.util.UUID;

@Builder
public record Offer(
        UUID id,
        UUID passengerId,
        UUID selectedDriverId, 
        String startPoint,
        String endPoint,
        double price,
        OfferState state,
        List<Bid> bids, 
        Long version) {

    public Offer withBids(List<Bid> bids) {
        return new Offer(this.id, this.passengerId, this.selectedDriverId, this.startPoint, this.endPoint, this.price, this.state, bids, this.version);
    }

    public Offer withState(OfferState state) {
        return new Offer(this.id, this.passengerId, this.selectedDriverId, this.startPoint, this.endPoint, this.price, state, this.bids, this.version);
    }

    // Helper pour mettre Ã  jour l'Ã©tat ET le chauffeur
    public Offer withDriverSelected(UUID driverId) {
        return new Offer(this.id, this.passengerId, driverId, this.startPoint, this.endPoint, this.price, OfferState.DRIVER_SELECTED, this.bids, this.version);
    }
    
    public boolean hasDriverApplied(UUID driverId) {
        if (bids == null) return false;
        return bids.stream().anyMatch(b -> b.driverId().equals(driverId));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/AuthUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import reactor.core.publisher.Mono;
import java.util.List;

public interface AuthUseCase {
    Mono<AuthPort.AuthResponse> login(String identifier, String password);
    
    Mono<Void> resetPassword(String email);

    Mono<AuthPort.AuthResponse> register(
        String username, 
        String password, 
        String email, 
        String phone, 
        String firstName, 
        String lastName,
        List<RoleType> roles 
    );
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/UserUseCases.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface UserUseCases {
    Mono<User> saveUser(User user);

    Mono<User> getUserById(UUID userId);

    Mono<Boolean> deleteUserById(UUID userId);

    Flux<User> getAllUsers();

    Flux<User> getUsersByRole(RoleType role);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/UpdateLocationUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import reactor.core.publisher.Mono;

/**
 * Input port for real-time location updates.
 */
public interface UpdateLocationUseCase {
    /**
     * Updates the GPS coordinates of the current authenticated actor.
     * @param latitude Double
     * @param longitude Double
     * @return Mono<Boolean> true if success
     */
    Mono<Boolean> updateCurrentLocation(Double latitude, Double longitude);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/UpdateRideStatusUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface UpdateRideStatusUseCase {
    /**
     * Updates the status of a ride obeying business rules.
     * @param rideId The ID of the ride
     * @param newStatus The target status (ONGOING, COMPLETED, CANCELLED)
     * @param actorId The ID of the user performing the action (Security)
     * @return The updated Ride
     */
    Mono<Ride> updateRideStatus(UUID rideId, RideState newStatus, UUID actorId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/GetRideLocationUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideTrackingResponse;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface GetRideLocationUseCase {
    /**
     * RÃ©cupÃ¨re la position, la distance et l'ETA du partenaire de course.
     */
    Mono<RideTrackingResponse> getPartnerLocation(UUID rideId, UUID requesterId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/OfferManagementUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface OfferManagementUseCase {
    Flux<Offer> getAllOffers();
    Mono<Offer> getOfferById(UUID id);
    Mono<Offer> updateOffer(UUID id, Offer offerDetails);
    Mono<Boolean> deleteOffer(UUID id);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/ResponseToOfferUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface ResponseToOfferUseCase {
    Mono<Offer> responseToOffer(UUID offerId, UUID driverId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/PutFareInCacheUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Fare;
import reactor.core.publisher.Mono;

public interface PutFareInCacheUseCase {
    Mono<Boolean> putFareInCache(Fare fare);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/SelectDriverUseCase.java`
```java

// SelectDriverUseCase.java
package com.yowyob.rideandgo.domain.ports.in;
import com.yowyob.rideandgo.domain.model.Offer;
import java.util.UUID;
import reactor.core.publisher.Mono;

public interface SelectDriverUseCase {
    Mono<Offer> selectDriver(UUID offerId, UUID driverId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/GetAvailableOffersUseCase.java`
```java
// GetAvailableOffersUseCase.java
package com.yowyob.rideandgo.domain.ports.in;
import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Flux;

public interface GetAvailableOffersUseCase {
    Flux<Offer> getAvailableOffers(); // Offers in PENDING state
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/CreateOfferUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface CreateOfferUseCase {
    Mono<Offer> createOffer(Offer offer, UUID passengerId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/in/AcceptedOfferUseCase.java`
```java
package com.yowyob.rideandgo.domain.ports.in;

import com.yowyob.rideandgo.domain.model.Ride;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface AcceptedOfferUseCase {
    Mono<Ride> acceptedOffer(UUID offerId, UUID passengerId, UUID driverId);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/FareCachePort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Fare;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface FareCachePort {
    Mono<Boolean> saveInCache(Fare fare);

    Mono<Fare> findFareById(UUID fareId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/OfferRepositoryPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface OfferRepositoryPort {
    Mono<Offer> save(Offer offer);
    Mono<Boolean> delete(Offer offer);
    Mono<Boolean> exists(Offer offer);
    Mono<Offer> findById(UUID offerId);
    Flux<Offer> findAll(); 
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/RoleRepositoryPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Role;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface RoleRepositoryPort {
    Mono<Role> findRoleById(UUID roleId);

    Mono<Role> findByRoleName(RoleType type);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/UserRepositoryPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.UUID;

public interface UserRepositoryPort {
    Mono<User> save(User user);

    Mono<Boolean> delete(User user);

    Mono<Boolean> deleteById(UUID userId);

    Mono<Boolean> exists(User user);

    Mono<User> findUserById(UUID userId);

    Flux<User> findByRoleName(RoleType role);

    Flux<User> findAll();

}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/UserCachePort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.User;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface UserCachePort {
    Mono<Boolean> saveInCache(User user);

    Mono<User> findUserById(UUID userId);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/LocationCachePort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Mono;
import java.util.UUID;

public interface LocationCachePort {
    /**
     * Saves the live location of an actor (Driver or Passenger).
     * @param actorId The ID of the BusinessActor
     * @param latitude GPS Latitude
     * @param longitude GPS Longitude
     */
    Mono<Boolean> saveLocation(UUID actorId, Double latitude, Double longitude);

    /**
     * Retrieves the last known location from cache.
     */
    Mono<Location> getLocation(UUID actorId);

    /**
     * Internal domain record for coordinates
     */
    record Location(Double latitude, Double longitude) {}
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/ExternalUserPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.User;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import java.util.UUID;

public interface ExternalUserPort {
    Flux<User> fetchAllRemoteUsers();
    Mono<User> fetchRemoteUserById(UUID id);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/OfferCachePort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface OfferCachePort {
    Mono<Boolean> saveInCache(Offer offer);

    Mono<Offer> findOfferById(UUID offerId);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/StockClientPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import reactor.core.publisher.Mono;

public interface StockClientPort {
    /**
     * Verify if te stock is full.
     * @return true full, false otherwise
     */
    Mono<Boolean> isStockFull(String productName);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/RideRepositoryPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Ride;
import reactor.core.publisher.Mono;

import java.util.UUID;

public interface RideRepositoryPort {
    Mono<Ride> save(Ride ride);
    Mono<Ride> findRideById(UUID id);
    Mono<Ride> findCurrentRideByDriverId(UUID driverId);
    
    // --- NOUVEAU ---
    Mono<Ride> findRideByOfferId(UUID offerId);
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/OfferEventPublisherPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.Offer;
import reactor.core.publisher.Mono;

public interface OfferEventPublisherPort {
    Mono<Void> publishOfferCreatedEvent(Offer offer);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/FareClientPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareRequest;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.FareResponse;
import reactor.core.publisher.Mono;

public interface FareClientPort {
    Mono<FareResponse> caclculateFare(FareRequest request);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/SendNotificationPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.SendNotificationRequest;
import reactor.core.publisher.Mono;

public interface SendNotificationPort {
    Mono<Boolean> sendNotification(SendNotificationRequest request);
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/domain/ports/out/AuthPort.java`
```java
package com.yowyob.rideandgo.domain.ports.out;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import reactor.core.publisher.Mono;
import java.util.List;

public interface AuthPort {
    Mono<AuthResponse> login(String email, String password);
    
    Mono<Void> forgotPassword(String email);

    Mono<AuthResponse> register(
        String username, 
        String password, 
        String email, 
        String phone, 
        String firstName, 
        String lastName,
        List<RoleType> roles 
    );

    record AuthResponse(
        String accessToken, 
        String refreshToken, 
        String username, 
        List<String> roles,
        List<String> permissions
    ) {}
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/utils/Constants.java`
```java
package com.yowyob.rideandgo.application.utils;

public class Constants {
    public static final String NOTIFICATION_SERVICE_TOKEN_HEADER = "X-Service-Token";
}
```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/utils/Utils.java`
```java
package com.yowyob.rideandgo.application.utils;

import java.util.UUID;

public class Utils {
    public static UUID generateUUID(){
        return UUID.randomUUID();
    }

    public static int generateRandomNumber(){
        return (int) (Math.random()*100);
    }

    public static int generateRandomNumber(int max){
        return (int) (Math.random()*max);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/OfferService.java`
```java
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.application.utils.Utils;
import com.yowyob.rideandgo.domain.exception.OfferNotFoundException;
import com.yowyob.rideandgo.domain.exception.OfferStatutNotMatchException;
import com.yowyob.rideandgo.domain.model.Bid;
import com.yowyob.rideandgo.domain.model.Offer;
import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.enums.OfferState;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.in.*;
import com.yowyob.rideandgo.domain.ports.out.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.*;
import java.util.concurrent.ThreadLocalRandom;

@Slf4j
@Service
@RequiredArgsConstructor
public class OfferService implements 
    CreateOfferUseCase, 
    ResponseToOfferUseCase, 
    GetAvailableOffersUseCase,
    SelectDriverUseCase,
    OfferManagementUseCase {

    private final OfferCachePort cache;
    private final OfferRepositoryPort repository;
    private final UserRepositoryPort userRepositoryPort;
    private final SendNotificationPort sendNotificationPort; // GardÃ© pour cohÃ©rence d'injection
    private final RideRepositoryPort rideRepositoryPort;
    private final LocationCachePort locationCachePort;
    private final EtaCalculatorService etaCalculatorService;

    // --- DATA DEMO POUR LE FRONTEND (Temporaire) ---
    private record DemoVehicle(String model, String color, String plate, String image) {}
    
    private static final List<DemoVehicle> FAKE_FLEET = List.of(
        new DemoVehicle("Toyota Yaris", "Grise", "LT-882-AF", "https://randomuser.me/api/portraits/men/32.jpg"), 
        new DemoVehicle("Hyundai Elantra", "Blanche", "CE-102-ZZ", "https://randomuser.me/api/portraits/men/45.jpg"), 
        new DemoVehicle("Peugeot 301", "Noire", "LT-440-GG", "https://randomuser.me/api/portraits/men/22.jpg")    
    );

    // --- 1. PUBLICATION ---
    @Override
    public Mono<Offer> createOffer(Offer request, UUID passengerId) {
        Offer offer = Offer.builder()
                .id(Utils.generateUUID())
                .passengerId(passengerId)
                .startPoint(request.startPoint())
                .endPoint(request.endPoint())
                .price(request.price())
                .state(OfferState.PENDING)
                .bids(new ArrayList<>())
                .build();

        return repository.save(offer)
                .flatMap(saved -> cache.saveInCache(saved).thenReturn(saved))
                .doOnSuccess(o -> log.info("Offer created: {}", o.id()));
    }

    // --- 2. DECOUVERTE ---
    @Override
    public Flux<Offer> getAvailableOffers() {
        return repository.findAll()
                .filter(o -> o.state() == OfferState.PENDING || o.state() == OfferState.BID_RECEIVED);
    }

    // --- 3. CANDIDATURE ---
    @Override
    public Mono<Offer> responseToOffer(UUID offerId, UUID driverId) {
        return repository.findById(offerId)
                .flatMap(offer -> userRepositoryPort.findUserById(driverId)
                        .flatMap(user -> {
                            // VÃ©rifie si dÃ©jÃ  postulÃ© pour Ã©viter doublons logiques (mÃªme si gÃ©rÃ© par repo)
                            if (offer.hasDriverApplied(driverId)) return Mono.just(offer);
                            
                            List<Bid> currentBids = new ArrayList<>(offer.bids());
                            currentBids.add(Bid.builder().driverId(driverId).build());
                            
                            // On passe en BID_RECEIVED si c'Ã©tait PENDING
                            return repository.save(offer.withBids(currentBids).withState(OfferState.BID_RECEIVED))
                                    .flatMap(s -> cache.saveInCache(s).thenReturn(s));
                        }));
    }

    // --- 4. SÃ‰LECTION (PASSAGER) ---
    @Override
    public Mono<Offer> selectDriver(UUID offerId, UUID driverId) {
        log.info("Client selecting driver {} for offer {}", driverId, offerId);
        return repository.findById(offerId)
                .flatMap(offer -> {
                    if (!offer.hasDriverApplied(driverId)) {
                        return Mono.error(new IllegalArgumentException("Driver has not applied."));
                    }
                    
                    Offer updated = offer.withDriverSelected(driverId);
                    
                    return repository.save(updated)
                            .flatMap(saved -> cache.saveInCache(saved).thenReturn(saved))
                            .doOnSuccess(saved -> log.info("Offer {} updated to DRIVER_SELECTED for driver {}", saved.id(), driverId));
                });
    }

    // --- 5. CONFIRMATION (CHAUFFEUR) -> CRÃ‰ATION TRIP ---
    public Mono<Ride> driverAcceptsOffer(UUID offerId, UUID driverId) {
        return repository.findById(offerId)
                .flatMap(offer -> {
                    // 1. VÃ©rification de l'Ã©tat
                    if (offer.state() != OfferState.DRIVER_SELECTED) {
                        return Mono.error(new OfferStatutNotMatchException("Offer must be in DRIVER_SELECTED state."));
                    }

                    // 2. SÃ‰CURITÃ‰ : VÃ©rifier que c'est le BON chauffeur
                    if (offer.selectedDriverId() == null || !offer.selectedDriverId().equals(driverId)) {
                        log.warn("Security Alert: Driver {} tried to accept offer {} meant for driver {}", 
                                driverId, offerId, offer.selectedDriverId());
                        return Mono.error(new IllegalStateException("Access Denied: You are not the selected driver."));
                    }
                    
                    // 3. Passage Ã  VALIDATED
                    return repository.save(offer.withState(OfferState.VALIDATED));
                })
                .flatMap(offer -> {
                    // 4. CrÃ©ation de la course
                    Ride ride = Ride.builder()
                            .id(Utils.generateUUID())
                            .offerId(offer.id())
                            .passengerId(offer.passengerId())
                            .driverId(driverId)
                            .state(RideState.CREATED) // Ã‰tat initial: Chauffeur en route
                            .build();

                    return rideRepositoryPort.save(ride);
                })
                .doOnSuccess(r -> log.info("Driver accepted. Ride created: {}", r.id()));
    }

    // --- 6. ANNULATION (PASSAGER) ---
    public Mono<Offer> cancelOffer(UUID offerId) {
        return repository.findById(offerId)
                .flatMap(offer -> {
                    if (offer.state() == OfferState.VALIDATED) {
                        return Mono.error(new IllegalStateException("Cannot cancel a validated offer. Cancel the ride instead."));
                    }
                    return repository.save(offer.withState(OfferState.CANCELLED));
                });
    }

    // --- UTILITAIRE (Enrichissement & Fake Data UI) ---
    public Mono<Offer> getOfferWithEnrichedBids(UUID offerId) {
        return repository.findById(offerId)
                .flatMap(offer -> {
                    if (offer.bids() == null || offer.bids().isEmpty()) return Mono.just(offer);
                    
                    return Flux.fromIterable(offer.bids())
                            .flatMap(bid -> Mono.zip(
                                    userRepositoryPort.findUserById(bid.driverId()),
                                    locationCachePort.getLocation(bid.driverId()).defaultIfEmpty(new LocationCachePort.Location(0.0, 0.0))
                            ).flatMap(tuple -> etaCalculatorService.calculateEta(tuple.getT2().latitude(), tuple.getT2().longitude(), 0.0, 0.0)
                                    .map(eta -> {
                                        // LOGIQUE DEMO : Choix alÃ©atoire d'un vÃ©hicule pour l'UI
                                        DemoVehicle fakeCar = FAKE_FLEET.get(ThreadLocalRandom.current().nextInt(FAKE_FLEET.size()));
                                        
                                        return Bid.builder()
                                            .driverId(tuple.getT1().id())
                                            .driverName(tuple.getT1().name())
                                            .latitude(tuple.getT2().latitude())
                                            .longitude(tuple.getT2().longitude())
                                            .eta(eta)
                                            .rating(4.5 + (Math.random() * 0.5)) // Note alÃ©atoire entre 4.5 et 5.0
                                            
                                            // Injection des Fake Data VÃ©hicule
                                            .carModel(fakeCar.model())
                                            .carColor(fakeCar.color())
                                            .licensePlate(fakeCar.plate())
                                            .driverImage(fakeCar.image())
                                            .build();
                                    })))
                            .collectList()
                            .map(offer::withBids);
                });
    }

    // --- IMPLEMENTATION CRUD / DEBUG ---

    @Override
    public Flux<Offer> getAllOffers() {
        return repository.findAll();
    }

    @Override
    public Mono<Offer> getOfferById(UUID id) {
        return repository.findById(id)
                .switchIfEmpty(Mono.error(new OfferNotFoundException("Offer not found: " + id)));
    }

    @Override
    public Mono<Offer> updateOffer(UUID id, Offer offerDetails) {
        return repository.findById(id)
                .switchIfEmpty(Mono.error(new OfferNotFoundException("Offer not found: " + id)))
                .flatMap(existingOffer -> {
                    Offer updated = new Offer(
                            existingOffer.id(),
                            existingOffer.passengerId(),
                            existingOffer.selectedDriverId(), 
                            offerDetails.startPoint() != null ? offerDetails.startPoint() : existingOffer.startPoint(),
                            offerDetails.endPoint() != null ? offerDetails.endPoint() : existingOffer.endPoint(),
                            offerDetails.price() > 0 ? offerDetails.price() : existingOffer.price(),
                            existingOffer.state(), 
                            existingOffer.bids(),
                            existingOffer.version()
                    );
                    return repository.save(updated);
                })
                .flatMap(saved -> cache.saveInCache(saved).thenReturn(saved));
    }

    @Override
    public Mono<Boolean> deleteOffer(UUID id) {
        return repository.findById(id)
                .flatMap(offer -> repository.delete(offer).thenReturn(true))
                .defaultIfEmpty(false);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/UserService.java`
```java
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.User;
import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.UserUseCases;
import com.yowyob.rideandgo.domain.ports.out.UserRepositoryPort;
import com.yowyob.rideandgo.domain.ports.out.ExternalUserPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import lombok.extern.slf4j.Slf4j;


import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class UserService implements UserUseCases {

    private final UserRepositoryPort userRepositoryPort;
    private final ExternalUserPort externalUserPort;

    @Override
    public Mono<User> saveUser(User user) {
        return userRepositoryPort.save(user);
    }

    @Override
    public Mono<Boolean> deleteUserById(UUID userId) {
        return userRepositoryPort.deleteById(userId);
    }

    @Override
    public Flux<User> getUsersByRole(RoleType role) {
        return userRepositoryPort.findByRoleName(role);
    }

    @Override
    public Mono<User> getUserById(UUID userId) {
        // RÃ¨gle stricte : Appel Distant -> Sauvegarde Locale -> Retour
        return externalUserPort.fetchRemoteUserById(userId)
                .flatMap(userRepositoryPort::save)
                .doOnSuccess(u -> log.info("âœ… Synced user {} from remote", u.id()));
    }


    @Override
    public Flux<User> getAllUsers() {
        // Appel Distant -> Sauvegarde tout -> Retourne flux sauvegardÃ©
        return externalUserPort.fetchAllRemoteUsers()
                .flatMap(userRepositoryPort::save)
                .doOnComplete(() -> log.info("âœ… Full user list synced from remote"));
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/RideService.java`
```java
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.Ride;
import com.yowyob.rideandgo.domain.model.enums.RideState;
import com.yowyob.rideandgo.domain.ports.in.UpdateRideStatusUseCase;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class RideService implements UpdateRideStatusUseCase {

    private final RideRepositoryPort rideRepository;

    @Override
    public Mono<Ride> updateRideStatus(UUID rideId, RideState newStatus, UUID actorId) {
        return rideRepository.findRideById(rideId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Ride not found with id: " + rideId)))
                .flatMap(ride -> {
                    boolean isDriver = ride.driverId().equals(actorId);
                    boolean isPassenger = ride.passengerId().equals(actorId);

                    // 1. VÃ©rification de SÃ©curitÃ© (Qui es-tu ?)
                    if (!isDriver && !isPassenger) {
                        return Mono.error(new IllegalStateException("Access Denied: You are not involved in this ride."));
                    }

                    // 2. RÃ¨gles MÃ©tier pour le PASSAGER
                    if (isPassenger) {
                        if (newStatus != RideState.CANCELLED) {
                            return Mono.error(new IllegalStateException("Passenger is not allowed to change status to " + newStatus));
                        }
                        if (ride.state() != RideState.CREATED) {
                            return Mono.error(new IllegalStateException("Too late to cancel. The ride has already started or finished."));
                        }
                    }

                    // 3. RÃ¨gles MÃ©tier pour la Machine Ã  Ã‰tats
                    if (!isValidTransition(ride.state(), newStatus)) {
                        return Mono.error(new IllegalStateException(
                                String.format("Invalid transition from %s to %s", ride.state(), newStatus)));
                    }

                    // 4. Application de la mise Ã  jour
                    Ride updatedRide = new Ride(
                            ride.id(),
                            ride.offerId(),
                            ride.passengerId(),
                            ride.driverId(),
                            ride.distance(),
                            ride.duration(),
                            newStatus, 
                            ride.timeReal()
                    );

                    return rideRepository.save(updatedRide);
                })
                .doOnSuccess(r -> log.info("Ride {} status updated to {} by actor {}", r.id(), r.state(), actorId));
    }

    public Mono<Ride> getCurrentRideForDriver(UUID driverId) {
        return rideRepository.findCurrentRideByDriverId(driverId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("No active ride found for this driver")));
    }
    
    // --- NOUVEAU : RÃ©cupÃ©ration par Offre ---
    public Mono<Ride> getRideByOfferId(UUID offerId) {
        return rideRepository.findRideByOfferId(offerId);
    }

    // --- NOUVEAU : RÃ©cupÃ©ration par ID ---
    public Mono<Ride> getRideById(UUID rideId) {
        return rideRepository.findRideById(rideId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Ride not found with id: " + rideId)));
    }

    private boolean isValidTransition(RideState current, RideState target) {
        if (current == target) return true;
        return switch (current) {
            case CREATED -> target == RideState.ONGOING || target == RideState.CANCELLED;
            case ONGOING -> target == RideState.COMPLETED || target == RideState.CANCELLED;
            case COMPLETED, CANCELLED -> false;
        };
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/TrackingCalculatorService.java`
```java
package com.yowyob.rideandgo.application.service;

import org.springframework.stereotype.Service;

@Service
public class TrackingCalculatorService {

    private static final int EARTH_RADIUS_KM = 6371;
    // Vitesse moyenne en ville estimÃ©e Ã  30 km/h pour le MVP
    private static final double AVERAGE_SPEED_KMH = 30.0; 

    /**
     * Calcule la distance Ã  vol d'oiseau (Formule de Haversine).
     * @return Distance en kilomÃ¨tres.
     */
    public double calculateDistance(double lat1, double lon1, double lat2, double lon2) {
        if ((lat1 == lat2) && (lon1 == lon2)) {
            return 0.0;
        }

        double latDistance = Math.toRadians(lat2 - lat1);
        double lonDistance = Math.toRadians(lon2 - lon1);
        
        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)
                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))
                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);
        
        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        
        double distance = EARTH_RADIUS_KM * c;
        
        // Arrondi Ã  2 dÃ©cimales (ex: 1.54 km)
        return Math.round(distance * 100.0) / 100.0;
    }

    /**
     * Estime le temps d'arrivÃ©e (ETA) basÃ© sur la distance et une vitesse moyenne.
     * @param distanceKm La distance en kilomÃ¨tres.
     * @return Temps estimÃ© en minutes (arrondi Ã  l'entier supÃ©rieur).
     */
    public int calculateEtaInMinutes(double distanceKm) {
        if (distanceKm <= 0) return 0;

        // Temps (heures) = Distance / Vitesse
        double timeInHours = distanceKm / AVERAGE_SPEED_KMH;
        
        // Conversion en minutes
        double timeInMinutes = timeInHours * 60;

        // On arrondit toujours Ã  la minute supÃ©rieure pour ne pas Ãªtre en retard
        return (int) Math.ceil(timeInMinutes);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/AuthService.java`
```java
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.enums.RoleType;
import com.yowyob.rideandgo.domain.ports.in.AuthUseCase;
import com.yowyob.rideandgo.domain.ports.out.AuthPort;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.List;

@Service
@RequiredArgsConstructor
public class AuthService implements AuthUseCase {

    private final AuthPort authPort;

    @Override
    public Mono<AuthPort.AuthResponse> login(String identifier, String password) {
        return authPort.login(identifier, password);
    }

    @Override
    public Mono<AuthPort.AuthResponse> register(String username, String email, String password, String phone, String firstName, String lastName, List<RoleType> roles) {
        return authPort.register(username, password, email, phone, firstName, lastName, roles);
    }

    @Override
    public Mono<Void> resetPassword(String email) {
        return authPort.forgotPassword(email);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/LocationService.java`
```java
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.ports.in.GetRideLocationUseCase;
import com.yowyob.rideandgo.domain.ports.in.UpdateLocationUseCase;
import com.yowyob.rideandgo.domain.ports.out.LocationCachePort;
import com.yowyob.rideandgo.domain.ports.out.RideRepositoryPort;
import com.yowyob.rideandgo.infrastructure.adapters.inbound.rest.dto.RideTrackingResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.core.context.ReactiveSecurityContextHolder;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.util.UUID;

@Slf4j
@Service
@RequiredArgsConstructor
public class LocationService implements UpdateLocationUseCase, GetRideLocationUseCase {

    private final LocationCachePort locationCachePort;
    private final RideRepositoryPort rideRepositoryPort;
    private final TrackingCalculatorService trackingCalculatorService; // Injection du nouveau service

    // --- 1. Mise Ã  jour de ma position (Existante) ---
    @Override
    public Mono<Boolean> updateCurrentLocation(Double latitude, Double longitude) {
        return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .flatMap(auth -> {
                    String userIdStr = auth.getName(); 
                    try {
                        UUID userId = UUID.fromString(userIdStr);
                        return locationCachePort.saveLocation(userId, latitude, longitude);
                    } catch (IllegalArgumentException e) {
                        log.error("Security Context principal is not a valid UUID: {}", userIdStr);
                        return Mono.just(false);
                    }
                })
                .switchIfEmpty(Mono.error(new RuntimeException("No security context found for location update")));
    }

    // --- 2. Consultation Intelligente (Nouvelle ImplÃ©mentation) ---
    @Override
    public Mono<RideTrackingResponse> getPartnerLocation(UUID rideId, UUID requesterId) {
        return rideRepositoryPort.findRideById(rideId)
                .switchIfEmpty(Mono.error(new IllegalArgumentException("Ride not found")))
                .flatMap(ride -> {
                    UUID targetId;
                    String targetRole;

                    // DÃ©termination SymÃ©trique
                    if (requesterId.equals(ride.driverId())) {
                        targetId = ride.passengerId();
                        targetRole = "PASSENGER";
                    } else if (requesterId.equals(ride.passengerId())) {
                        targetId = ride.driverId();
                        targetRole = "DRIVER";
                    } else {
                        return Mono.error(new IllegalStateException("Access Denied: You are not part of this ride"));
                    }

                    // RÃ©cupÃ©ration ParallÃ¨le des 2 positions
                    Mono<LocationCachePort.Location> targetLocMono = locationCachePort.getLocation(targetId)
                            .defaultIfEmpty(new LocationCachePort.Location(0.0, 0.0));
                    
                    Mono<LocationCachePort.Location> myLocMono = locationCachePort.getLocation(requesterId)
                            .defaultIfEmpty(new LocationCachePort.Location(0.0, 0.0));

                    return Mono.zip(targetLocMono, myLocMono)
                            .map(tuple -> {
                                LocationCachePort.Location targetLoc = tuple.getT1();
                                LocationCachePort.Location myLoc = tuple.getT2();

                                double distance = 0.0;
                                int eta = 0;

                                // On ne calcule que si les positions sont valides
                                if (targetLoc.latitude() != 0.0 && myLoc.latitude() != 0.0) {
                                    distance = trackingCalculatorService.calculateDistance(
                                            myLoc.latitude(), myLoc.longitude(),
                                            targetLoc.latitude(), targetLoc.longitude()
                                    );
                                    eta = trackingCalculatorService.calculateEtaInMinutes(distance);
                                }

                                return new RideTrackingResponse(
                                        targetLoc.latitude(),
                                        targetLoc.longitude(),
                                        distance,
                                        eta,
                                        targetRole
                                );
                            });
                });
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/FareService.java`
```java
package com.yowyob.rideandgo.application.service;

import com.yowyob.rideandgo.domain.model.Fare;
import com.yowyob.rideandgo.domain.ports.in.PutFareInCacheUseCase;
import com.yowyob.rideandgo.domain.ports.out.FareCachePort;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

@Slf4j
@Service
@RequiredArgsConstructor
public class FareService implements PutFareInCacheUseCase {

    private final FareCachePort fareCachePort;

    @Override
    public Mono<Boolean> putFareInCache(Fare fare) {
        return fareCachePort.saveInCache(fare);
    }
}```

---
### Fichier : `./src/main/java/com/yowyob/rideandgo/application/service/EtaCalculatorService.java`
```java
package com.yowyob.rideandgo.application.service;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;
import java.util.concurrent.ThreadLocalRandom;

@Slf4j
@Service
public class EtaCalculatorService {

    /**
     * Logic: Random value between 3 and 12 minutes for MVP.
     */
    public Mono<Integer> calculateEta(Double startLat, Double startLon, Double endLat, Double endLon) {
        return Mono.fromCallable(() -> ThreadLocalRandom.current().nextInt(3, 13));
    }
}```

---
### Fichier : `./.mvn/wrapper/maven-wrapper.properties`
```properties
wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip
```

---
### Fichier : `./Readme.md`
```md
# ðŸš— Ride & Go API - Guide de dÃ©marrage rapide

Ce guide permet de configurer l'environnement de dÃ©veloppement complet (Postgres, Redis, Kafka) en local.

## ðŸ“‹ PrÃ©requis
- **Java 21**
- **Docker & Docker Compose**

## ðŸš€ Ã‰tape 1 : Lancer l'infrastructure
Depuis la racine du projet :
```bash
docker-compose up -d
```
Ceci dÃ©marre :
- **Postgres** (Port 5432) : Stockage des utilisateurs et offres.
- **Redis** (Port 6379) : Tracking GPS temps rÃ©el (Mot de passe: `password`).
- **Redpanda/Kafka** (Port 9092) : SystÃ¨me de notifications.

## âš™ï¸ Ã‰tape 2 : Configuration de l'application
Assurez-vous que le profil `local` est activÃ© dans `src/main/resources/application.yml` :
```yaml
spring:
  profiles:
    active: local
```

## ðŸ› ï¸ Ã‰tape 3 : Lancer le projet
```bash
./mvnw clean spring-boot:run
```
Le systÃ¨me va automatiquement :
1. CrÃ©er le schÃ©ma central (Postgres).
2. Injecter **100 utilisateurs de test** (5 Admins, 30 Chauffeurs, 65 Passagers).

## âœ… Ã‰tape 4 : Tester le flux Marketplace
1. **Swagger UI** : [http://localhost:8080/swagger-ui.html](http://localhost:8080/swagger-ui.html)
2. **IdentitÃ©s de test (Tokens statiques)** :
   - Client : `Bearer client-token`
   - Chauffeur 1 : `Bearer driver-1-token`
   - Chauffeur 2 : `Bearer driver-2-token`

## ðŸ³ Utilitaires Docker
- Stopper l'infra : `docker-compose stop`
- Tout supprimer (volumes inclus) : `docker-compose down -v`
```

---
### Fichier : `./pom.xml`
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" 
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.6</version>
        <relativePath/>
    </parent>
    
    <groupId>com.yowyob</groupId>
    <artifactId>reactive-hexagonal</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>ride-and-go</name>
    <description>API Ride and Go - Marketplace de transport urbain</description>
    
    <properties>
        <java.version>21</java.version>
        <spring-cloud.version>2023.0.0</spring-cloud.version>
        <mapstruct.version>1.5.5.Final</mapstruct.version>
    </properties>
    
    <dependencies>
        <!-- REACTIVE CORE -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-webflux</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>io.micrometer</groupId>
            <artifactId>micrometer-registry-prometheus</artifactId>
        </dependency>

        <!-- DATA (R2DBC & REDIS) -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-r2dbc</artifactId>
        </dependency>
        
        <!-- CORRECTION CRITIQUE : Enlever le scope runtime pour r2dbc-postgresql -->
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>r2dbc-postgresql</artifactId>
        </dependency>
        
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
        </dependency>

        <!-- MESSAGING (KAFKA) -->
        <dependency>
            <groupId>org.springframework.kafka</groupId>
            <artifactId>spring-kafka</artifactId>
        </dependency>
        <dependency>
            <groupId>io.projectreactor.kafka</groupId>
            <artifactId>reactor-kafka</artifactId>
            <version>1.3.22</version>
        </dependency>

        <!-- CLOUD & RESILIENCE -->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-circuitbreaker-reactor-resilience4j</artifactId>
        </dependency>

        <!-- TOOLS (Lombok & Mapstruct) -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>
        
        <!-- Docker Compose Auto-setup -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-docker-compose</artifactId>
            <scope>runtime</scope>
            <optional>true</optional>
        </dependency>
        
        <!-- Test -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>io.projectreactor</groupId>
            <artifactId>reactor-test</artifactId>
            <scope>test</scope>
        </dependency>

        <!-- Documentation API (Swagger/OpenAPI) -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webflux-ui</artifactId>
            <version>2.5.0</version>
        </dependency>
        
        <!-- SPRING SECURITY REACTIVE -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

        <!-- SECURITY TESTING -->
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>1.18.30</version>
                        </path>
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok-mapstruct-binding</artifactId>
                            <version>0.2.0</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>```

---
### Fichier : `./.github/workflows/ci-cd.yml`
```yaml
name: Spring Boot CI/CD

on:
  push:
    branches:
      - "**"
      #- main

env:
  REGISTRY_IMAGE: ghcr.io/${{ github.repository_owner }}/ride-and-go
  APP_NAME: ride-and-go
  HEALTH_DELAY: ${{ secrets.DEPLOY_DELAY }}
  CONTAINER_NAME: ride-and-go

jobs:
  tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up JDK
        uses: actions/setup-java@v3
        with:
          distribution: 'temurin'
          java-version: 21

      - name: Run Unit Tests + SonarQube Analysis
        continue-on-error: true
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        run: |
          mvn clean verify sonar:sonar \
            -Dsonar.projectKey=${{ env.APP_NAME }} \
            -Dsonar.projectName=${{ env.APP_NAME }} \
            -Dsonar.host.url=${{ secrets.SONAR_HOST_URL }}

  build:
    needs: tests
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Log in to GitHub Container Registry
        run: |
          echo "${{ secrets.PERSONAL_ACCESS_TOKEN }}" | docker login ghcr.io -u ${{ secrets.REGISTRY_NAMESPACE }} --password-stdin

      - name: Use prod.application.yml
        run: |
          echo "Using prod.application.yml"
          rm src/main/resources/application.yml
          mv src/main/resources/prod.application.yml src/main/resources/application.yml
          cat src/main/resources/application.yml

      - name: Build Docker image
        run: |
          echo "Building Docker image..."
          docker build -t ${{ env.REGISTRY_IMAGE }}:latest .

      - name: Push Docker image
        run: |
          echo "Pushing Docker image..."
          docker push ${{ env.REGISTRY_IMAGE }}:latest


  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Add SSH key
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Deploy on server
        run: |
          ssh -o StrictHostKeyChecking=no ${{ secrets.REMOTE_USER }}@${{ secrets.REMOTE_HOST }} << 'EOF'

            echo "Pulling latest image ${{ env.REGISTRY_IMAGE }}"

            docker login ghcr.io -u ${{ secrets.REGISTRY_NAMESPACE }} -p ${{ secrets.PERSONAL_ACCESS_TOKEN }}

            cd /root/projet_synthese/infra

            echo "Stopping container"
            docker compose down ${{ env.CONTAINER_NAME }}

            echo "Removing old image"
            docker rmi -f ${{ env.REGISTRY_IMAGE }}:latest || true

            echo "Pulling new image"
            docker pull ${{ env.REGISTRY_IMAGE }}:latest

            echo " Starting container"
            docker compose up -d ${{ env.CONTAINER_NAME }}

            echo " Waiting ${{ env.HEALTH_DELAY }} seconds for health check"
            sleep ${{ env.HEALTH_DELAY }}

            echo " Checking container health..."
            STATUS=$(docker inspect --format='{{json .State.Health.Status}}' ${{ env.CONTAINER_NAME }})

            echo "Health status: $STATUS"

            if [ "$STATUS" != "\"healthy\"" ]; then
              echo "ERROR: Container is not healthy"
              exit 1
            fi

            echo "Deployment successful & container healthy!"
          EOF
```

---
### Fichier : `./docker-compose.yml`
```yaml
services:
  # 1. Base de donnÃ©es PostgreSQL
  postgres:
    image: postgres:16
    container_name: ride-go-db
    ports:
      - "5432:5432"
    environment:
      POSTGRES_DB: yowyob_db
      POSTGRES_USER: fleet_admin
      POSTGRES_PASSWORD: fleet_password
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # 2. Cache Redis pour le tracking GPS
  redis:
    image: redis:alpine
    container_name: ride-go-redis
    ports:
      - "6379:6379"
    command: redis-server --requirepass password

  # 3. Kafka (Redpanda) pour les notifications
  redpanda:
    image: docker.redpanda.com/redpandadata/redpanda:latest
    container_name: ride-go-kafka
    ports:
      - "9092:9092"
    command:
      - redpanda start
      - --overprovisioned
      - --smp 1
      - --memory 1G
      - --reserve-memory 0M
      - --node-id 0
      - --check=false
      - --kafka-addr plaintext://0.0.0.0:29092,external://0.0.0.0:9092
      - --advertise-kafka-addr plaintext://redpanda:29092,external://localhost:9092

volumes:
  postgres_data:```
